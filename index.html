<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1e3a5f">
    <title>The Spread Sheet - College Basketball Analytics & Betting Picks</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Data-driven college basketball analytics and betting picks. Get daily game predictions, win probabilities, spread analysis, and statistical validation. Data don't lie.">
    <meta name="keywords" content="college basketball, NCAAB, betting picks, sports analytics, spread predictions, win probability, KenPom, basketball statistics, March Madness">
    <meta name="author" content="The Spread Sheet">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://thespreadsheet.com">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://thespreadsheet.com">
    <meta property="og:title" content="The Spread Sheet - College Basketball Analytics">
    <meta property="og:description" content="Data-driven college basketball analytics and betting picks. Daily predictions with win probabilities and statistical validation.">
    <meta property="og:image" content="assets/brand/logo-horizontal.png">
    <meta property="og:image:alt" content="The Spread Sheet - College basketball analytics with data trend visualization">
    <meta property="og:site_name" content="The Spread Sheet">
    <meta property="og:locale" content="en_US">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://thespreadsheet.com">
    <meta name="twitter:title" content="The Spread Sheet - College Basketball Analytics">
    <meta name="twitter:description" content="Data-driven NCAAB predictions. Win probabilities, spread analysis, and validated performance tracking.">
    <meta name="twitter:image" content="assets/brand/logo-horizontal.png">
    <meta name="twitter:image:alt" content="The Spread Sheet - Data Don't Lie">

    <!-- Additional Meta -->
    <meta name="application-name" content="The Spread Sheet">
    <meta name="msapplication-TileColor" content="#1e3a5f">
    <meta name="format-detection" content="telephone=no">
    <!-- Favicon - Basketball with trend line (SVG primary, PNG fallbacks) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23ff8c42' stroke='%231e3a5f' stroke-width='4'/%3E%3Cpath d='M 50 4 Q 18 50 50 96' fill='none' stroke='%231e3a5f' stroke-width='3' stroke-linecap='round'/%3E%3Cpath d='M 50 4 Q 82 50 50 96' fill='none' stroke='%231e3a5f' stroke-width='3' stroke-linecap='round'/%3E%3Cpath d='M 6 40 Q 50 55 94 40' fill='none' stroke='%231e3a5f' stroke-width='3' stroke-linecap='round'/%3E%3Cpath d='M 6 60 Q 50 45 94 60' fill='none' stroke='%231e3a5f' stroke-width='3' stroke-linecap='round'/%3E%3Cpath d='M 25 68 L 42 48 L 58 58 L 78 32' fill='none' stroke='white' stroke-width='5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpolygon points='78,32 66,36 70,46' fill='white'/%3E%3C/svg%3E">
    <link rel="alternate icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAA6BJREFUWIXtl01oXFUUx3/nvjczmUwm0yRNmrRpEhNtjWJBu1DBhYIuuuqi4EoR3LgQF+5EV4Kg4ELduBGhCwXBjYsuFCkuFMSFiFIp1VqbNmlsk8x8vzfv3OtiXjJJJpmJCe3C/8A97517zvn/z7nv3HshISEhISEhISEhISEh4f8MiVrYdQDZbDavdH5PRErA3b8AMeZEJAN0b9s2NOfct4BqGIZPGGMeTaVSp40xs+12u8i2XVGRh0TkpDHmOOCMMV8bY95LpVLPGWNOWWu/AraiCNStfhE5KiKvAx8bY4LwQ6RxpzPgxDYVvW/b9gVgo4jcJSLvAiOAHSfUZqT9HlkE1gHbReRdEVlqjKkYY0b+DePrDuoGh5xdKpAVkeOAisg1rdbP0YG1CMYQOkQBK1xG1K5Xq51NdEm/AZahuh7YAKwF/gTe3kx+lOEtOCBwwCFt2xcBo4AXzPb5iFwE3gH2An2xUv8NPhCR3wA/DMM7ReTHVCr1DvCQMeZ7a+0XwCURuRU4DSwHPgXWiMgfIrLJWvumqA7arva8s3tUtJgHqsjvIvI80COqhwBOGYIZoB9YJqpbgW2oPhFO6O8RKRhj7kuVSqU7gVUi8l9g4nYr2FYsG0VF+vfFYcwAIIpkAHWfk0BeRA6GYRgfVFARWS0iz4mILyJXgdUi8qSI7BaRM8A5EfnbWptMJrO9LBOmY9sLDdH1r6I6JhLqJlE9JKL/iMgFVHNBEBxzziUCuRKwBngKeBi4FygCf2UymZ+stSeNMa+IyOsajf8qIv1+EIT5IAgORX5YRNIQcZnCwBagiGpPYWRkUx/wjohcCC2CwGbgQVENqkgl+0R1v6geEgm7nXMjxphOVF8WkcMisgHoBvbiBoQCh1ANQ+8p4IpIXJKyBlGZC6wD7hCJfhGRR0V1k4j8DFwZ0oIXIK85l+tQaZnhYsE0TlELXME5FwSpVGqGSOinGfAVAdlsNt8UvNlsHmumZ5gBCIPAbwJPYE2Eh3JuKLHOZjPh8FjMOVc3BlT6+vpmmJzRaB2APsAzxlQajUZPR0fHSVV9tqOj44yI/AakjTGHReSliLn0V1B+7b/BG3ATuNsY85qIXPf9xjwPVB98KPpFRN5CNR2G4XljzCsi8h0w6JxbGpk9CawDlphjp1T1OVQfFJHvgO8HB4fvKqJaAq4ZY4qJ9CpRnaEqS1T1NRF5BVgQhmG8NI8dNP6tSXa0BAAAAAElFTkSuQmCC">
    <link rel="alternate icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAdgAAAHYBTnsmCAAAADNJREFUOI1jYKAQMOKS+P//PwMjIyMDAwMDA8P///8Zhv2LGBgYGBjOnTvH8P//f4ZhbwYAKhIHMf4CfR8AAAAASUVORK5CYII=">
    <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAA6BJREFUWIXtl01oXFUUx3/nvjczmUwm0yRNmrRpEhNtjWJBu1DBhYIuuuqi4EoR3LgQF+5EV4Kg4ELduBGhCwXBjYsuFCkuFMSFiFIp1VqbNmlsk8x8vzfv3OtiXjJJJpmJCe3C/8A97517zvn/z7nv3HshISEhISEhISEhISEh4f8MiVrYdQDZbDavdH5PRErA3b8AMeZEJAN0b9s2NOfct4BqGIZPGGMeTaVSp40xs+12u8i2XVGRh0TkpDHmOOCMMV8bY95LpVLPGWNOWWu/AraiCNStfhE5KiKvAx8bY4LwQ6RxpzPgxDYVvW/b9gVgo4jcJSLvAiOAHSfUZqT9HlkE1gHbReRdEVlqjKkYY0b+DePrDuoGh5xdKpAVkeOAisg1rdbP0YG1CMYQOkQBK1xG1K5Xq51NdEm/AZahuh7YAKwF/gTe3kx+lOEtOCBwwCFt2xcBo4AXzPb5iFwE3gH2An2xUv8NPhCR3wA/DMM7ReTHVCr1DvCQMeZ7a+0XwCURuRU4DSwHPgXWiMgfIrLJWvumqA7arva8s3tUtJgHqsjvIvI80COqhwBOGYIZoB9YJqpbgW2oPhFO6O8RKRhj7kuVSqU7gVUi8l9g4nYr2FYsG0VF+vfFYcwAIIpkAHWfk0BeRA6GYRgfVFARWS0iz4mILyJXgdUi8qSI7BaRM8A5EfnbWptMJrO9LBOmY9sLDdH1r6I6JhLqJlE9JKL/iMgFVHNBEBxzziUCuRKwBngKeBi4FygCf2UymZ+stSeNMa+IyOsajf8qIv1+EIT5IAgORX5YRNIQcZnCwBagiGpPYWRkUx/wjohcCC2CwGbgQVENqkgl+0R1v6geEgm7nXMjxphOVF8WkcMisgHoBvbiBoQCh1ANQ+8p4IpIXJKyBlGZC6wD7hCJfhGRR0V1k4j8DFwZ0oIXIK85l+tQaZnhYsE0TlELXME5FwSpVGqGSOinGfAVAdlsNt8UvNlsHmumZ5gBCIPAbwJPYE2Eh3JuKLHOZjPh8FjMOVc3BlT6+vpmmJzRaB2APsAzxlQajUZPR0fHSVV9tqOj44yI/AakjTGHReSliLn0V1B+7b/BG3ATuNsY85qIXPf9xjwPVB98KPpFRN5CNR2G4XljzCsi8h0w6JxbGpk9CawDlphjp1T1OVQfFJHvgO8HB4fvKqJaAq4ZY4qJ9CpRnaEqS1T1NRF5BVgQhmG8NI8dNP6tSXa0BAAAAAElFTkSuQmCC">

    <!-- Preconnect to Google Fonts for faster font loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Playfair+Display:wght@600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/brand.css?v=20260122d">
    <style>
        :root { --transition-speed: 0.25s; }

        /* LIGHT MODE - Warm Premium */
        [data-theme="light"] {
            --bg-body: #f9f7f4;
            --bg-primary: #ffffff;
            --bg-secondary: #f5f3f0;
            --bg-card: #ffffff;
            --bg-card-hover: #fdfcfb;
            --bg-input: #f5f3f0;
            --bg-nav: #1e3a5f;
            --border-color: #e8e4df;
            --border-light: #f0ece7;
            --text-primary: #1e3a5f;
            --text-secondary: #5a6a7a;
            --text-muted: #8a9aaa;
            --shadow-sm: 0 1px 3px rgba(30, 58, 95, 0.04);
            --shadow-card: 0 2px 8px rgba(30, 58, 95, 0.06), 0 1px 3px rgba(30, 58, 95, 0.04);
            --shadow-hover: 0 8px 24px rgba(30, 58, 95, 0.1);
            --shadow-nav: 0 4px 20px rgba(30, 58, 95, 0.15);
            /* Semantic accent - for headings, highlights that adapt to theme */
            --accent-theme: var(--navy);
            --accent-theme-text: var(--navy);
        }

        /* DARK MODE - Navy Premium */
        [data-theme="dark"] {
            --bg-body: #0d1926;
            --bg-primary: #132337;
            --bg-secondary: #1a2d42;
            --bg-card: #1a2d42;
            --bg-card-hover: #213548;
            --bg-input: #132337;
            --bg-nav: #0d1926;
            --border-color: #2a3f54;
            --border-light: #344a5f;
            --text-primary: #f5f3f0;
            --text-secondary: #a8b8c8;
            --text-muted: #6a7a8a;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.2);
            --shadow-card: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.15);
            --shadow-hover: 0 8px 24px rgba(0, 0, 0, 0.3);
            --shadow-nav: 0 4px 20px rgba(0, 0, 0, 0.3);
            /* Semantic accent - for headings, highlights that adapt to theme */
            --accent-theme: var(--orange);
            --accent-theme-text: var(--orange);
        }

        /* Brand Colors - Used Sparingly */
        :root {
            --navy: #1e3a5f;
            --navy-light: #2a4a70;
            --orange: #ff8c42;
            --orange-hover: #ff9d5c;
            --orange-dim: rgba(255, 140, 66, 0.12);
            --cream: #f9f7f4;
            
            --accent-green: #22c55e;
            --accent-green-dim: rgba(34, 197, 94, 0.12);
            --accent-red: #ef4444;
            --accent-red-dim: rgba(239, 68, 68, 0.12);
            --accent-yellow: #eab308;
            --accent-yellow-dim: rgba(234, 179, 8, 0.12);
            --accent-blue: #3b82f6;
            --accent-blue-dim: rgba(59, 130, 246, 0.12);
            
            /* Themed Confidence Colors (Orange/Navy/Blue/Gray Palette) */
            --conf-bestbet: #f59e0b;
            --conf-bestbet-dim: rgba(245, 158, 11, 0.15);
            --conf-bestbet-border: rgba(245, 158, 11, 0.5);
            --conf-elite: #ff8c42;
            --conf-elite-dim: rgba(255, 140, 66, 0.12);
            --conf-elite-border: rgba(255, 140, 66, 0.4);
            --conf-high: #1e3a5f;
            --conf-high-dim: rgba(30, 58, 95, 0.12);
            --conf-high-border: rgba(30, 58, 95, 0.4);
            --conf-medium: #4a8fd4;
            --conf-medium-dim: rgba(74, 143, 212, 0.12);
            --conf-medium-border: rgba(74, 143, 212, 0.4);
            --conf-low: #8a9aaa;
            --conf-low-dim: rgba(138, 154, 170, 0.12);
            --conf-low-border: rgba(138, 154, 170, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        /* ========== ACCESSIBILITY IMPROVEMENTS ========== */

        /* Skip to main content link - hidden until focused */
        .skip-link {
            position: absolute;
            top: -100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            background: var(--orange);
            color: white;
            font-weight: 600;
            text-decoration: none;
            border-radius: 0 0 8px 8px;
            z-index: 9999;
            transition: top 0.2s;
        }

        .skip-link:focus {
            top: 0;
            outline: none;
        }

        /* Global focus visible styles for keyboard navigation */
        :focus-visible {
            outline: 2px solid var(--orange);
            outline-offset: 2px;
        }

        /* Remove default focus for mouse users */
        :focus:not(:focus-visible) {
            outline: none;
        }

        /* Ensure interactive elements have sufficient touch target (44px) */
        button, .tab, .filter-pill, select {
            min-height: 44px;
        }

        /* Reduce motion for users who prefer it */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Improve screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Ensure sufficient color contrast in both themes */
        [data-theme="light"] .text-muted { color: #5a6a7a; }
        [data-theme="dark"] .text-muted { color: #9aabb8; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-body);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            transition: background var(--transition-speed), color var(--transition-speed);
            -webkit-font-smoothing: antialiased;
            /* Safe area for notched phones */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
        }

        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 0.5rem;
            padding-top: max(0.5rem, env(safe-area-inset-top));
        }

        /* ========== STICKY NAV WRAPPER ========== */
        .sticky-nav-wrapper {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--bg-body);
            padding-top: 0.5rem;
            margin: -0.5rem -0.5rem 0 -0.5rem;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }

        /* ========== HEADER ========== */
        .header {
            background: var(--bg-nav);
            border-radius: 10px;
            padding: 0.625rem 1.25rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-nav);
        }

        .header-left { display: flex; align-items: center; gap: 1rem; }
        
        .logo-img { 
            height: 48px; 
            width: 48px;
            border-radius: 50%;
        }
        
        .logo-text-group { display: flex; flex-direction: column; }
        
        .logo-title {
            font-family: 'Playfair Display', Georgia, serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.01em;
            line-height: 1.1;
        }
        
        .logo-tagline {
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255,255,255,0.7);
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        .header-right { display: flex; align-items: center; gap: 1rem; }
        
        .header-status {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.9);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-yellow);
        }

        /* Share Button Group (Desktop/Mobile Export) */
        .share-btn-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .share-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.1);
            border: 2px solid var(--orange);
            border-radius: 8px;
            color: rgba(255,255,255,0.9);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .share-btn:hover {
            background: rgba(255, 140, 66, 0.15);
            border-color: var(--orange-hover);
            transform: translateY(-1px);
        }
        
        .share-btn:active {
            transform: translateY(0);
        }
        
        .share-btn-icon {
            font-size: 1rem;
            line-height: 1;
        }
        
        .share-btn-label {
            letter-spacing: 0.02em;
        }
        
        /* Metrics Bar Wrapper & Toggle */
        .metrics-bar-wrapper {
            margin-bottom: 0.5rem;
        }
        
        .metrics-bar-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.625rem 1rem;
            background: linear-gradient(135deg, var(--navy) 0%, var(--navy-light) 100%);
            border: 2px solid var(--orange);
            border-radius: 10px;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 44px;
        }
        
        .metrics-bar-toggle:hover {
            background: linear-gradient(135deg, var(--navy-light) 0%, var(--navy) 100%);
            box-shadow: 0 4px 12px rgba(30, 58, 95, 0.3);
        }
        
        .metrics-bar-toggle[aria-expanded="true"] {
            border-radius: 10px 10px 0 0;
            border-bottom: none;
        }
        
        .metrics-bar-toggle-icon {
            font-size: 0.7rem;
            transition: transform 0.2s ease;
            color: var(--orange);
        }
        
        .metrics-bar-toggle[aria-expanded="true"] .metrics-bar-toggle-icon {
            transform: rotate(90deg);
        }
        
        .metrics-bar-toggle-text {
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        
        .metrics-bar-toggle-preview {
            background: rgba(255, 255, 255, 0.15);
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--orange);
        }
        
        /* Metrics Bar Content */
        .metrics-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 2px solid var(--orange);
            border-top: none;
            border-radius: 0 0 10px 10px;
            transition: max-height 0.3s ease, opacity 0.2s ease, padding 0.3s ease;
            max-height: 200px;
            overflow: hidden;
        }
        
        .metric-chip {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-body);
            border-radius: 8px;
            min-width: 80px;
        }
        
        .metric-chip-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--navy);
        }
        
        .metric-chip-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .metric-chip-ci {
            font-size: 0.6rem;
            color: var(--text-muted);
        }
        
        /* Hamburger Menu */
        .hamburger-menu-container {
            position: relative;
        }
        
        .hamburger-btn {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 12px;
            transition: all 0.2s;
        }
        
        .hamburger-btn:hover,
        .hamburger-btn:focus { 
            background: rgba(255,255,255,0.2); 
            outline: none;
        }
        
        .hamburger-btn:focus-visible {
            box-shadow: 0 0 0 2px var(--orange);
        }
        
        .hamburger-btn .bar {
            width: 20px;
            height: 2px;
            background: white;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        .hamburger-btn[aria-expanded="true"] .bar:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        
        .hamburger-btn[aria-expanded="true"] .bar:nth-child(2) {
            opacity: 0;
        }
        
        .hamburger-btn[aria-expanded="true"] .bar:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        
        .hamburger-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            min-width: 220px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: var(--shadow-hover);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 1000;
            overflow: hidden;
        }
        
        .hamburger-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .hamburger-dropdown-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            width: 100%;
            padding: 0.875rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            font-family: inherit;
        }
        
        .hamburger-dropdown-item:hover,
        .hamburger-dropdown-item:focus {
            background: var(--bg-input);
            outline: none;
        }
        
        .hamburger-dropdown-item:focus-visible {
            background: var(--bg-input);
            box-shadow: inset 0 0 0 2px var(--orange);
        }
        
        .hamburger-dropdown-item .menu-icon {
            font-size: 1.1rem;
            width: 24px;
            text-align: center;
        }
        
        .hamburger-dropdown-divider {
            height: 1px;
            background: var(--border-color);
            margin: 0.25rem 0;
        }
        
        [data-theme="dark"] .hamburger-dropdown-divider {
            background: var(--border-light);
            opacity: 0.6;
        }
        
        /* Theme toggle row in menu */
        .menu-theme-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .menu-theme-label {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .menu-theme-label .menu-icon {
            font-size: 1.1rem;
            width: 24px;
            text-align: center;
        }
        
        .theme-toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .theme-toggle-switch:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--orange);
        }
        
        .theme-toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: all 0.2s;
        }
        
        .theme-toggle-switch[aria-checked="true"] {
            background: var(--orange);
            border-color: var(--orange);
        }
        
        .theme-toggle-switch[aria-checked="true"]::after {
            left: 24px;
            background: white;
        }
        
        /* Glossary Modal */
        .glossary-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
            animation: fadeIn 0.2s ease;
        }
        
        [data-theme="light"] .glossary-modal-overlay {
            background: rgba(30, 58, 95, 0.4);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .glossary-modal {
            background: var(--bg-card);
            border-radius: 16px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.25s ease;
        }
        
        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .glossary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .glossary-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }
        
        .glossary-close {
            width: 36px;
            height: 36px;
            border: none;
            background: var(--bg-input);
            border-radius: 8px;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .glossary-close:hover {
            background: var(--accent-red-dim);
            color: var(--accent-red);
        }
        
        .glossary-close:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--orange);
        }
        
        .glossary-content {
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(80vh - 80px);
        }
        
        .glossary-section {
            margin-bottom: 1.5rem;
        }
        
        .glossary-section:last-child {
            margin-bottom: 0;
        }
        
        .glossary-section h3 {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--accent-theme);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        .glossary-list {
            margin: 0;
        }
        
        .glossary-list dt {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
            margin-top: 0.75rem;
        }
        
        .glossary-list dt:first-child {
            margin-top: 0;
        }
        
        .glossary-list dd {
            margin: 0.25rem 0 0 0;
            color: var(--text-secondary);
            font-size: 0.82rem;
            line-height: 1.5;
        }
        
        /* How It Works list styling */
        .glossary-list.how-list dt {
            font-size: 0.95rem;
            margin-top: 1rem;
            color: var(--accent-theme);
        }
        .glossary-list.how-list dt:first-child {
            margin-top: 0;
        }
        .glossary-list.how-list dd {
            font-size: 0.85rem;
            line-height: 1.6;
        }
        
        /* Alphabetical glossary - compact two-column on larger screens */
        .glossary-list.alphabetical dt {
            margin-top: 0.875rem;
        }
        .glossary-list.alphabetical dt:first-child {
            margin-top: 0;
        }
        
        /* ========== SETTINGS MODAL ========== */
        .settings-modal {
            max-width: 600px;
        }
        .settings-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .settings-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .settings-section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
        .settings-field-modal {
            margin-bottom: 1rem;
        }
        .settings-field-modal .settings-label {
            display: block;
            margin-bottom: 0.5rem;
        }
        .settings-field-modal .settings-input {
            width: 100%;
            box-sizing: border-box;
        }
        .settings-hint {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            margin-bottom: 0.75rem;
            line-height: 1.4;
        }
        .settings-save-btn {
            background: var(--accent-blue);
            color: white;
            border: none;
            padding: 0.6rem 1.25rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        .settings-save-btn:hover {
            background: var(--navy-light);
            transform: translateY(-1px);
        }
        .settings-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .settings-action-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.7rem 1rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .settings-action-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent-blue);
        }
        .settings-action-btn .btn-icon {
            font-size: 1.1rem;
        }
        .settings-action-btn.danger {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        .settings-action-btn.danger:hover {
            background: var(--accent-red);
            color: white;
        }
        .danger-zone {
            background: rgba(239, 68, 68, 0.05);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 0.5rem;
        }
        .danger-zone h3 {
            color: var(--accent-red);
        }
        [data-theme="dark"] .danger-zone {
            background: rgba(239, 68, 68, 0.1);
        }
        
        /* Validation Notes */
        .validation-notes-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        @media (max-width: 600px) {
            .validation-notes-container {
                grid-template-columns: 1fr;
            }
        }
        .validation-notes-column {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .validation-notes-column .settings-label {
            font-size: 0.85rem;
            font-weight: 600;
        }
        .validation-notes-column .settings-label.working {
            color: var(--accent-green);
        }
        .validation-notes-column .settings-label.issues {
            color: var(--accent-yellow);
        }
        .validation-notes-input {
            width: 100%;
            min-height: 140px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.5;
            resize: vertical;
            box-sizing: border-box;
        }
        .validation-notes-input::placeholder {
            color: var(--text-muted);
            opacity: 0.7;
        }
        .validation-notes-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        /* Responsive header */
        @media (max-width: 700px) {
            .header { flex-direction: column; gap: 1rem; text-align: center; padding: 1rem; }
            .header-left { flex-direction: column; }
            .header-right { width: 100%; justify-content: center; }
            .header-status { display: none; }
            .logo-title { font-size: 1.25rem; }
        }

        /* ========== SETTINGS PANEL ========== */
        .settings-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: 0.75rem;
            overflow: hidden;
            box-shadow: var(--shadow-card);
            display: none;
        }
        
        .settings-panel.expanded { display: block; }
        
        .settings-content {
            padding: 0.875rem;
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 0.75rem;
            align-items: end;
        }
        
        .settings-field { display: flex; flex-direction: column; gap: 0.4rem; }
        .settings-label { font-size: 0.75rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        
        .settings-input {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: 'JetBrains Mono', monospace;
            transition: border-color 0.2s;
        }
        
        .settings-input:focus { outline: none; border-color: var(--orange); }
        
        .settings-actions { display: flex; gap: 0.75rem; }
        
        .btn-refresh {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            background: var(--orange);
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-refresh:hover { background: var(--orange-hover); }
        .btn-refresh:disabled { opacity: 0.6; cursor: not-allowed; }
        
        /* ========== BOUNCING BASKETBALL REFRESH ANIMATION ========== */
        .refresh-icon-container {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        
        .refresh-basketball {
            width: 18px;
            height: 18px;
            display: inline-block;
        }
        
        .refresh-basketball svg {
            width: 100%;
            height: 100%;
        }
        
        /* Bouncing animation */
        @keyframes basketball-bounce {
            0%, 100% {
                transform: translateY(0);
                animation-timing-function: ease-out;
            }
            50% {
                transform: translateY(-6px);
                animation-timing-function: ease-in;
            }
        }
        
        .btn-refresh.refreshing .refresh-basketball {
            animation: basketball-bounce 1s ease-in-out infinite;
        }
        
        /* Reduced motion: subtle pulse instead of bounce */
        @media (prefers-reduced-motion: reduce) {
            @keyframes basketball-pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.6; }
            }
            
            .btn-refresh.refreshing .refresh-basketball {
                animation: basketball-pulse 1.5s ease-in-out infinite;
            }
        }
        
        /* Screen reader announcements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* ========== GLOBAL FOCUS STYLES ========== */
        /* Consistent focus-visible for keyboard navigation */
        .tab:focus-visible,
        .filter-pill:focus-visible,
        .filter-select:focus-visible,
        .btn:focus-visible,
        .team-search-clear:focus-visible,
        .analytics-toggle:focus-visible {
            outline: 2px solid var(--orange);
            outline-offset: 2px;
        }
        
        [data-theme="light"] .tab:focus-visible,
        [data-theme="light"] .filter-pill:focus-visible {
            outline-color: var(--navy);
        }
        
        /* ========== DARK MODE CONFIDENCE COLOR ADJUSTMENTS ========== */
        /* High confidence in dark mode needs lighter navy for readability */
        [data-theme="dark"] {
            --conf-high: #4a7ab8;
            --conf-high-dim: rgba(74, 122, 184, 0.15);
            --conf-high-border: rgba(74, 122, 184, 0.5);
        }
        
        /* Ensure score badges are visible in dark mode */
        [data-theme="dark"] .score-badge.high { 
            background: linear-gradient(135deg, #4a7ab8, #3a6aa8); 
        }
        
        [data-theme="dark"] .pick-col.has-pick.high { 
            border-color: rgba(74, 122, 184, 0.5); 
            background: rgba(74, 122, 184, 0.12);
        }
        
        [data-theme="dark"] .confidence-ring-mini.high .conf-value,
        [data-theme="dark"] .top5-conf-value.high,
        [data-theme="dark"] .picks-summary-card.high .picks-summary-count {
            color: #6b9ed8;
        }
        
        [data-theme="dark"] .top5-conf-fill.high {
            background: linear-gradient(90deg, #4a7ab8, #3a6aa8);
        }
        
        [data-theme="dark"] .game-card.high {
            border-top-color: #4a7ab8;
            border-color: rgba(74, 122, 184, 0.4);
        }
        
        [data-theme="dark"] .best-bet-card.high {
            border-color: #4a7ab8;
            box-shadow: 0 4px 20px rgba(74, 122, 184, 0.2);
        }
        
        [data-theme="dark"] .score-pill.high {
            background: rgba(74, 122, 184, 0.15);
            color: #6b9ed8;
        }

        /* ========== NAVIGATION TABS ========== */
        .tabs-container {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 0.25rem;
            margin-bottom: 0.75rem;
            display: flex;
            gap: 0.2rem;
            overflow-x: auto;
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 50;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }

        @supports (background: color-mix(in srgb, red 50%, blue)) {
            .tabs-container {
                background: color-mix(in srgb, var(--bg-card) 88%, transparent);
            }
        }

        /* When sticky, add subtle bottom shadow for depth */
        .tabs-container.stuck {
            border-radius: 0 0 10px 10px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }

        .tab {
            padding: 0.5rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
        }

        .tab:hover { background: var(--bg-input); color: var(--text-primary); }
        .tab:focus { outline: none; }
        .tab:focus-visible { 
            outline: 2px solid var(--navy); 
            outline-offset: -2px;
        }
        [data-theme="dark"] .tab:focus-visible {
            outline-color: var(--orange);
        }
        
        .tab.active {
            background: var(--navy);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        /* Active tab underline indicator */
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 1px;
        }

        /* ===== Tab Badges ===== */
        .tab-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 18px;
            padding: 0 5px;
            border-radius: 9px;
            font-size: 0.65rem;
            font-weight: 700;
            font-family: 'JetBrains Mono', monospace;
            line-height: 1;
            margin-left: 4px;
            vertical-align: middle;
        }
        .tab-badge:empty { display: none; }
        .tab.active .tab-badge {
            background: rgba(255,255,255,0.25);
            color: white;
        }
        .tab:not(.active) .tab-badge {
            background: var(--orange-dim);
            color: var(--orange);
        }

        /* ===== Tab Divider ===== */
        .tab-divider {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            align-self: center;
            margin: 0 2px;
            flex-shrink: 0;
        }

        /* ===== Legend Toggle ===== */
        .tab-legend-toggle {
            width: 28px;
            height: 28px;
            min-height: 28px;
            border-radius: 50%;
            border: 1.5px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-muted);
            font-size: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            flex-shrink: 0;
            transition: all 0.2s;
            align-self: center;
        }
        .tab-legend-toggle:hover {
            border-color: var(--orange);
            color: var(--orange);
            background: var(--orange-dim);
        }

        /* ===== Game Card Left Border (Confidence Tier) ===== */
        .game-card-new {
            border-left: 4px solid var(--border-color);
        }
        .game-card-new.tier-bestbet { border-left-color: var(--conf-bestbet); }
        .game-card-new.tier-elite   { border-left-color: var(--conf-elite); }
        .game-card-new.tier-high    { border-left-color: var(--conf-high); }
        .game-card-new.tier-medium  { border-left-color: var(--conf-medium); }
        .game-card-new.tier-low     { border-left-color: var(--border-color); }

        /* ===== Card Entrance Animation ===== */
        @keyframes cardFadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        .game-card-new, .bb-pick-card {
            animation: cardFadeInUp 0.3s ease both;
        }

        [data-theme="light"] .tab.active {
            background: var(--navy);
            color: white;
        }

        [data-theme="dark"] .tab.active {
            background: var(--orange);
            color: white;
        }

        /* ========== SECTION HEADERS ========== */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .section-title {
            font-family: 'Playfair Display', Georgia, serif;
            font-size: 1.35rem;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.01em;
        }

        /* ========== FILTER CONTROLS ========== */
        .filter-pills { display: flex; gap: 0.35rem; align-items: center; flex-wrap: wrap; }

        .filter-pill {
            padding: 0.35rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-pill:hover { border-color: var(--accent-theme); color: var(--text-primary); }
        [data-theme="dark"] .filter-pill:hover { border-color: var(--orange); color: var(--orange); }
        
        .filter-pill.active {
            background: var(--navy);
            color: white;
            border-color: var(--navy);
        }
        
        [data-theme="dark"] .filter-pill.active { background: var(--orange); border-color: var(--orange); }

        .filter-select {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        .filter-select:focus {
            outline: none;
            border-color: var(--navy);
            box-shadow: 0 0 0 2px rgba(30, 58, 95, 0.15);
        }
        
        [data-theme="dark"] .filter-select:focus {
            border-color: var(--orange);
            box-shadow: 0 0 0 2px rgba(255, 140, 66, 0.15);
        }

        /* ========== CARDS ========== */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 0.875rem;
            box-shadow: var(--shadow-card);
            transition: all 0.2s;
        }
        
        .card:hover { box-shadow: var(--shadow-hover); }

        /* ========== GAME CARDS ========== */
        .games-grid { display: flex; flex-direction: column; gap: 0.5rem; }

        .game-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow-card);
            transition: all 0.2s;
        }

        .game-card:hover { box-shadow: var(--shadow-hover); }
        .game-card.bestbet { border-top: 4px solid var(--conf-bestbet); border-left: none; background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-bestbet-dim) 100%); }
        .game-card.elite { border-top: 3px solid var(--conf-elite); border-left: none; }
        .game-card.high { border-top: 3px solid var(--conf-high); border-left: none; }
        
        [data-theme="dark"] .game-card {
            box-shadow: var(--shadow-card), inset 0 1px 0 rgba(255,255,255,0.03);
        }
        
        [data-theme="dark"] .game-card:hover {
            box-shadow: var(--shadow-hover), inset 0 1px 0 rgba(255,255,255,0.05);
        }

        /* Game Header */
        .game-header-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 0.75rem;
            padding: 0.65rem 0.875rem;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .team-col {}
        .team-col.home { text-align: right; }
        .team-col .team-name { 
            font-size: 1.05rem; 
            font-weight: 800; 
            color: var(--text-primary); 
            margin-bottom: 0.15rem; 
            line-height: 1.2;
            letter-spacing: -0.01em;
        }
        .team-col .team-meta { font-size: 0.65rem; color: var(--text-secondary); font-weight: 500; }
        .team-col .team-rating { font-size: 0.75rem; margin-top: 0.15rem; font-weight: 700; }
        .team-rating .positive { color: var(--accent-green); }
        .team-rating .negative { color: var(--accent-red); }

        .game-info-col { text-align: center; min-width: 85px; }
        .game-datetime { font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.2rem; font-weight: 500; }
        .game-line {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-primary);
            padding: 0.3rem 0.5rem;
            background: var(--bg-input);
            border-radius: 6px;
            display: inline-block;
            border: 1px solid var(--border-light);
        }

        /* Picks Row */
        .picks-row { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; padding: 0.75rem 1rem; }
        @media (max-width: 600px) { .picks-row { grid-template-columns: 1fr; } }

        .pick-col {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            min-height: 120px;
        }

        .pick-col.has-pick { 
            border-color: var(--conf-medium-border); 
            background: var(--conf-medium-dim);
            border-width: 2px;
        }
        .pick-col.has-pick.high { 
            border-color: var(--conf-high-border); 
            background: var(--conf-high-dim);
        }
        .pick-col.no-pick { opacity: 0.5; }

        .pick-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem; }
        .pick-type-label { 
            font-size: 0.6rem; 
            font-weight: 800; 
            color: var(--text-secondary); 
            text-transform: uppercase; 
            letter-spacing: 0.1em;
            padding: 0.15rem 0.4rem;
            background: var(--bg-input);
            border-radius: 4px;
        }

        /* NEW SCORE BADGE - 0-100 */
        .score-badge {
            min-width: 32px;
            height: 24px;
            padding: 0 0.4rem;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 800;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        
        [data-theme="dark"] .score-badge {
            box-shadow: 0 2px 6px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.05);
        }
        
        .score-badge.bestbet { background: linear-gradient(135deg, var(--conf-bestbet), #d97706); box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3); }
        .score-badge.elite { background: linear-gradient(135deg, var(--conf-elite), #e67a35); }
        .score-badge.high { background: linear-gradient(135deg, var(--conf-high), #162d4a); }
        .score-badge.medium { background: linear-gradient(135deg, var(--conf-medium), #3670ab); }
        .score-badge.low { background: var(--text-muted); }
        
        /* Legacy circle badge for compatibility */
        .pick-confidence {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 700;
            color: white;
        }

        .pick-confidence.bestbet { background: var(--conf-bestbet); }
        .pick-confidence.elite { background: var(--conf-elite); }
        .pick-confidence.high { background: var(--conf-high); }
        .pick-confidence.medium { background: var(--conf-medium); }
        .pick-confidence.low { background: var(--text-muted); }

        /* SCORE GAUGE VISUALIZATION */
        .score-gauge {
            position: relative;
            width: 38px;
            height: 38px;
        }
        
        .score-gauge-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                var(--gauge-color, var(--accent-green)) calc(var(--score, 0) * 3.6deg),
                var(--bg-input) 0deg
            );
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .score-gauge-inner {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        /* COMPONENT BARS */
        .component-bars {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            margin-top: 0.35rem;
        }
        
        .component-bar {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }
        
        .component-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            width: 45px;
            text-transform: uppercase;
        }
        
        .component-track {
            flex: 1;
            height: 5px;
            background: var(--bg-input);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .component-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .component-fill.edge { background: var(--accent-green); }
        .component-fill.power { background: var(--accent-blue); }
        .component-fill.matchup { background: var(--accent-yellow); }
        .component-fill.situational { background: #8b5cf6; }
        
        .component-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            color: var(--text-secondary);
            width: 20px;
            text-align: right;
        }
        
        /* WIN PROBABILITY METER */
        .win-prob-meter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.5rem;
            background: var(--bg-input);
            border-radius: 6px;
            margin-top: 0.4rem;
            margin-bottom: 0.2rem;
        }
        
        .win-prob-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 700;
        }
        
        .win-prob-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .win-prob-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green));
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .win-prob-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 800;
            color: var(--text-primary);
            min-width: 36px;
            text-align: right;
        }
        
        .win-prob-value.positive {
            color: var(--accent-green);
        }
        
        /* SCORE BREAKDOWN VISUAL */
        .score-breakdown-visual {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
            padding: 0.5rem 0;
        }
        
        .score-ring-container {
            flex-shrink: 0;
        }
        
        .score-ring {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: conic-gradient(
                var(--gauge-color, var(--accent-green)) calc(var(--score, 0) * 3.6deg),
                var(--bg-input) 0deg
            );
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .score-ring-inner {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .score-ring-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            font-weight: 800;
            color: var(--text-primary);
            line-height: 1;
        }
        
        .score-ring-label {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 2px;
            font-weight: 600;
        }
        
        /* EDGE BAR CHART VISUALIZATION */
        .edge-bar-chart {
            background: var(--bg-input);
            border-radius: 6px;
            padding: 0.75rem;
            margin: 0.5rem 0;
        }
        
        .edge-bar-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.35rem;
        }
        
        .edge-bar-row:last-child {
            margin-bottom: 0;
        }
        
        .edge-bar-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            width: 70px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .edge-bar-track {
            flex: 1;
            height: 20px;
            background: var(--bg-secondary);
            border-radius: 3px;
            position: relative;
            overflow: visible;
        }
        
        .edge-bar-fill {
            height: 100%;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 0.4rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            transition: width 0.3s ease;
        }
        
        .edge-bar-fill.vegas {
            background: var(--text-muted);
        }
        
        .edge-bar-fill.projection {
            background: var(--accent-blue);
        }
        
        .edge-bar-fill.edge {
            background: var(--accent-green);
        }
        
        .edge-comparison {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: var(--bg-card);
            border-radius: 6px;
            margin-top: 0.35rem;
        }
        
        .edge-comparison-item {
            text-align: center;
        }
        
        .edge-comparison-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.05rem;
            font-weight: 800;
            color: var(--text-primary);
        }
        
        .edge-comparison-value.positive {
            color: var(--accent-green);
        }
        
        .edge-comparison-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 0.2rem;
            font-weight: 600;
        }
        
        .edge-arrow {
            font-size: 1.25rem;
            color: var(--accent-green);
        }
        
        /* WIN PROBABILITY CONTEXT */
        .win-prob-context {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 0.2rem;
        }
        
        .win-prob-context .breakeven {
            color: var(--accent-yellow);
        }

        .pick-main { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.4rem; }
        .pick-icon { font-size: 1rem; }
        .pick-team-name { 
            font-size: 0.95rem; 
            font-weight: 800; 
            color: var(--text-primary);
            letter-spacing: -0.01em;
        }
        .pick-line-value { 
            font-family: 'JetBrains Mono', monospace; 
            font-size: 0.95rem; 
            font-weight: 800; 
            color: var(--accent-theme);
            background: var(--bg-input);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }
        
        /* Win% badge in pick header */
        .pick-winprob {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 800;
            padding: 0.2rem 0.5rem;
            border-radius: 5px;
            background: var(--bg-input);
        }
        .pick-winprob.bestbet { color: var(--conf-bestbet); background: var(--conf-bestbet-dim); font-weight: 800; }
        .pick-winprob.elite { color: var(--conf-elite); background: var(--conf-elite-dim); }
        .pick-winprob.high { color: var(--conf-high); background: var(--conf-high-dim); }
        .pick-winprob.medium { color: var(--conf-medium); background: var(--conf-medium-dim); }
        .pick-winprob.low { color: var(--text-muted); }

        /* Pick Bullet Points - Why This Bet Wins */
        .pick-bullets {
            list-style: none;
            padding: 0;
            margin: 0.5rem 0;
            font-size: 0.75rem;
            line-height: 1.4;
        }
        .pick-bullets li {
            position: relative;
            padding-left: 1rem;
            margin-bottom: 0.25rem;
            color: var(--text-secondary);
        }
        .pick-bullets li::before {
            content: '';
            position: absolute;
            left: 0;
            color: var(--accent-green);
            font-weight: 700;
        }
        .pick-col.high .pick-bullets li::before {
            color: var(--conf-elite);
        }
        
        /* Best Bets bullet styling */
        .bestbet-bullets {
            margin: 0.75rem 0;
            padding: 0.5rem 0.75rem;
            background: var(--bg-input);
            border-radius: 6px;
            border-left: 3px solid var(--conf-medium);
        }
        .best-bet-card.elite .bestbet-bullets { border-left-color: var(--conf-elite); }
        .best-bet-card.high .bestbet-bullets { border-left-color: var(--conf-high); }
        
        /* Top 5 bullet styling */
        .top5-bullets {
            margin: 0.4rem 0 0;
            font-size: 0.7rem;
        }
        .top5-bullets li {
            margin-bottom: 0.15rem;
        }

        .pick-metrics { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.3rem; margin-bottom: 0.4rem; }
        .pick-metric { text-align: center; padding: 0.3rem 0.2rem; background: var(--bg-card); border-radius: 6px; border: 1px solid var(--border-light); }
        .pm-value { display: block; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; font-weight: 700; color: var(--text-primary); }
        .pm-value.positive { color: var(--accent-green); font-weight: 800; }
        .pm-label { font-size: 0.55rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600; letter-spacing: 0.03em; }

        .no-pick-msg {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1.25rem 0.5rem;
            color: var(--text-muted);
            font-size: 0.8rem;
            gap: 0.25rem;
            min-height: 80px;
        }

        .no-pick-msg span:first-child { font-size: 1.25rem; opacity: 0.6; }
        .no-data-msg { text-align: center; padding: 0.75rem; color: var(--text-muted); font-size: 0.75rem; }

        /* Analytics Toggle & Drill Down */
        .analytics-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.3rem;
            padding: 0.35rem;
            margin: 0 0.75rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .analytics-toggle:hover { background: var(--bg-card-hover); color: var(--text-primary); border-color: var(--accent-theme); }
        .analytics-toggle:focus { outline: none; }
        .analytics-toggle:focus-visible { 
            outline: 2px solid var(--accent-theme); 
            outline-offset: 2px;
        }
        [data-theme="dark"] .analytics-toggle:hover { border-color: var(--orange); }
        [data-theme="dark"] .analytics-toggle:focus-visible { outline-color: var(--orange); }

        /* Drill Down Content */
        .drill-down-content { display: none; margin: 0 0.5rem 0.4rem; padding: 0.4rem; background: var(--bg-secondary); border-radius: 5px; border: 1px solid var(--border-color); }
        .drill-down-content.visible { display: block; }

        /* Analysis Sections */
        .analysis-section { margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
        .analysis-section:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }

        .section-header-large { display: flex; align-items: center; gap: 0.35rem; margin-bottom: 0.25rem; }
        .section-icon { font-size: 0.85rem; }
        .section-header-large > span:nth-child(2) { font-size: 0.85rem; font-weight: 700; color: var(--text-primary); }
        .section-badge { font-size: 0.55rem; font-weight: 700; padding: 0.12rem 0.35rem; border-radius: 6px; background: var(--bg-input); color: var(--text-secondary); margin-left: auto; }
        .section-badge.high { background: var(--accent-blue-dim); color: var(--accent-blue); }

        .section-explainer { font-size: 0.68rem; color: var(--text-muted); margin-bottom: 0.4rem; font-style: italic; }

        /* Highlighted Reasoning Box */
        .highlight-section { background: var(--orange-dim); border-radius: 8px; padding: 0.5rem; margin-bottom: 0.625rem; border: 1px solid rgba(255, 140, 66, 0.2); }
        .reasoning-item { font-size: 0.8rem; color: var(--text-primary); line-height: 1.4; margin-bottom: 0.3rem; padding: 0.35rem 0.5rem; background: var(--bg-card); border-radius: 5px; border-left: 2px solid var(--orange); }
        .reasoning-item:last-child { margin-bottom: 0; }
        .reasoning-item strong { color: var(--orange); }

        /* Compact Grid */
        .compact-grid { margin-bottom: 0.4rem; }
        .compact-row { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.35rem; margin-bottom: 0.3rem; align-items: center; }
        @media (max-width: 600px) { .compact-row { grid-template-columns: 1fr 1fr; } }
        .cg-label { font-size: 0.7rem; color: var(--text-secondary); font-weight: 500; }
        .cg-value { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; font-weight: 700; color: var(--text-primary); }
        .cg-value.elite { color: var(--accent-green); font-weight: 800; }
        .cg-value.good { color: var(--accent-blue); font-weight: 800; }
        .cg-value.ok { color: var(--accent-yellow); }
        .cg-value.bad { color: var(--accent-red); }

        /* Threshold Bar */
        .threshold-bar { position: relative; height: 4px; background: var(--bg-input); border-radius: 2px; margin: 0.35rem 0 0.2rem; }
        .threshold-fill { height: 100%; background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green)); border-radius: 2px; transition: width 0.3s; }
        .threshold-markers { position: absolute; top: 0; left: 0; right: 0; height: 100%; }
        .threshold-markers .marker { position: absolute; top: -10px; font-size: 0.45rem; color: var(--text-muted); transform: translateX(-50%); }
        .threshold-label { font-size: 0.65rem; color: var(--text-muted); }
        .threshold-label span.elite { color: var(--accent-green); font-weight: 600; }
        .threshold-label span.good { color: var(--accent-blue); font-weight: 600; }

        /* Units Display */
        .units-display { display: flex; align-items: center; gap: 0.3rem; margin: 0.35rem 0; }
        .units-label { font-size: 0.7rem; color: var(--text-secondary); }
        .unit-chip { font-family: 'JetBrains Mono', monospace; font-size: 0.7rem; font-weight: 600; padding: 0.2rem 0.4rem; background: var(--bg-input); border-radius: 5px; color: var(--text-secondary); }
        .unit-chip.selected { background: var(--accent-green-dim); color: var(--accent-green); border: 1px solid rgba(34, 197, 94, 0.3); }

        /* Signal Display */
        .signal-display { display: flex; align-items: center; gap: 0.4rem; padding: 0.4rem; border-radius: 6px; margin-bottom: 0.3rem; }
        .signal-display.good { background: var(--accent-green-dim); border: 1px solid rgba(34, 197, 94, 0.2); }
        .signal-display.bad { background: var(--accent-red-dim); border: 1px solid rgba(239, 68, 68, 0.2); }
        .signal-display.neutral { background: var(--bg-input); border: 1px solid var(--border-color); }
        .signal-icon-lg { font-size: 1rem; }
        .signal-content { display: flex; flex-direction: column; gap: 0.05rem; }
        .signal-content strong { font-size: 0.75rem; color: var(--text-primary); }
        .signal-content span { font-size: 0.65rem; color: var(--text-secondary); }

        /* Pace Display */
        .pace-display { display: flex; align-items: center; gap: 0.3rem; padding: 0.3rem; background: var(--bg-input); border-radius: 5px; font-size: 0.7rem; color: var(--text-secondary); }
        .pace-display.extreme { background: var(--accent-yellow-dim); color: var(--accent-yellow); border: 1px solid rgba(234, 179, 8, 0.2); }
        .pace-icon { font-size: 0.8rem; }

        /* Script Compact */
        .script-compact { display: flex; flex-direction: column; gap: 0.2rem; }
        .script-item { display: flex; align-items: center; gap: 0.3rem; }
        .script-name { font-size: 0.65rem; color: var(--text-muted); min-width: 70px; }
        .script-bar-sm { flex: 1; height: 3px; background: var(--bg-input); border-radius: 2px; overflow: hidden; }
        .script-fill { height: 100%; border-radius: 2px; }
        .script-pct { font-family: 'JetBrains Mono', monospace; font-size: 0.65rem; color: var(--text-secondary); min-width: 24px; text-align: right; }

        /* Factors Compact */
        .factors-compact { display: flex; flex-wrap: wrap; gap: 0.25rem; }
        .factor-chip { font-size: 0.68rem; padding: 0.2rem 0.4rem; border-radius: 10px; background: var(--bg-input); color: var(--text-secondary); }
        .factor-chip.positive { background: var(--accent-green-dim); color: var(--accent-green); }
        .factor-chip.negative { background: var(--accent-red-dim); color: var(--accent-red); }

        /* ========== STATUS & BUTTONS ========== */
        .status-badge { display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.25rem 0.5rem; background: var(--bg-input); border-radius: 15px; font-size: 0.7rem; font-weight: 500; color: var(--text-secondary); }
        .status-badge.success { background: var(--accent-green-dim); color: var(--accent-green); }
        .status-badge.error { background: var(--accent-red-dim); color: var(--accent-red); }

        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.4rem; padding: 0.5rem 1rem; border-radius: 6px; font-weight: 600; font-size: 0.8rem; cursor: pointer; border: none; transition: all 0.2s; }
        .btn-primary { background: var(--orange); color: white; }
        .btn-primary:hover { background: var(--orange-hover); }
        .btn-secondary { background: var(--bg-input); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-success { background: var(--conf-high); color: white; }
        .btn-small { padding: 0.35rem 0.7rem; font-size: 0.75rem; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }

        /* Spinner */
        .spinner { width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 0.8s linear infinite; display: inline-block; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Filter Pills - Compact variant (Best Bets tab uses rounded pills) */
        .filter-pills.compact { gap: 0.25rem; }
        .filter-pill.rounded { border-radius: 15px; padding: 0.3rem 0.65rem; }
        
        .styled-select { padding: 0.35rem 1.75rem 0.35rem 0.75rem; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 0.8rem; font-weight: 600; cursor: pointer; appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.5rem center; }
        .styled-select:hover { border-color: var(--accent-theme); }
        .styled-select:focus { outline: none; border-color: var(--accent-theme); box-shadow: 0 0 0 2px rgba(30, 58, 95, 0.1); }
        [data-theme="dark"] .styled-select { background-color: var(--bg-card); }
        [data-theme="dark"] .styled-select:hover, [data-theme="dark"] .styled-select:focus { border-color: var(--orange); box-shadow: 0 0 0 2px rgba(255, 140, 66, 0.15); }
        [data-theme="dark"] .styled-select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23a8b8c8' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
        }

        /* Picks Summary Widget */
        .picks-summary-widget {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.4rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-card);
        }
        
        @media (max-width: 600px) {
            .picks-summary-widget { grid-template-columns: repeat(2, 1fr); }
        }
        
        .picks-summary-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.35rem;
            border-radius: 6px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }
        
        .picks-summary-card.elite { border-left: 3px solid var(--conf-elite); }
        .picks-summary-card.high { border-left: 3px solid var(--conf-high); }
        .picks-summary-card.medium { border-left: 3px solid var(--conf-medium); }
        .picks-summary-card.low { border-left: 3px solid var(--text-muted); }
        
        .picks-summary-label {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            margin-bottom: 0.1rem;
        }
        
        .picks-summary-range {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-muted);
            opacity: 0.7;
            margin-bottom: 0.25rem;
        }
        
        .picks-summary-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
        }
        
        .picks-summary-card.elite .picks-summary-count { color: var(--conf-elite); }
        .picks-summary-card.high .picks-summary-count { color: var(--conf-high); }
        .picks-summary-card.medium .picks-summary-count { color: var(--conf-medium); }
        
        .picks-summary-winrate {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-top: 0.25rem;
            padding: 0.15rem 0.4rem;
            background: var(--bg-input);
            border-radius: 8px;
        }
        
        .picks-summary-winrate.positive { color: var(--accent-green); background: var(--accent-green-dim); }
        .picks-summary-winrate.negative { color: var(--accent-red); background: var(--accent-red-dim); }

        /* Conference Dropdown */
        .filter-select { padding: 0.4rem 0.75rem; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 20px; color: var(--text-primary); font-size: 0.8rem; font-weight: 500; cursor: pointer; outline: none; min-width: 120px; }
        .filter-select:hover { border-color: var(--accent-theme); }
        .filter-select:focus { border-color: var(--accent-theme); box-shadow: 0 0 0 2px rgba(30, 58, 95, 0.15); }
        [data-theme="dark"] .filter-select:hover { border-color: var(--orange); }
        [data-theme="dark"] .filter-select:focus { border-color: var(--orange); box-shadow: 0 0 0 2px rgba(255, 140, 66, 0.15); }

        /* Team Search Autocomplete */
        .team-search-container {
            position: relative;
            flex: 1;
            min-width: 150px;
            max-width: 200px;
        }
        
        .team-search-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 0.85rem;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .team-search-input:focus {
            border-color: var(--accent-theme);
            box-shadow: 0 0 0 2px rgba(30, 58, 95, 0.15);
        }
        
        [data-theme="dark"] .team-search-input:focus {
            border-color: var(--orange);
            box-shadow: 0 0 0 2px rgba(255, 140, 66, 0.15);
        }
        
        .team-search-input::placeholder {
            color: var(--text-muted);
        }
        
        .team-search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-hover);
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            margin-top: 4px;
        }
        
        .team-search-dropdown.active {
            display: block;
        }
        
        .team-search-item {
            padding: 0.6rem 0.75rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.15s;
        }
        
        .team-search-item:last-child {
            border-bottom: none;
        }
        
        .team-search-item:hover {
            background: var(--bg-input);
        }
        
        .team-search-item.selected {
            background: var(--accent-blue-dim);
        }
        
        .team-search-name {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .team-search-conf {
            font-size: 0.7rem;
            color: var(--text-muted);
            padding: 0.15rem 0.4rem;
            background: var(--bg-input);
            border-radius: 4px;
        }
        
        .team-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            display: none;
            border-radius: 4px;
            transition: all 0.15s;
        }
        
        .team-search-clear:hover {
            color: var(--text-primary);
            background: var(--bg-input);
        }
        
        .team-search-clear:focus {
            outline: none;
        }
        
        .team-search-clear:focus-visible {
            outline: 2px solid var(--orange);
            outline-offset: 1px;
        }
        
        .team-search-container.has-value .team-search-clear {
            display: block;
        }

        /* Game Cards - Condensed */
        .games-grid { display: flex; flex-direction: column; gap: 0.5rem; }
        .game-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; transition: all 0.2s; box-shadow: var(--shadow-card); }
        .game-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-hover); }
        .game-card.elite { border-top: 3px solid var(--conf-elite); border-color: var(--conf-elite-border); }
        .game-card.high { border-top: 3px solid var(--conf-high); border-color: var(--conf-high-border); }

        .game-main { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; padding: 0.75rem 1rem; gap: 0.75rem; }
        @media (max-width: 700px) { .game-main { grid-template-columns: 1fr; text-align: center; gap: 0.75rem; } }

        .team { display: flex; flex-direction: column; gap: 0.2rem; }
        .team.away { text-align: left; align-items: flex-start; }
        .team.home { text-align: right; align-items: flex-end; }
        @media (max-width: 700px) { .team.away, .team.home { text-align: center; align-items: center; } }

        .team-header { display: flex; align-items: center; gap: 0.4rem; }
        .team.home .team-header { flex-direction: row-reverse; }
        @media (max-width: 700px) { .team.home .team-header { flex-direction: row; } }

        .team-logo { width: 32px; height: 32px; object-fit: contain; border-radius: 4px; flex-shrink: 0; }
        .team-logo.placeholder { background: var(--bg-input); display: flex; align-items: center; justify-content: center; font-size: 0.75rem; color: var(--text-muted); }

        .team-name { font-size: 1.05rem; font-weight: 700; line-height: 1.2; }
        .team-meta { font-size: 0.7rem; color: var(--text-muted); font-weight: 500; }
        .team-rating { font-size: 0.8rem; font-weight: 600; }
        .team-rating .positive { color: var(--accent-green); }
        .team-rating .negative { color: var(--accent-red); }

        .game-center { text-align: center; padding: 0 0.75rem; }
        .game-time { font-size: 0.9rem; font-weight: 600; }
        .game-date { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.35rem; }

        /* Confidence Ring - Condensed */
        .confidence-ring { width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0.35rem auto; position: relative; background: var(--bg-input); }
        .confidence-ring::before { content: ''; position: absolute; inset: 3px; border-radius: 50%; background: var(--bg-card); }
        .confidence-value { position: relative; z-index: 1; font-size: 1.1rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; }
        .confidence-ring.bestbet .confidence-value { color: var(--conf-bestbet); }
        .confidence-ring.elite .confidence-value { color: var(--conf-elite); }
        .confidence-ring.high .confidence-value { color: var(--conf-high); }
        .confidence-ring.medium .confidence-value { color: var(--conf-medium); }
        .confidence-ring.low .confidence-value { color: var(--text-muted); }

        /* ========== CONFIDENCE LEGEND ========== */
        .confidence-legend {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.7rem;
            flex-wrap: wrap;
        }

        /* Global legend positioned below tabs */
        .confidence-legend--global {
            margin-bottom: 0.75rem;
            display: none; /* Hidden by default  toggled via (?) icon in tab bar */
        }

        .confidence-legend--global.visible {
            display: flex;
        }
        
        .confidence-legend-title {
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.6rem;
        }
        
        .confidence-legend-items {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            flex-wrap: wrap;
        }
        
        .confidence-legend-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .confidence-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .confidence-legend-dot.bestbet { background: var(--conf-bestbet); }
        .confidence-legend-dot.elite { background: var(--conf-elite); }
        .confidence-legend-dot.high { background: var(--conf-high); }
        .confidence-legend-dot.medium { background: var(--conf-medium); }
        .confidence-legend-dot.low { background: var(--conf-low); }
        
        .confidence-legend-label {
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .confidence-legend-range {
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
        }
        
        /* Confidence Ring used in both Games and Best Bets */
        .confidence-ring-mini {
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }
        
        .confidence-ring-mini::before {
            content: '';
            position: absolute;
            inset: 3px;
            border-radius: 50%;
            background: var(--bg-card);
        }
        
        .confidence-ring-mini .conf-value {
            position: relative;
            z-index: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 800;
        }
        
        /* Scale font size based on ring size */
        .confidence-ring-mini[style*="width:44px"] .conf-value,
        .confidence-ring-mini[style*="width: 44px"] .conf-value {
            font-size: 0.9rem;
        }
        
        .confidence-ring-mini.elite .conf-value { color: var(--conf-elite); }
        .confidence-ring-mini.high .conf-value { color: var(--conf-high); }
        .confidence-ring-mini.medium .conf-value { color: var(--conf-medium); }
        .confidence-ring-mini.low .conf-value { color: var(--text-muted); }
        
        /* Win% Badge - Clean display of win probability */
        .win-prob-badge {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.4rem 0.6rem;
            border-radius: 8px;
            background: var(--bg-input);
            border: 2px solid var(--border-color);
            min-width: 52px;
        }
        .win-prob-badge .win-prob-pct {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            line-height: 1.1;
        }
        .win-prob-badge .win-prob-label-sm {
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }
        .win-prob-badge.bestbet { border-color: var(--conf-bestbet); background: var(--conf-bestbet-dim); }
        .win-prob-badge.bestbet .win-prob-pct { color: var(--conf-bestbet); font-weight: 800; }
        .win-prob-badge.elite { border-color: var(--conf-elite); background: var(--conf-elite-dim); }
        .win-prob-badge.elite .win-prob-pct { color: var(--conf-elite); }
        
        /* Best Bet Basketball Rating (1-5 basketballs with half support) - 62%+ calibrated threshold */
        .elite-rating { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            margin-top: 8px; 
            justify-content: center;
            padding: 8px 12px;
            background: linear-gradient(135deg, var(--conf-bestbet-dim), rgba(245, 158, 11, 0.05));
            border-radius: 10px;
            border: 1px solid var(--conf-bestbet-border);
        }
        .elite-rating-balls { 
            display: flex; 
            align-items: center; 
            gap: 3px;
            line-height: 1;
        }
        .elite-rating-balls svg {
            display: inline-block;
            flex-shrink: 0;
        }
        /* Compact version for grid view */
        .elite-rating-mini { 
            display: inline-flex;
            align-items: center;
            gap: 0;
            justify-content: center;
            line-height: 1;
            flex-shrink: 0;
        }
        .elite-rating-mini svg {
            display: inline-block;
            flex-shrink: 0;
        }
        .win-prob-badge.high { border-color: var(--conf-high); background: var(--conf-high-dim); }
        .win-prob-badge.high .win-prob-pct { color: var(--conf-high); }
        .win-prob-badge.medium { border-color: var(--conf-medium); background: var(--conf-medium-dim); }
        .win-prob-badge.medium .win-prob-pct { color: var(--conf-medium); }
        .win-prob-badge.low .win-prob-pct { color: var(--text-muted); }
        .win-prob-badge-lg { padding: 0.5rem 0.75rem; min-width: 60px; }
        .win-prob-badge-lg .win-prob-pct { font-size: 1.2rem; }
        
        /* Reasoning text style */
        .pick-reasoning-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-input);
            border-radius: 6px;
            border-left: 3px solid var(--conf-medium);
        }
        .pick-reasoning-text.elite { border-left-color: var(--conf-elite); }
        .pick-reasoning-text.high { border-left-color: var(--conf-high); }

        /* Analysis - Condensed */
        .game-analysis { background: var(--bg-input); padding: 0.75rem 1rem; border-top: 1px solid var(--border-color); }
        .analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; }
        .analysis-block h4 { font-size: 0.65rem; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.06em; margin-bottom: 0.5rem; }
        .analysis-row { display: flex; justify-content: space-between; padding: 0.25rem 0; }
        .analysis-label { font-size: 0.75rem; color: var(--text-secondary); }
        .analysis-value { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; font-weight: 600; }
        .analysis-value.positive { color: var(--accent-green); }

        /* Recommendation - Condensed */
        .recommendation { background: var(--bg-card); border-radius: 10px; padding: 0.75rem 1rem; margin-top: 0.75rem; }
        .pick-header { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.5rem; }
        .pick-icon { font-size: 1.1rem; }
        .pick-team { font-size: 0.95rem; font-weight: 700; }
        .pick-line { font-family: 'JetBrains Mono', monospace; color: var(--accent-theme); font-weight: 700; }
        .pick-reasoning { font-size: 0.8rem; color: var(--text-secondary); line-height: 1.5; margin-bottom: 0.5rem; }
        .factor-tags { display: flex; flex-wrap: wrap; gap: 0.3rem; margin-bottom: 0.5rem; }
        .factor-tag { display: inline-flex; padding: 0.2rem 0.45rem; border-radius: 5px; font-size: 0.65rem; font-weight: 600; }
        .factor-tag.positive { background: var(--accent-green-dim); color: var(--accent-green); }
        .factor-tag.negative { background: var(--accent-red-dim); color: var(--accent-red); }
        .factor-tag.neutral { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .factor-tag.info { background: var(--accent-blue-dim); color: var(--accent-blue); }

        /* Best Bets - Condensed */
        .best-bet-card { background: var(--bg-card); border: 2px solid var(--conf-high-border); border-radius: 12px; padding: 0.75rem; margin-bottom: 0.6rem; box-shadow: 0 4px 20px rgba(30, 58, 95, 0.12); }
        .best-bet-card.bestbet { border-color: var(--conf-bestbet); box-shadow: 0 4px 24px rgba(245, 158, 11, 0.25); background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-bestbet-dim) 100%); }
        .best-bet-card.elite { border-color: var(--conf-elite); box-shadow: 0 4px 20px rgba(255, 140, 66, 0.15); }
        .best-bet-card.high { border-color: var(--conf-high); box-shadow: 0 4px 20px rgba(30, 58, 95, 0.15); }
        .best-bet-card.medium { border-color: var(--conf-medium); box-shadow: 0 4px 20px rgba(74, 143, 212, 0.15); }
        
        [data-theme="dark"] .best-bet-card {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255,255,255,0.03);
        }
        [data-theme="dark"] .best-bet-card.elite {
            box-shadow: 0 4px 20px rgba(255, 140, 66, 0.2), inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .best-bet-header { display: flex; align-items: center; gap: 0.6rem; margin-bottom: 0.5rem; }
        .rank-badge { width: 34px; height: 34px; background: var(--conf-elite); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white; font-size: 0.9rem; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
        .best-bet-info { flex: 1; }
        .best-bet-pick { font-size: 1rem; font-weight: 800; letter-spacing: -0.01em; }
        .best-bet-matchup { font-size: 0.75rem; color: var(--text-secondary); font-weight: 500; }

        /* Best Bets Grid View - Professional Sportsbook Style */
        .best-bets-grid { 
            background: var(--bg-card); 
            border-radius: 10px; 
            overflow: hidden; 
            border: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }
        
        /* Header Row */
        .best-bets-grid-header { 
            display: grid; 
            grid-template-columns: 36px 1fr 72px 1.2fr 70px 130px; 
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        .best-bets-grid-header > div { 
            padding: 0.7rem 0.75rem;
            font-size: 0.65rem; 
            font-weight: 600; 
            text-transform: uppercase; 
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }
        .best-bets-grid-header .col-rank { text-align: center; }
        .best-bets-grid-header .col-matchup { text-align: left; }
        .best-bets-grid-header .col-time { text-align: center; }
        .best-bets-grid-header .col-pick { text-align: left; }
        .best-bets-grid-header .col-edge { text-align: right; }
        .best-bets-grid-header .col-winprob { text-align: center; }
        
        /* Data Rows */
        .best-bets-grid-row { 
            display: grid; 
            grid-template-columns: 36px 1fr 72px 1.2fr 70px 130px;
            transition: background 0.15s ease;
            position: relative;
        }
        .best-bets-grid-row:nth-child(odd):not(.drill-down-content) { background: var(--bg-secondary); }
        .best-bets-grid-row:hover { background: var(--bg-card-hover); }
        .best-bets-grid-row.expanded { background: var(--bg-card-hover) !important; }
        .best-bets-grid-row > div { 
            padding: 0.75rem;
            display: flex; 
            align-items: center;
        }
        
        /* Rank Column */
        .best-bets-grid-row .col-rank { 
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-muted);
        }
        
        /* Matchup Column - Primary hierarchy */
        .best-bets-grid-row .col-matchup { 
            flex-direction: column;
            align-items: flex-start;
            gap: 0.15rem;
            line-height: 1.3;
        }
        .best-bets-grid-row .matchup-away { 
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .best-bets-grid-row .matchup-home { 
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .best-bets-grid-row .matchup-at { 
            font-size: 0.65rem;
            color: var(--text-muted);
            font-weight: 400;
        }
        
        /* Time Column - Secondary */
        .best-bets-grid-row .col-time { 
            flex-direction: column;
            justify-content: center;
            text-align: center;
            gap: 0.1rem;
        }
        .best-bets-grid-row .time-date {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        .best-bets-grid-row .time-hour {
            font-size: 0.65rem;
            color: var(--text-muted);
        }
        
        /* Pick Column - Badge/Pill Style */
        .best-bets-grid-row .col-pick { 
            justify-content: flex-start;
        }
        .pick-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.55rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        .pick-badge .pick-dir {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            background: var(--text-muted);
            color: white;
        }
        .pick-badge .pick-dir.over { background: var(--accent-green); }
        .pick-badge .pick-dir.under { background: var(--accent-blue); }
        .pick-badge .pick-dir.spread { background: var(--navy); }
        .pick-badge .pick-line {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }
        
        /* Edge Column - Green accent */
        .best-bets-grid-row .col-edge { 
            justify-content: flex-end;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-green);
        }
        
        /* Win% Column - Soft intensity scale */
        .best-bets-grid-row .col-winprob { 
            justify-content: center;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding-right: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
        }
        .best-bets-grid-row .col-winprob .winprob-value {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            white-space: nowrap;
        }
        .best-bets-grid-row .col-winprob .winprob-value.tier-bestbet { 
            background: var(--conf-bestbet-dim);
            color: var(--conf-bestbet);
            font-weight: 800;
        }
        .best-bets-grid-row .col-winprob .winprob-value.tier-elite { 
            background: rgba(255, 140, 66, 0.12);
            color: var(--conf-elite);
        }
        .best-bets-grid-row .col-winprob .winprob-value.tier-high { 
            background: rgba(30, 58, 95, 0.1);
            color: var(--conf-high);
        }
        .best-bets-grid-row .col-winprob .winprob-value.tier-medium { 
            background: rgba(74, 143, 212, 0.1);
            color: var(--conf-medium);
        }
        .best-bets-grid-row .col-winprob .winprob-value.tier-low { 
            color: var(--text-muted);
        }
        
        /* Dark mode adjustments */
        [data-theme="dark"] .pick-badge { 
            background: var(--bg-primary); 
            border-color: var(--border-light);
        }
        [data-theme="dark"] .best-bets-grid-row .col-winprob .winprob-value.tier-high {
            background: rgba(74, 143, 212, 0.15);
            color: var(--conf-medium);
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            .best-bets-grid-header, .best-bets-grid-row { 
                grid-template-columns: 28px 1fr 54px 1fr 50px 90px; 
            }
            .best-bets-grid-header > div, .best-bets-grid-row > div { 
                padding: 0.5rem 0.35rem; 
            }
            .best-bets-grid-row .matchup-away,
            .best-bets-grid-row .matchup-home { font-size: 0.7rem; }
            .best-bets-grid-row .matchup-at { font-size: 0.6rem; }
            .pick-badge { padding: 0.2rem 0.35rem; font-size: 0.65rem; gap: 0.25rem; }
            .pick-badge .pick-dir { font-size: 0.5rem; padding: 0.1rem 0.2rem; }
            .pick-badge .pick-line { font-size: 0.65rem; }
            .best-bets-grid-row .col-edge { font-size: 0.7rem; }
            .best-bets-grid-row .col-winprob { font-size: 0.7rem; padding-right: 0.3rem; }
            .best-bets-grid-row .col-winprob .winprob-value { padding: 0.15rem 0.3rem; }
        }

        /* ========== REDESIGNED ANALYSIS - CLEAN & PROFESSIONAL ========== */
        
        .bb-analysis {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 0.5rem;
        }
        
        /* Summary Bar - Model/Vegas/Edge/Win in a row */
        .bb-summary-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border-radius: 6px;
            margin-bottom: 0.6rem;
            border: 1px solid var(--border-color);
        }
        
        .bb-summary-bar.under {
            border-color: var(--accent-blue);
            background: var(--accent-blue-dim);
        }
        
        /* Panel Title */
        .bb-panel-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            padding-bottom: 0.35rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        .bb-panel-title-text {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--accent-theme);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .bb-panel-title-badge {
            font-size: 0.55rem;
            font-weight: 600;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-input);
            color: var(--text-muted);
        }
        
        .bb-panel-title-badge.pass {
            background: var(--accent-yellow-dim);
            color: var(--accent-yellow);
        }
        
        .bb-summary-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-width: 45px;
        }
        
        .bb-summary-label {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .bb-summary-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .bb-summary-value.edge {
            color: var(--accent-green);
        }
        
        .bb-summary-value.under {
            color: var(--accent-blue);
        }
        
        /* Content Grid - Stats table + Facts side by side */
        .bb-content-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.75rem;
            align-items: start;
        }
        
        @media (max-width: 500px) {
            .bb-content-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Stats Table */
        .bb-stats-table {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            font-size: 0.7rem;
        }
        
        .bb-stats-row {
            display: grid;
            grid-template-columns: 65px repeat(4, 1fr);
            gap: 0.25rem;
            padding: 0.25rem 0.4rem;
            background: var(--bg-card);
            border-radius: 4px;
        }
        
        .bb-stats-row.header {
            background: var(--bg-input);
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            font-size: 0.55rem;
            letter-spacing: 0.03em;
        }
        
        .bb-stats-row.diff {
            background: var(--bg-input);
            font-weight: 600;
            border-top: 1px solid var(--border-color);
        }
        
        .bb-stats-row.proj {
            background: var(--bg-input);
            grid-template-columns: 1fr;
            font-size: 0.65rem;
            text-align: center;
        }
        
        .bb-stats-cell {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        
        .bb-stats-cell:first-child {
            text-align: left;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .bb-stats-cell.positive {
            color: var(--accent-green);
        }
        
        .bb-stats-cell.negative {
            color: var(--accent-red);
        }
        
        /* Facts Panel */
        .bb-facts {
            min-width: 120px;
            padding: 0.5rem;
            background: var(--bg-card);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .bb-facts-header {
            font-size: 0.6rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.35rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        .bb-facts-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        .bb-facts-list li {
            padding: 0.2rem 0;
            padding-left: 0.9rem;
            position: relative;
        }
        
        .bb-facts-list li::before {
            content: '';
            position: absolute;
            left: 0;
            color: var(--accent-green);
            font-size: 0.6rem;
            font-weight: 700;
        }
        
        .bb-facts-list.under li::before {
            color: var(--accent-blue);
        }
        
        /* Header Row with Title + Reason Chips */
        .bb-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.6rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .bb-title {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .bb-title-icon {
            font-size: 1rem;
        }
        
        /* Reason Chips */
        .bb-reason-chips {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }
        .bb-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        .bb-chip.highlight {
            background: var(--accent-green-dim);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }
        .bb-chip.highlight-blue {
            background: var(--accent-blue-dim);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }
        .bb-chip-emoji {
            font-size: 0.75rem;
        }
        
        /* Value Bar - Vegas vs Model | Edge | Win Prob */
        .bb-value-bar {
            display: flex;
            align-items: stretch;
            background: var(--bg-card);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.6rem;
            border: 1px solid var(--border-color);
        }
        .bb-value-item {
            flex: 1;
            padding: 0.5rem 0.4rem;
            text-align: center;
            border-right: 1px solid var(--border-color);
        }
        .bb-value-item:last-child {
            border-right: none;
        }
        .bb-value-item.comparison {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.6rem;
        }
        .bb-value-label {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.15rem;
        }
        .bb-value-num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .bb-value-num.edge {
            color: var(--accent-green);
        }
        .bb-value-num.edge.under {
            color: var(--accent-blue);
        }
        .bb-value-num.winprob {
            color: var(--accent-green);
        }
        .bb-value-num.winprob.under {
            color: var(--accent-blue);
        }
        .bb-value-arrow {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: 600;
        }
        .bb-value-vs {
            font-size: 0.55rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        
        /* Two Column Layout - Equal Width */
        .bb-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6rem;
        }
        @media (max-width: 520px) {
            .bb-columns { grid-template-columns: 1fr; }
        }
        
        /* Line Visualization Panel */
        .bb-line-panel {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
        }
        .bb-line-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            letter-spacing: 0.03em;
        }
        
        /* Number Line Visualization */
        .bb-number-line {
            position: relative;
            height: 40px;
            margin: 0.5rem 0;
        }
        .bb-line-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--bg-secondary);
            border-radius: 2px;
            transform: translateY(-50%);
        }
        .bb-line-range {
            position: absolute;
            height: 100%;
            border-radius: 2px;
        }
        .bb-line-range.over {
            background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.3));
        }
        .bb-line-range.under {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.3), transparent);
        }
        .bb-line-marker {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 2;
        }
        .bb-marker-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid var(--bg-card);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .bb-marker-dot.vegas {
            background: var(--text-muted);
        }
        .bb-marker-dot.model {
            background: var(--accent-green);
        }
        .bb-marker-dot.model.under {
            background: var(--accent-blue);
        }
        .bb-marker-label {
            font-size: 0.55rem;
            font-weight: 700;
            margin-top: 0.2rem;
            white-space: nowrap;
        }
        .bb-marker-label.vegas {
            color: var(--text-muted);
        }
        .bb-marker-label.model {
            color: var(--accent-green);
        }
        .bb-marker-label.model.under {
            color: var(--accent-blue);
        }
        .bb-line-endpoints {
            display: flex;
            justify-content: space-between;
            font-size: 0.5rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }
        
        /* Projected Score */
        .bb-proj-score {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }
        .bb-proj-team {
            font-size: 0.68rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .bb-proj-pts {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .bb-proj-at {
            color: var(--text-muted);
            font-size: 0.6rem;
        }
        .bb-proj-eq {
            color: var(--text-muted);
            font-weight: 600;
        }
        .bb-proj-total {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            font-weight: 800;
        }
        .bb-proj-total.over { color: var(--accent-green); }
        .bb-proj-total.under { color: var(--accent-blue); }
        
        /* Matchup Table Panel */
        .bb-matchup-panel {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        .bb-matchup-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            letter-spacing: 0.03em;
        }
        .bb-matchup-table {
            width: 100%;
            font-family: 'JetBrains Mono', monospace;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .bb-matchup-row {
            display: grid;
            grid-template-columns: 1.6fr repeat(4, 1fr);
            gap: 0.3rem;
            padding: 0.35rem 0.2rem;
            font-size: 0.68rem;
            align-items: center;
        }
        .bb-matchup-row.header {
            font-size: 0.6rem;
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 0.4rem 0.2rem;
            margin-bottom: 0.2rem;
        }
        .bb-matchup-cell {
            text-align: center;
        }
        .bb-matchup-cell:first-child {
            text-align: left;
            font-weight: 600;
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 0.68rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .bb-matchup-cell.positive { color: var(--accent-green); }
        .bb-matchup-cell.negative { color: var(--accent-red); }

        /* ========== NEW ANALYSIS PANEL DESIGN (Screenshot-inspired) ========== */

        /* Main Analysis Container - 3 Panel Layout */
        .analysis-panel {
            display: grid;
            grid-template-columns: 1fr 1.3fr 1fr;
            gap: 1rem;
            background: var(--bg-body);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 0.5rem;
        }

        @media (max-width: 900px) {
            .analysis-panel {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
        }

        /* Analysis Panel - Single Pick Version (Best Bets) */
        .analysis-panel.single-pick {
            grid-template-columns: 1fr 1.5fr 1fr;
        }

        @media (max-width: 900px) {
            .analysis-panel.single-pick {
                grid-template-columns: 1fr;
            }
        }

        /* Panel Sections */
        .analysis-section-panel {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
            min-height: 200px;
        }

        .analysis-section-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.6rem;
            padding-bottom: 0.4rem;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .analysis-section-title .title-icon {
            font-size: 0.85rem;
        }

        /* ===== LEFT PANEL: Matchup Insights ===== */
        .matchup-insights {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* Metric Comparison Row */
        .metric-compare-row {
            display: grid;
            grid-template-columns: 48px 1fr 48px;
            align-items: center;
            gap: 0.6rem;
            padding: 0.5rem 0;
        }

        .metric-compare-row:not(:last-child) {
            border-bottom: 1px solid var(--border-light);
        }

        .metric-team-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.82rem;
            font-weight: 700;
            min-width: 48px;
        }

        .metric-team-value.left {
            text-align: right;
            color: var(--text-primary);
        }

        .metric-team-value.right {
            text-align: left;
            color: var(--text-primary);
        }

        .metric-team-value.better {
            color: var(--accent-green);
        }

        .metric-bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }

        .metric-label {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .metric-bar-track {
            width: 100%;
            height: 6px;
            background: var(--bg-secondary);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .metric-bar-fill {
            position: absolute;
            top: 0;
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .metric-bar-fill.left {
            right: 50%;
            background: linear-gradient(90deg, var(--conf-elite), var(--orange));
        }

        .metric-bar-fill.right {
            left: 50%;
            background: linear-gradient(90deg, var(--orange), var(--conf-elite));
        }

        .metric-bar-center {
            position: absolute;
            left: 50%;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: var(--border-color);
            transform: translateX(-50%);
        }

        /* Team Labels for Metrics */
        .metric-team-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.6rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }

        .metric-team-label {
            font-size: 0.68rem;
            font-weight: 700;
            color: var(--text-secondary);
            max-width: 90px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ===== CENTER PANEL: Model Prediction ===== */
        .model-prediction-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.85rem;
            justify-content: flex-start;
        }

        /* Confidence Circle */
        .confidence-circle-container {
            position: relative;
            width: 110px;
            height: 110px;
            margin: 0.25rem 0;
        }

        .confidence-circle-bg {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            /* Background set via inline style for dynamic conic-gradient */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .confidence-circle-inner {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .confidence-circle-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.6rem;
            font-weight: 800;
            color: var(--conf-elite);
            line-height: 1;
        }

        .confidence-circle-label {
            font-size: 0.5rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-top: 0.25rem;
            text-align: center;
            line-height: 1.4;
            max-width: 60px;
        }

        /* Model Version Badge */
        .model-badge {
            font-size: 0.55rem;
            font-weight: 700;
            padding: 0.2rem 0.5rem;
            background: var(--orange-dim);
            color: var(--orange);
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Pick Predictions Grid */
        .predictions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            width: 100%;
        }

        .prediction-box {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 0.6rem;
            text-align: center;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .prediction-box.best-pick {
            border-color: var(--conf-bestbet);
            background: var(--conf-bestbet-dim);
        }

        .prediction-box.best-pick::before {
            content: 'BEST PICK';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5rem;
            font-weight: 700;
            padding: 0.15rem 0.4rem;
            background: var(--conf-bestbet);
            color: white;
            border-radius: 3px;
            letter-spacing: 0.03em;
        }

        .prediction-label {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.3rem;
        }

        .prediction-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--text-primary);
        }

        .prediction-value.spread { color: var(--accent-green); }
        .prediction-value.under { color: var(--accent-blue); }
        .prediction-value.over { color: var(--accent-green); }

        .prediction-edge {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-top: 0.2rem;
        }

        .prediction-edge .edge-value {
            color: var(--accent-green);
            font-weight: 600;
        }

        .prediction-projected {
            font-size: 0.55rem;
            color: var(--text-muted);
            margin-top: 0.15rem;
        }

        /* Model Insight Text */
        .model-insight {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 0.5rem 0.6rem;
            width: 100%;
            display: flex;
            align-items: flex-start;
            gap: 0.4rem;
            border-left: 3px solid var(--orange);
        }

        .model-insight-icon {
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .model-insight-text {
            font-size: 0.68rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .model-insight-text strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* ===== RIGHT PANEL: Key Factors ===== */
        .key-factors-panel {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        /* Factor Item */
        .factor-item-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.6rem;
            background: var(--bg-secondary);
            border-radius: 5px;
            font-size: 0.72rem;
        }

        .factor-item-row .factor-icon {
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .factor-item-row .factor-text {
            flex: 1;
            color: var(--text-secondary);
        }

        .factor-item-row .factor-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: var(--text-primary);
        }

        .factor-item-row.positive {
            border-left: 2px solid var(--accent-green);
        }

        .factor-item-row.negative {
            border-left: 2px solid var(--accent-red);
        }

        .factor-item-row.neutral {
            border-left: 2px solid var(--text-muted);
        }

        /* Stat Mini Cards */
        .stat-mini-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: auto;
            padding-top: 0.5rem;
        }

        .stat-mini-card {
            background: var(--bg-secondary);
            border-radius: 5px;
            padding: 0.5rem 0.4rem;
            text-align: center;
        }

        .stat-mini-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-mini-value.positive { color: var(--accent-green); }
        .stat-mini-value.negative { color: var(--accent-red); }

        .stat-mini-label {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 0.15rem;
        }

        /* ===== V2 Analysis Grid (Games Tab - Both Spread & Total) ===== */
        .v2-analysis-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .v2-analysis-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        @media (max-width: 700px) {
            .v2-analysis-row {
                grid-template-columns: 1fr;
            }
        }

        /* Single Analysis Panel for Games Tab */
        .v2-single-analysis {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
        }

        .v2-single-analysis.pass {
            opacity: 0.65;
        }

        .v2-analysis-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            padding-bottom: 0.4rem;
            border-bottom: 1px solid var(--border-light);
        }

        .v2-analysis-title {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .v2-analysis-title .title-emoji {
            font-size: 0.9rem;
        }

        .v2-analysis-badge {
            font-size: 0.55rem;
            font-weight: 700;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .v2-analysis-badge.pass {
            background: var(--accent-yellow-dim);
            color: var(--accent-yellow);
        }

        .v2-analysis-badge.play {
            background: var(--accent-green-dim);
            color: var(--accent-green);
        }

        /* V2 Prediction Summary */
        .v2-prediction-summary {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.4rem;
            margin-bottom: 0.5rem;
        }

        .v2-pred-item {
            text-align: center;
            padding: 0.4rem 0.2rem;
            background: var(--bg-card);
            border-radius: 5px;
        }

        .v2-pred-label {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .v2-pred-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .v2-pred-value.highlight { color: var(--accent-green); }
        .v2-pred-value.under { color: var(--accent-blue); }

        /* V2 Compact Stats */
        .v2-compact-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .v2-stats-col {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .v2-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.4rem;
            background: var(--bg-card);
            border-radius: 4px;
            font-size: 0.65rem;
        }

        .v2-stat-label {
            color: var(--text-muted);
            font-weight: 500;
        }

        .v2-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            color: var(--text-primary);
        }

        .v2-stat-value.positive { color: var(--accent-green); }
        .v2-stat-value.negative { color: var(--accent-red); }

        /* V2 Key Factor Pills */
        .v2-factors {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            margin-top: 0.4rem;
        }

        .v2-factor-pill {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem 0.4rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .v2-factor-pill.positive {
            background: var(--accent-green-dim);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .v2-factor-pill.negative {
            background: var(--accent-red-dim);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .v2-factor-pill .pill-emoji {
            font-size: 0.7rem;
        }

        /* ========== END NEW ANALYSIS PANEL DESIGN ========== */

        /* ========== NEW BEST BETS PAGE LAYOUT ========== */
        .bb-page-container {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 1.5rem;
            height: calc(100vh - 180px);
            overflow: hidden;
        }

        @media (max-width: 900px) {
            .bb-page-container {
                grid-template-columns: 1fr;
                height: auto;
                overflow: visible;
            }
            .bb-sidebar {
                order: 2;
                position: relative;
                top: 0;
            }
        }

        /* Sidebar Filters */
        .bb-sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            height: fit-content;
            align-self: start;
            overflow-y: auto;
            max-height: 100%;
        }

        .bb-filter-section {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
        }

        .bb-filter-title {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.75rem;
        }

        .bb-conf-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .bb-conf-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.5rem 0.6rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .bb-conf-item:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .bb-conf-item.active {
            background: var(--orange-dim);
            color: var(--orange);
            font-weight: 600;
        }

        .bb-conf-checkbox {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.15s;
        }

        .bb-conf-item.active .bb-conf-checkbox {
            background: var(--orange);
            border-color: var(--orange);
        }

        .bb-conf-item.active .bb-conf-checkbox::after {
            content: '';
            color: white;
            font-size: 0.7rem;
            font-weight: 700;
        }

        /* Probability Slider */
        .bb-slider-container {
            padding: 0.5rem 0;
        }

        .bb-slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .bb-slider-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .bb-slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--orange);
        }

        .bb-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--border-color);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .bb-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
        }

        .bb-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--orange);
            cursor: pointer;
            border: 3px solid var(--bg-card);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            margin-top: -6px;
        }

        .bb-slider::-moz-range-track {
            width: 100%;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
        }

        .bb-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--orange);
            cursor: pointer;
            border: 3px solid var(--bg-card);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        /* Main Content Area */
        .bb-main-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: 100%;
            overflow: hidden;
        }

        .bb-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            flex-shrink: 0;
        }

        .bb-picks-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .bb-title-section h2 {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
            margin: 0;
        }

        .bb-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* Header Controls Container */
        .bb-header-controls,
        .games-header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* Team Search in Header */
        .bb-team-search-container,
        .games-team-search-header {
            position: relative;
            min-width: 180px;
        }

        .bb-team-search-input {
            width: 100%;
            padding: 0.6rem 2rem 0.6rem 0.75rem;
            font-size: 0.85rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
        }

        .bb-team-search-input:focus {
            outline: none;
            border-color: var(--orange);
        }

        .bb-team-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
        }

        .bb-team-search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .bb-team-search-dropdown.show {
            display: block;
        }

        .bb-team-search-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .bb-team-search-item:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        @media (max-width: 768px) {
            .bb-header-controls,
            .games-header-controls {
                flex-direction: column;
                align-items: stretch;
                width: 100%;
            }
            .bb-team-search-container,
            .games-team-search-header {
                min-width: unset;
                width: 100%;
            }
        }

        /* Type Tabs (Spread/Total/Highest Value) */
        .bb-type-tabs {
            display: flex;
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 4px;
            gap: 4px;
        }

        .bb-type-tab {
            padding: 0.6rem 1.25rem;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bb-type-tab:hover {
            color: var(--text-primary);
        }

        .bb-type-tab.active {
            background: var(--orange);
            color: white;
        }

        /* Pick Cards List */
        .bb-picks-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* New Pick Card Design */
        .bb-pick-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem 1.25rem;
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            align-items: center;
            gap: 1.25rem;
            transition: all 0.2s;
        }
        .bb-pick-card.tier-bestbet { border-left-color: var(--conf-bestbet); }
        .bb-pick-card.tier-elite   { border-left-color: var(--conf-elite); }
        .bb-pick-card.tier-high    { border-left-color: var(--conf-high); }
        .bb-pick-card.tier-medium  { border-left-color: var(--conf-medium); }
        .bb-pick-card.tier-low     { border-left-color: var(--border-color); }

        .bb-pick-card:hover {
            border-color: var(--orange);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        @media (max-width: 768px) {
            .bb-pick-card {
                grid-template-columns: auto 1fr;
                gap: 0.75rem;
            }
            .bb-pick-stats,
            .bb-pick-confidence {
                grid-column: span 2;
            }
        }

        /* Rank Badge */
        .bb-pick-rank {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.15rem;
        }

        .bb-pick-rank-label {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .bb-pick-rank-num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--orange);
        }

        /* Team/Matchup Info */
        .bb-pick-info {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .bb-pick-matchup {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .bb-pick-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Pick Badge */
        .bb-pick-badge-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
        }

        .bb-pick-badge-label {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .bb-pick-badge {
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
        }

        .bb-pick-badge.spread {
            background: var(--accent-green-dim);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }

        .bb-pick-badge.over {
            background: var(--accent-green-dim);
            color: var(--accent-green);
            border: 1px solid var(--accent-green);
        }

        .bb-pick-badge.under {
            background: var(--accent-blue-dim);
            color: var(--accent-blue);
            border: 1px solid var(--accent-blue);
        }

        /* Model Confidence */
        .bb-pick-confidence {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.35rem;
            min-width: 140px;
        }

        .bb-pick-confidence-label {
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .bb-pick-confidence-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .bb-pick-confidence-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .bb-pick-confidence-fill.bestbet { background: var(--conf-bestbet); }
        .bb-pick-confidence-fill.elite { background: var(--conf-elite); }
        .bb-pick-confidence-fill.high { background: var(--conf-high); }
        .bb-pick-confidence-fill.medium { background: var(--conf-medium); }

        .bb-pick-confidence-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Basketball Rating in Best Bets card */
        .bb-pick-rating {
            margin-top: 0.25rem;
        }

        .bb-pick-rating .elite-rating-balls {
            display: flex;
            gap: 1px;
        }

        /* Card Analysis Toggle */
        .bb-pick-card .analytics-toggle {
            grid-column: 1 / -1;
            margin-top: 0.5rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-light);
        }

        /* Empty state */
        .bb-empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }

        .bb-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .bb-empty-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .bb-empty-text {
            font-size: 0.9rem;
        }

        /* ========== END NEW BEST BETS PAGE LAYOUT ========== */

        /* ========== NEW GAMES TAB LAYOUT ========== */
        .games-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .games-title-section h2 {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
            margin: 0;
        }

        .games-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .games-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        /* Games Page Layout - Similar to Best Bets */
        .games-page-container {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 1.5rem;
            padding: 1rem;
            height: calc(100vh - 180px);
            overflow: hidden;
        }

        @media (max-width: 900px) {
            .games-page-container {
                grid-template-columns: 1fr;
                height: auto;
                overflow: visible;
            }
            .games-sidebar {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
                position: relative;
                top: 0;
            }
            .games-sidebar .bb-filter-section {
                flex: 1;
                min-width: 200px;
            }
        }

        .games-sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            height: fit-content;
            align-self: start;
            overflow-y: auto;
            max-height: 100%;
        }

        .games-main-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: 100%;
            overflow: hidden;
        }

        .games-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            flex-shrink: 0;
        }

        .games-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .games-sort-pills {
            display: flex;
            gap: 0.5rem;
        }

        /* Team Search in Sidebar */
        .games-team-search-container {
            position: relative;
        }

        .games-team-search-input {
            width: 100%;
            padding: 0.6rem 0.75rem;
            font-size: 0.85rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
        }

        .games-team-search-input:focus {
            outline: none;
            border-color: var(--orange);
        }

        .games-team-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
        }

        .games-team-search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .games-team-search-dropdown.show {
            display: block;
        }

        /* Game Card - Similar to Best Bets */
        .game-card-new {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem 1.25rem;
            transition: all 0.2s;
        }

        .game-card-new:hover {
            border-color: var(--orange);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .game-card-new-header {
            display: grid;
            grid-template-columns: minmax(200px, 1fr) auto 100px;
            align-items: center;
            gap: 1rem;
            justify-items: start;
        }

        .game-card-new-header .game-picks-container {
            justify-self: center;
        }

        .game-card-new-header .game-vegas-lines {
            justify-self: end;
        }

        @media (max-width: 768px) {
            .game-card-new-header {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        /* Matchup Info */
        .game-matchup-info {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .game-matchup-teams {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .game-matchup-meta {
            font-size: 0.8rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .game-conf-badge {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }

        /* Picks Container - Side by Side */
        .game-picks-container {
            display: flex;
            gap: 1rem;
            align-items: stretch;
        }

        @media (max-width: 600px) {
            .game-picks-container {
                flex-direction: column;
                gap: 0.75rem;
            }
        }

        /* Individual Pick Box */
        .game-pick-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            padding: 0.6rem 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            min-width: 140px;
            border: 2px solid transparent;
            flex: 1;
        }

        .game-pick-box.has-pick {
            border-color: var(--border-color);
        }

        .game-pick-box.has-pick.bestbet {
            border-color: var(--conf-bestbet);
            background: var(--conf-bestbet-dim);
        }

        .game-pick-box.has-pick.elite {
            border-color: var(--conf-elite);
            background: var(--conf-elite-dim);
        }

        .game-pick-box.has-pick.high {
            border-color: var(--conf-high);
            background: var(--conf-high-dim);
        }

        .game-pick-box.has-pick.medium {
            border-color: var(--conf-medium);
            background: var(--conf-medium-dim);
        }

        .game-pick-label {
            font-size: 0.6rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Tier Label */
        .game-pick-tier {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
            box-sizing: border-box;
        }

        .game-pick-tier.bestbet {
            background: var(--conf-bestbet);
            color: white;
        }

        .game-pick-tier.elite {
            background: var(--conf-elite);
            color: white;
        }

        .game-pick-tier.high {
            background: var(--conf-high);
            color: white;
        }

        .game-pick-tier.medium {
            background: var(--conf-medium);
            color: white;
        }

        .game-pick-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .game-pick-box.has-pick.bestbet .game-pick-value,
        .game-pick-box.has-pick.elite .game-pick-value {
            color: var(--conf-elite);
        }

        .game-pick-box.has-pick.high .game-pick-value {
            color: var(--conf-high);
        }

        .game-pick-box.no-pick .game-pick-value {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .game-pick-winprob {
            font-size: 0.65rem;
            font-weight: 700;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
            box-sizing: border-box;
        }

        .game-pick-winprob.bestbet {
            background: var(--conf-bestbet);
            color: white;
        }

        .game-pick-winprob.elite {
            background: var(--conf-elite);
            color: white;
        }

        .game-pick-winprob.high {
            background: var(--conf-high);
            color: white;
        }

        .game-pick-winprob.medium {
            background: var(--conf-medium);
            color: white;
        }

        /* Prob Row - win prob and tier on same line */
        .game-pick-prob-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
            margin-top: 0.25rem;
        }

        /* Basketball Rating in pick box */
        .game-pick-rating {
            margin-top: 0.35rem;
            display: flex;
            justify-content: center;
        }

        .game-pick-rating .elite-rating-balls {
            display: flex;
            gap: 1px;
        }

        /* Vegas Lines */
        .game-vegas-lines {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.25rem;
        }

        .game-vegas-line {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .game-vegas-label {
            color: var(--text-muted);
            font-weight: 500;
        }

        .game-vegas-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Analysis Toggle for Game Card */
        .game-card-new .analytics-toggle {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-light);
        }

        .bb-empty-text {
            font-size: 0.9rem;
        }

        /* ========== END NEW BEST BETS PAGE LAYOUT ========== */

        /* Scoring Factors */
        .bb-factors-section { margin-bottom: 1.5rem; }
        .bb-factors-header { font-size: 0.95rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.75rem; }
        .bb-factors-list { display: flex; flex-direction: column; gap: 0.6rem; }
        .bb-factor-item { display: flex; align-items: center; gap: 0.75rem; background: var(--bg-card); border-radius: 8px; padding: 0.75rem 1rem; border-left: 4px solid var(--border-color); }
        .bb-factor-item.supports { border-left-color: var(--accent-green); background: rgba(34, 197, 94, 0.05); }
        .bb-factor-item.against { border-left-color: var(--accent-red); background: rgba(239, 68, 68, 0.03); }
        .bb-factor-item.neutral { border-left-color: var(--accent-yellow); }
        .bb-factor-icon { font-size: 1.1rem; }
        .bb-factor-content { flex: 1; }
        .bb-factor-name { font-size: 0.95rem; font-weight: 600; color: var(--text-primary); }
        .bb-factor-desc { font-size: 0.85rem; color: var(--text-muted); margin-top: 0.2rem; }
        .bb-factor-supports { font-size: 1.1rem; color: var(--accent-green); }

        /* ====== Record Filter Strip ====== */
        .record-filter-strip {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            margin-bottom: 1rem;
            padding: 0.4rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .record-filter-btn {
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.15s;
            min-height: 32px;
        }
        .record-filter-btn:hover { background: var(--bg-secondary); }
        .record-filter-btn.active {
            background: var(--orange-dim);
            color: var(--orange);
            border-color: var(--orange);
        }
        .record-filter-btn.ball-filter { font-size: 0.6rem; padding: 0.3rem 0.5rem; letter-spacing: -1px; }
        .record-filter-divider { width: 1px; height: 20px; background: var(--border-color); flex-shrink: 0; }
        @media (max-width: 768px) {
            .record-filter-strip { gap: 0.2rem; padding: 0.3rem; }
            .record-filter-btn { font-size: 0.65rem; padding: 0.3rem 0.5rem; }
            .record-filter-btn.ball-filter { font-size: 0.5rem; padding: 0.25rem 0.35rem; }
        }

        /* ====== Trend Indicator ====== */
        .val-hero-trend {
            display: flex; align-items: center; justify-content: center; gap: 0.75rem;
            margin-top: 0.5rem; padding-top: 0.5rem;
            border-top: 1px solid rgba(255,255,255,0.06);
            font-size: 0.75rem; color: var(--text-secondary);
        }
        .trend-chip {
            display: inline-flex; align-items: center; gap: 0.3rem;
            padding: 0.2rem 0.5rem; border-radius: 6px; font-weight: 600; font-size: 0.7rem;
        }
        .trend-chip.up { background: rgba(46,204,113,0.12); color: var(--accent-green); }
        .trend-chip.down { background: rgba(231,76,60,0.12); color: var(--accent-red); }
        .trend-chip.flat { background: rgba(255,255,255,0.06); color: var(--text-muted); }

        /* ====== Type Breakdown Cards ====== */
        .record-type-breakdown {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem;
        }
        .record-type-card {
            background: var(--bg-card); border: 1px solid var(--border-color);
            border-radius: 10px; padding: 0.75rem 1rem;
        }
        .record-type-label {
            font-size: 0.7rem; font-weight: 600; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.04em; margin-bottom: 0.3rem;
        }
        .record-type-record { font-size: 1.1rem; font-weight: 700; font-variant-numeric: tabular-nums; }
        .record-type-record.green { color: var(--accent-green); }
        .record-type-record.red { color: var(--accent-red); }
        .record-type-meta { font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.15rem; }
        .record-type-bar { width: 100%; height: 6px; background: var(--bg-secondary); border-radius: 3px; margin-top: 0.4rem; overflow: hidden; }
        .record-type-bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
        @media (max-width: 600px) { .record-type-breakdown { grid-template-columns: 1fr; } }

        /* Validation */
        .validation-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .validation-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; text-align: center; }
        .tier-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.25rem; }
        .tier-card.elite { border-left: 4px solid var(--conf-elite); }
        .tier-card.high { border-left: 4px solid var(--conf-high); }
        .tier-card.medium { border-left: 4px solid var(--conf-medium); }
        .tier-card.low { border-left: 4px solid var(--text-muted); }
        .tier-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .tier-name { display: flex; align-items: center; gap: 0.5rem; font-weight: 700; }
        .tier-badge { min-width: 42px; height: 28px; padding: 0 6px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.65rem; color: white; }
        .tier-record { font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 700; }
        .tier-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
        .tier-stat { background: var(--bg-input); padding: 0.5rem; border-radius: 8px; text-align: center; }
        .tier-stat-value { font-family: 'JetBrains Mono', monospace; font-weight: 700; }
        .tier-stat-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }
        .validation-log { max-height: 400px; overflow-y: auto; }
        .validation-pick { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 10px; padding: 0.75rem 1rem; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; }
        .validation-pick.win { border-left: 4px solid var(--accent-green); }
        .validation-pick.loss { border-left: 4px solid var(--accent-red); }
        .validation-pick-team { font-weight: 600; }
        .validation-pick-details { font-size: 0.75rem; color: var(--text-secondary); }
        .validation-pick-result { display: flex; align-items: center; gap: 0.5rem; }
        .validation-type { font-size: 0.65rem; font-weight: 700; padding: 0.2rem 0.4rem; border-radius: 4px; background: var(--bg-input); color: var(--text-muted); }
        .validation-conf { min-width: 36px; height: 28px; padding: 0 6px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.75rem; color: white; }
        .validation-outcome { padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 700; }
        .validation-outcome.win { background: var(--accent-green-dim); color: var(--accent-green); }
        .validation-outcome.loss { background: var(--accent-red-dim); color: var(--accent-red); }

        /* Daily Performance Chart */
        .daily-chart-container { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.25rem; margin-bottom: 1rem; }
        .daily-chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 0.75rem; }
        .daily-card { background: var(--bg-input); border-radius: 10px; padding: 1rem; text-align: center; border-left: 4px solid var(--border-color); }
        .daily-card.winning { border-left-color: var(--accent-green); background: var(--accent-green-dim); }
        .daily-card.losing { border-left-color: var(--accent-red); background: var(--accent-red-dim); }
        .daily-card.even { border-left-color: var(--accent-yellow); }
        .daily-card-date { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.25rem; }
        .daily-card-day { font-weight: 700; font-size: 0.9rem; margin-bottom: 0.5rem; }
        .daily-card-record { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; }
        .daily-card.winning .daily-card-record { color: var(--accent-green); }
        .daily-card.losing .daily-card-record { color: var(--accent-red); }
        .daily-card-units { font-size: 0.85rem; font-weight: 600; margin-top: 0.25rem; }
        .daily-card-units.positive { color: var(--accent-green); }
        .daily-card-units.negative { color: var(--accent-red); }
        .daily-tiers { display: flex; flex-direction: column; gap: 4px; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color); }
        .daily-tier-row { display: flex; align-items: center; gap: 6px; font-size: 0.7rem; }
        .daily-tier-label { min-width: 12px; height: 12px; border-radius: 3px; }
        .daily-tier-bar { flex: 1; height: 14px; background: var(--bg-card); border-radius: 3px; overflow: hidden; position: relative; }
        .daily-tier-fill { height: 100%; border-radius: 3px; display: flex; align-items: center; justify-content: center; }
        .daily-tier-text { font-size: 0.6rem; font-weight: 700; color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.3); }
        .daily-chart-empty { text-align: center; padding: 2rem; color: var(--text-muted); font-size: 0.9rem; }
        .daily-chart-summary { display: flex; justify-content: center; gap: 1.5rem; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); }
        .daily-summary-item { text-align: center; }
        .daily-summary-value { font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; font-weight: 700; }
        .daily-summary-value.green { color: var(--accent-green); }
        .daily-summary-value.red { color: var(--accent-red); }
        .daily-summary-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; }

        /* Prediction Tracker System */
        .tracker-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.75rem; }
        .tracker-status { display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: var(--text-secondary); }
        .tracker-status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--accent-green); animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .tracker-actions { display: flex; gap: 0.5rem; }
        .tracker-btn { padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-card); color: var(--text-primary); font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .tracker-btn:hover { background: var(--bg-card-hover); border-color: var(--orange); }
        .tracker-btn.primary { background: var(--orange); color: white; border-color: var(--orange); }
        .tracker-btn.primary:hover { background: var(--orange-hover); }
        .tracker-btn.danger { color: var(--accent-red); border-color: var(--accent-red-dim); }
        .tracker-btn.danger:hover { background: var(--accent-red-dim); }
        
        .tracker-stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem; }
        .tracker-stat-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; text-align: center; }
        .tracker-stat-card.highlight { border-color: var(--orange); background: var(--orange-dim); }
        .tracker-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; }
        .tracker-stat-value.green { color: var(--accent-green); }
        .tracker-stat-value.red { color: var(--accent-red); }
        .tracker-stat-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; margin-top: 0.25rem; }
        
        .tracker-section { margin-bottom: 1.5rem; }
        .tracker-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
        .tracker-section-title { font-size: 1rem; font-weight: 700; display: flex; align-items: center; gap: 0.5rem; }
        .tracker-section-subtitle { font-size: 0.75rem; color: var(--text-muted); }
        
        .tracker-breakdown { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
        .tracker-breakdown-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; }
        .tracker-breakdown-card.best-bets { border-left: 4px solid var(--conf-bestbet); }
        .tracker-breakdown-card.spreads { border-left: 4px solid var(--accent-blue); }
        .tracker-breakdown-card.totals { border-left: 4px solid var(--accent-green); }
        .tracker-breakdown-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; }
        .tracker-breakdown-title { font-weight: 700; font-size: 0.9rem; }
        .tracker-breakdown-record { font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 700; }
        .tracker-breakdown-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; }
        .tracker-breakdown-stat { background: var(--bg-input); padding: 0.5rem; border-radius: 6px; text-align: center; }
        .tracker-breakdown-stat-value { font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 0.9rem; }
        .tracker-breakdown-stat-label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; }
        
        .tracker-tiers { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem; }
        .tracker-tier { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 10px; padding: 0.875rem; }
        .tracker-tier.bestbet { border-left: 4px solid var(--conf-bestbet); }
        .tracker-tier.elite { border-left: 4px solid var(--conf-elite); }
        .tracker-tier.high { border-left: 4px solid var(--conf-high); }
        .tracker-tier.medium { border-left: 4px solid var(--conf-medium); }
        .tracker-tier.low { border-left: 4px solid var(--conf-low); }
        .tracker-tier.unknown { border-left: 4px solid var(--text-muted); }
        .tracker-tier.unknown { border-left: 4px solid var(--text-muted); background: var(--bg-secondary); }
        .tracker-tier-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; }
        .tracker-tier-name { font-weight: 700; font-size: 0.85rem; display: flex; align-items: center; gap: 0.4rem; }
        .tracker-tier-badge { min-width: 38px; height: 22px; padding: 0 5px; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.6rem; color: white; }
        .tracker-tier-record { font-family: 'JetBrains Mono', monospace; font-weight: 700; }
        .tracker-tier-stats { display: flex; gap: 0.75rem; }
        .tracker-tier-stat { flex: 1; background: var(--bg-input); padding: 0.4rem; border-radius: 5px; text-align: center; }
        .tracker-tier-stat-value { font-family: 'JetBrains Mono', monospace; font-weight: 600; font-size: 0.8rem; }
        .tracker-tier-stat-label { font-size: 0.55rem; color: var(--text-muted); text-transform: uppercase; }
        
        .tracker-picks-list { max-height: 500px; overflow-y: auto; }
        .tracker-pick { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 10px; padding: 0.75rem 1rem; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; }
        .tracker-pick.win { border-left: 4px solid var(--accent-green); }
        .tracker-pick.loss { border-left: 4px solid var(--accent-red); }
        .tracker-pick.push { border-left: 4px solid var(--accent-yellow); }
        .tracker-pick.pending { border-left: 4px solid var(--text-muted); opacity: 0.85; }
        .tracker-pick-main { flex: 1; min-width: 200px; }
        .tracker-pick-team { font-weight: 600; display: flex; align-items: center; gap: 0.4rem; }
        .tracker-pick-team .best-bet-badge { background: var(--conf-bestbet); color: white; font-size: 0.55rem; padding: 0.15rem 0.35rem; border-radius: 3px; font-weight: 700; }
        .tracker-pick-details { font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.2rem; }
        .tracker-pick-meta { display: flex; align-items: center; gap: 0.5rem; }
        .tracker-pick-type { font-size: 0.65rem; font-weight: 700; padding: 0.2rem 0.4rem; border-radius: 4px; background: var(--bg-input); color: var(--text-muted); }
        .tracker-pick-conf { min-width: 32px; height: 24px; padding: 0 5px; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.7rem; color: white; }
        .tracker-pick-outcome { padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; font-weight: 700; min-width: 50px; text-align: center; }
        .tracker-pick-outcome.win { background: var(--accent-green-dim); color: var(--accent-green); }
        .tracker-pick-outcome.loss { background: var(--accent-red-dim); color: var(--accent-red); }
        .tracker-pick-outcome.push { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .tracker-pick-outcome.pending { background: var(--bg-input); color: var(--text-muted); }
        
        .tracker-filters { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem; }
        .tracker-filter { padding: 0.4rem 0.75rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-card); color: var(--text-secondary); font-size: 0.75rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .tracker-filter:hover { border-color: var(--orange); color: var(--text-primary); }
        .tracker-filter.active { background: var(--orange); color: white; border-color: var(--orange); }
        
        .tracker-empty { text-align: center; padding: 3rem 1rem; color: var(--text-muted); }
        .tracker-empty-icon { font-size: 3rem; margin-bottom: 1rem; }
        .tracker-empty-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-primary); }
        .tracker-empty-text { font-size: 0.9rem; max-width: 400px; margin: 0 auto; }
        
        /* Best Bet Rating Breakdown */
        .best-bet-summary {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-bestbet-dim) 100%);
            border: 1px solid var(--conf-bestbet-border);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .best-bet-summary-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--conf-bestbet);
            margin-bottom: 0.75rem;
        }
        .best-bet-summary-stats {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }
        .best-bet-summary-stat {
            text-align: center;
        }
        .best-bet-summary-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .best-bet-summary-value.green { color: var(--accent-green); }
        .best-bet-summary-value.red { color: var(--accent-red); }
        .best-bet-summary-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .best-bet-rating-breakdown {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .rating-breakdown-header {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }
        .rating-breakdown-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.75rem;
        }
        .rating-breakdown-card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }
        .rating-breakdown-rating {
            margin-bottom: 0.5rem;
        }
        .rating-breakdown-record {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .rating-breakdown-record.green { color: var(--accent-green); }
        .rating-breakdown-record.red { color: var(--accent-red); }
        .rating-breakdown-stats {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            justify-content: center;
            gap: 0.5rem;
        }
        .rating-breakdown-stats .green { color: var(--accent-green); }
        .rating-breakdown-stats .red { color: var(--accent-red); }
        
        /* Tier Filter Summary */
        .tier-filter-summary {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .tier-filter-summary-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }
        .tier-filter-summary-stats {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }
        .tier-filter-stat {
            text-align: center;
        }
        .tier-filter-stat-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .tier-filter-stat-value.green { color: var(--accent-green); }
        .tier-filter-stat-value.red { color: var(--accent-red); }
        .tier-filter-stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .picks-list-divider {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin: 1rem 0 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        /* Trend Banner */
        .trend-banner { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem 1.25rem; margin-bottom: 1rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .trend-indicator { display: flex; align-items: center; gap: 0.75rem; }
        .trend-icon { font-size: 1.5rem; }
        .trend-text { font-weight: 600; font-size: 1rem; }
        .trend-banner.hot { border-left: 4px solid var(--accent-green); background: linear-gradient(90deg, var(--accent-green-dim), var(--bg-card)); }
        .trend-banner.hot .trend-text { color: var(--accent-green); }
        .trend-banner.cold { border-left: 4px solid var(--accent-red); background: linear-gradient(90deg, var(--accent-red-dim), var(--bg-card)); }
        .trend-banner.cold .trend-text { color: var(--accent-red); }
        .trend-banner.neutral { border-left: 4px solid var(--accent-yellow); }
        .trend-details { display: flex; gap: 1.5rem; flex-wrap: wrap; }
        .trend-detail { display: flex; align-items: center; gap: 0.4rem; font-size: 0.85rem; }
        .trend-label { color: var(--text-muted); }
        .trend-detail span:last-child { font-weight: 600; font-family: 'JetBrains Mono', monospace; }

        /* Chart Container */
        .chart-tabs { display: flex; gap: 0.5rem; }
        .chart-tab { padding: 0.4rem 0.75rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-card); color: var(--text-secondary); font-size: 0.75rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .chart-tab:hover { border-color: var(--orange); color: var(--text-primary); }
        .chart-tab.active { background: var(--orange); color: white; border-color: var(--orange); }
        .chart-container { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.25rem; min-height: 300px; }
        .chart-placeholder { text-align: center; padding: 3rem; color: var(--text-muted); }
        .chart-svg { width: 100%; height: 240px; display: block; }
        .chart-bar-group { cursor: pointer; }
        .chart-bar-group:hover rect { opacity: 0.8; }
        .chart-line { fill: none; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round; }
        .chart-area { opacity: 0.15; }
        .chart-dot { stroke-width: 2; }
        .chart-grid-line { stroke: var(--border-color); stroke-dasharray: 4,4; }
        .chart-axis-label { font-size: 10px; fill: var(--text-muted); }
        .chart-legend { display: flex; justify-content: center; gap: 1.5rem; margin-top: 1rem; flex-wrap: wrap; }
        .chart-legend-item { display: flex; align-items: center; gap: 0.4rem; font-size: 0.75rem; color: var(--text-secondary); }
        .chart-legend-dot { width: 10px; height: 10px; border-radius: 50%; }
        .chart-tooltip { position: absolute; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.5rem 0.75rem; font-size: 0.75rem; box-shadow: var(--shadow-hover); pointer-events: none; z-index: 100; }

        /* Daily Calendar */
        .daily-calendar { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; overflow-x: auto; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 0.5rem; min-width: 500px; }
        .calendar-header { font-size: 0.7rem; font-weight: 600; color: var(--text-muted); text-align: center; padding: 0.5rem; text-transform: uppercase; }
        .calendar-day { background: var(--bg-input); border-radius: 8px; padding: 0.5rem; min-height: 70px; cursor: pointer; transition: all 0.2s; border: 2px solid transparent; }
        .calendar-day:hover { border-color: var(--orange); transform: translateY(-2px); }
        .calendar-day.winning { background: var(--accent-green-dim); border-color: var(--accent-green); }
        .calendar-day.losing { background: var(--accent-red-dim); border-color: var(--accent-red); }
        .calendar-day.even { background: var(--accent-yellow-dim); border-color: var(--accent-yellow); }
        .calendar-day.no-picks { opacity: 0.5; cursor: default; }
        .calendar-day.no-picks:hover { border-color: transparent; transform: none; }
        .calendar-day.future { opacity: 0.3; cursor: default; }
        .calendar-day.future:hover { border-color: transparent; transform: none; }
        .calendar-day-date { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem; }
        .calendar-day-record { font-family: 'JetBrains Mono', monospace; font-size: 1rem; font-weight: 700; text-align: center; }
        .calendar-day.winning .calendar-day-record { color: var(--accent-green); }
        .calendar-day.losing .calendar-day-record { color: var(--accent-red); }
        .calendar-day-units { font-size: 0.7rem; text-align: center; margin-top: 0.25rem; }
        .calendar-day-units.positive { color: var(--accent-green); }
        .calendar-day-units.negative { color: var(--accent-red); }
        .calendar-day-breakdown { display: flex; justify-content: center; gap: 0.25rem; margin-top: 0.35rem; }
        .calendar-day-dot { width: 6px; height: 6px; border-radius: 50%; }
        .calendar-loading { text-align: center; padding: 2rem; color: var(--text-muted); }
        .calendar-legend { display: flex; justify-content: center; gap: 1.25rem; margin-top: 1rem; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 0.4rem; font-size: 0.75rem; color: var(--text-secondary); }
        .legend-dot { width: 12px; height: 12px; border-radius: 4px; }
        .legend-dot.winning { background: var(--accent-green); }
        .legend-dot.losing { background: var(--accent-red); }
        .legend-dot.even { background: var(--accent-yellow); }
        .legend-dot.no-picks { background: var(--bg-input); border: 1px solid var(--border-color); }

        /* Day Detail Modal */
        .day-detail-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 1rem; }
        .day-detail-content { background: var(--bg-primary); border-radius: 16px; max-width: 500px; width: 100%; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
        .day-detail-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.25rem; border-bottom: 1px solid var(--border-color); }
        .day-detail-header h3 { font-size: 1.1rem; font-weight: 700; }
        .day-detail-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted); padding: 0; line-height: 1; }
        .day-detail-close:hover { color: var(--text-primary); }
        .day-detail-body { padding: 1.25rem; overflow-y: auto; }
        .day-detail-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; margin-bottom: 1rem; }
        .day-detail-stat { background: var(--bg-input); border-radius: 8px; padding: 0.75rem; text-align: center; }
        .day-detail-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 700; }
        .day-detail-stat-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }
        .day-detail-picks { margin-top: 1rem; }
        .day-detail-picks-title { font-size: 0.85rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-secondary); }
        .day-detail-pick { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.75rem; background: var(--bg-card); border-radius: 6px; margin-bottom: 0.5rem; border-left: 3px solid var(--border-color); }
        .day-detail-pick.win { border-left-color: var(--accent-green); }
        .day-detail-pick.loss { border-left-color: var(--accent-red); }
        .day-detail-pick.push { border-left-color: var(--accent-yellow); }
        .day-detail-pick-info { font-size: 0.85rem; }
        .day-detail-pick-result { font-size: 0.75rem; font-weight: 600; padding: 0.2rem 0.5rem; border-radius: 4px; }
        .day-detail-pick-result.win { background: var(--accent-green-dim); color: var(--accent-green); }
        .day-detail-pick-result.loss { background: var(--accent-red-dim); color: var(--accent-red); }
        .day-detail-pick-result.push { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        
        /* Tier Breakdown in Day Detail */
        .day-detail-tier-breakdown { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); }
        .day-detail-tier-title { font-size: 0.75rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0.75rem; letter-spacing: 0.5px; }
        .day-detail-tier-row { display: grid; grid-template-columns: 80px repeat(3, 1fr); gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--bg-input); border-radius: 8px; border-left: 3px solid var(--border-color); }
        .day-detail-tier-row.elite { border-left-color: var(--conf-elite); }
        .day-detail-tier-row.high { border-left-color: var(--conf-high); }
        .day-detail-tier-row.medium { border-left-color: var(--conf-medium); }
        .day-detail-tier-row.low { border-left-color: var(--conf-low); }
        .day-detail-tier-row.unknown { border-left-color: var(--text-muted); background: var(--bg-secondary); }
        .day-detail-tier-label { font-size: 0.7rem; font-weight: 600; }
        .day-detail-tier-label.elite { color: var(--conf-elite); }
        .day-detail-tier-label.high { color: var(--conf-high); }
        .day-detail-tier-label.medium { color: var(--conf-medium); }
        .day-detail-tier-label.low { color: var(--conf-low); }
        .day-detail-tier-label.unknown { color: var(--text-muted); }
        [data-theme="dark"] .day-detail-tier-label.high { color: var(--text-primary); }
        .day-detail-tier-stat { text-align: center; }
        .day-detail-tier-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; font-weight: 700; }
        .day-detail-tier-stat-label { font-size: 0.55rem; color: var(--text-muted); text-transform: uppercase; }

        /* Breakdown Trends */
        .breakdown-trend { margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; }
        .breakdown-trend-icon { font-size: 1rem; }
        .breakdown-trend-text { color: var(--text-secondary); }
        .breakdown-trend.hot .breakdown-trend-text { color: var(--accent-green); }
        .breakdown-trend.cold .breakdown-trend-text { color: var(--accent-red); }

        /* Tier Trend Bars */
        .tier-trend-bar { margin-top: 0.75rem; height: 6px; background: var(--bg-input); border-radius: 3px; overflow: hidden; display: flex; }
        .tier-trend-segment { height: 100%; transition: width 0.3s; }
        .tier-trend-segment.win { background: var(--accent-green); }
        .tier-trend-segment.loss { background: var(--accent-red); }
        .tier-trend-segment.pending { background: var(--text-muted); opacity: 0.3; }

        /* March Madness Bracket - Traditional Aligned Layout */
        .bracket-status { text-align: center; padding: 1rem; color: var(--text-muted); }
        .bracket-wrapper { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; overflow: auto; }
        .bracket-container { min-width: 1000px; }
        .bracket-ff-top { background: linear-gradient(135deg, var(--bg-input), var(--bg-card)); border-radius: 12px; padding: 1rem; margin-bottom: 1rem; }
        .bracket-ff-title { font-family: 'Playfair Display', Georgia, serif; font-size: 1.1rem; font-weight: 700; color: var(--accent-theme); text-align: center; margin-bottom: 0.75rem; }
        [data-theme="dark"] .bracket-ff-title { color: var(--orange); }
        .bracket-ff-row { display: flex; justify-content: center; align-items: flex-start; gap: 1.5rem; flex-wrap: wrap; }
        .bracket-ff-game { background: var(--bg-card); border: 2px solid var(--navy); border-radius: 8px; padding: 0.5rem; min-width: 150px; cursor: pointer; }
        .bracket-ff-game:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        [data-theme="dark"] .bracket-ff-game { border-color: var(--orange); }
        .bracket-ff-game.upset { border-color: var(--accent-red); background: var(--accent-red-dim); }
        .bracket-ff-label { font-size: 0.6rem; color: var(--text-muted); text-align: center; margin-bottom: 4px; text-transform: uppercase; font-weight: 600; }
        .bracket-champ-box { background: linear-gradient(135deg, var(--navy) 0%, #2d4a7c 100%); border-radius: 12px; padding: 1rem 1.5rem; text-align: center; }
        [data-theme="dark"] .bracket-champ-box { background: linear-gradient(135deg, var(--orange) 0%, #e6a756 100%); }
        .bracket-champ-label { color: rgba(255,255,255,0.8); font-size: 0.65rem; text-transform: uppercase; letter-spacing: 1px; }
        .bracket-champ-team { color: white; font-size: 1.2rem; font-weight: 700; font-family: 'Playfair Display', Georgia, serif; margin-top: 0.25rem; }
        .bracket-champ-seed { color: rgba(255,255,255,0.7); font-size: 0.75rem; }
        .bracket-quadrants { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        .bracket-quadrant { background: var(--bg-input); border-radius: 10px; padding: 0.5rem; }
        .bracket-region-title { font-family: 'Playfair Display', Georgia, serif; font-size: 0.95rem; font-weight: 700; color: var(--accent-theme); text-align: center; padding: 0.4rem; margin-bottom: 0.5rem; border-bottom: 2px solid var(--border-color); }
        [data-theme="dark"] .bracket-region-title { color: var(--orange); }
        .bracket-rounds-row { display: flex; width: 100%; align-items: stretch; }
        .bracket-round-col { flex: 1; display: flex; flex-direction: column; min-width: 0; }
        .bracket-round-title { text-align: center; font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; font-weight: 700; padding: 4px 0; background: var(--bg-card); border-radius: 4px; margin: 0 2px 4px 2px; flex-shrink: 0; }
        .bracket-games-col { display: flex; flex-direction: column; flex: 1; }
        /* R64: 8 games, tight spacing */
        .bracket-round-col.r64 .bracket-games-col { justify-content: flex-start; }
        .bracket-round-col.r64 .bracket-game { margin: 1px 2px; }
        /* R32: 4 games, each centered between 2 R64 games */
        .bracket-round-col.r32 .bracket-games-col { justify-content: space-around; }
        .bracket-round-col.r32 .bracket-game { margin: 1px 2px; }
        /* S16: 2 games, each centered between 2 R32 games */
        .bracket-round-col.s16 .bracket-games-col { justify-content: space-around; }
        .bracket-round-col.s16 .bracket-game { margin: 1px 2px; }
        /* E8: 1 game, centered in column */
        .bracket-round-col.e8 .bracket-games-col { justify-content: center; }
        .bracket-round-col.e8 .bracket-game { margin: 1px 2px; }
        .bracket-game { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.65rem; overflow: hidden; cursor: pointer; transition: all 0.15s; flex-shrink: 0; }
        .bracket-game:hover { border-color: var(--accent-blue); box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .bracket-game.upset { border: 2px solid var(--accent-red); background: var(--accent-red-dim); }
        .bracket-game-team { display: flex; align-items: center; padding: 3px 5px; gap: 3px; border-bottom: 1px solid var(--border-color); }
        .bracket-game-team:last-child { border-bottom: none; }
        .bracket-game-team.winner { background: var(--accent-green-dim); font-weight: 600; }
        .bracket-game-team.loser { opacity: 0.55; }
        .bracket-game-seed { min-width: 14px; font-weight: 700; color: var(--text-muted); font-size: 0.6rem; }
        .bracket-game-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.62rem; }
        .bracket-game-prob { font-size: 0.55rem; color: var(--accent-blue); font-weight: 600; min-width: 26px; text-align: right; }
        .bracket-stats-bar { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-bottom: 1rem; padding: 1rem; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; }
        .bracket-stat { text-align: center; min-width: 80px; }
        .bracket-stat-value { font-size: 1.1rem; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
        .bracket-stat-value.green { color: var(--accent-green); }
        .bracket-stat-value.red { color: var(--accent-red); }
        .bracket-stat-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }
        .bracket-sim-controls { display: flex; gap: 1rem; align-items: center; flex-wrap: wrap; }
        .bracket-legend { display: flex; gap: 1rem; justify-content: center; margin-top: 0.75rem; font-size: 0.7rem; color: var(--text-muted); }
        .bracket-legend-item { display: flex; align-items: center; gap: 4px; }
        .bracket-legend-box { width: 14px; height: 14px; border-radius: 3px; }
        .bracket-analysis-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .bracket-analysis-content { background: var(--bg-card); border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        .bracket-analysis-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color); }
        .bracket-analysis-title { font-family: 'Playfair Display', Georgia, serif; font-size: 1rem; font-weight: 700; color: var(--accent-theme); }
        [data-theme="dark"] .bracket-analysis-title { color: var(--orange); }
        .bracket-analysis-close { background: none; border: none; font-size: 1.25rem; cursor: pointer; color: var(--text-muted); }
        .bracket-analysis-matchup { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .bracket-analysis-team { text-align: center; flex: 1; }
        .bracket-analysis-team.winner { color: var(--accent-green); }
        .bracket-analysis-seed { font-size: 0.7rem; color: var(--text-muted); }
        .bracket-analysis-name { font-weight: 700; font-size: 0.9rem; }
        .bracket-analysis-prob { font-size: 0.8rem; color: var(--accent-blue); }
        .bracket-analysis-vs { color: var(--text-muted); font-weight: 700; }
        .bracket-analysis-text { font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6; }
        .bracket-analysis-factors { margin-top: 1rem; }
        .bracket-analysis-factor { display: flex; justify-content: space-between; font-size: 0.8rem; padding: 0.35rem 0; border-bottom: 1px solid var(--border-color); }
        .bracket-analysis-factor:last-child { border-bottom: none; }

        /* Info Cards */
        .info-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.25rem; margin-bottom: 1rem; box-shadow: var(--shadow-card); }
        .info-card h3 { font-family: 'Playfair Display', Georgia, serif; color: var(--accent-theme); font-size: 1rem; font-weight: 700; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem; }
        [data-theme="dark"] .info-card h3 { color: var(--orange); }
        .info-card p, .info-card li { color: var(--text-secondary); font-size: 0.875rem; line-height: 1.7; margin-bottom: 0.6rem; }
        .info-card ul { margin-left: 1.25rem; }
        .formula-box { background: var(--bg-input); border-radius: 10px; padding: 1rem; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; margin: 1rem 0; }
        .scale-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; margin-top: 1rem; }
        .scale-item { background: var(--bg-input); border-radius: 10px; padding: 0.75rem; display: flex; align-items: center; gap: 0.75rem; }
        .scale-badge { width: 36px; height: 36px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 800; font-size: 0.85rem; color: white; }
        .scale-info strong { display: block; font-size: 0.85rem; }
        .scale-info span { font-size: 0.7rem; color: var(--text-muted); }

        /* Empty State */
        .empty-state { text-align: center; padding: 2rem 1.5rem; }
        .empty-icon { font-size: 2.5rem; margin-bottom: 0.75rem; opacity: 0.5; }
        .empty-title { font-size: 1rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.4rem; }
        .empty-text { font-size: 0.8rem; color: var(--text-muted); }

        /* ========== TOP 5 PICKS SECTION ========== */
        .top5-section {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
            border: 3px solid var(--navy);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            box-shadow: var(--shadow-card);
            position: relative;
            overflow: hidden;
        }
        
        [data-theme="dark"] .top5-section {
            border-color: var(--navy-light);
        }
        
        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .top5-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
            gap: 0.4rem;
        }
        
        .top5-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .top5-title h3 {
            font-family: 'Playfair Display', Georgia, serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }
        
        .top5-fire-icon {
            font-size: 1.25rem;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .top5-date-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.35rem 0.75rem;
            background: var(--navy);
            border: 1px solid var(--navy);
            border-radius: 5px;
            font-size: 0.7rem;
            font-weight: 600;
            color: white;
        }
        
        [data-theme="dark"] .top5-date-badge {
            background: var(--orange);
            border-color: var(--orange);
        }
        
        .top5-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.4rem;
            align-items: stretch;
        }
        
        @media (max-width: 1200px) {
            .top5-grid { grid-template-columns: repeat(3, 1fr); }
        }
        
        @media (max-width: 768px) {
            .top5-grid { grid-template-columns: repeat(2, 1fr); }
        }
        
        @media (max-width: 480px) {
            .top5-grid { grid-template-columns: 1fr; }
        }
        
        .top5-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .top5-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
            border-color: var(--orange);
        }
        
        .top5-card:focus-within {
            outline: 2px solid var(--orange);
            outline-offset: 2px;
        }
        
        .top5-card.bestbet {
            border-top: 4px solid var(--conf-bestbet);
            border-left: none;
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-bestbet-dim) 100%);
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.2);
        }
        
        .top5-card.elite {
            border-top: 3px solid var(--conf-elite);
            border-left: none;
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-elite-dim) 100%);
        }
        
        .top5-card.high {
            border-top: 3px solid var(--conf-high);
            border-left: none;
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-high-dim) 100%);
        }
        
        .top5-card.medium {
            border-top: 3px solid var(--conf-medium);
            border-left: none;
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--conf-medium-dim) 100%);
        }
        
        .top5-rank {
            position: absolute;
            top: 0.35rem;
            right: 0.35rem;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--navy);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 700;
        }
        
        [data-theme="dark"] .top5-rank {
            background: var(--orange);
        }
        
        .top5-matchup {
            font-size: 0.75rem;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 0.2rem;
            padding-right: 1.5rem;
            line-height: 1.25;
            letter-spacing: -0.01em;
            height: 2.5em; /* Fixed height for 2 lines with better spacing */
            overflow: hidden;
            flex-shrink: 0;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .top5-time {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
            flex-shrink: 0;
        }
        
        .top5-time-icon {
            font-size: 0.65rem;
            opacity: 0.8;
        }
        
        .top5-bet {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.4rem;
            background: var(--bg-input);
            border-radius: 6px;
            margin-bottom: 0.3rem;
            border: 1px solid var(--border-light);
            flex-shrink: 0;
        }
        
        .top5-bet-icon {
            font-size: 0.85rem;
        }
        
        .top5-bet-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 800;
            color: var(--text-primary);
            flex: 1;
        }
        
        .top5-bet-type {
            font-size: 0.55rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            padding: 0.15rem 0.35rem;
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        
        .top5-confidence {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.25rem;
            margin-top: auto;
            flex-shrink: 0;
        }
        
        .top5-conf-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        
        .top5-conf-meter {
            flex: 1;
            height: 5px;
            background: var(--bg-input);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .top5-conf-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease;
        }
        
        .top5-conf-fill.elite { background: linear-gradient(90deg, var(--conf-elite), #e67a35); }
        .top5-conf-fill.high { background: linear-gradient(90deg, var(--conf-high), #162d4a); }
        .top5-conf-fill.medium { background: linear-gradient(90deg, var(--conf-medium), #3670ab); }
        
        .top5-conf-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 24px;
            text-align: right;
        }
        
        .top5-conf-value.elite { color: var(--conf-elite); }
        .top5-conf-value.high { color: var(--conf-high); }
        .top5-conf-value.medium { color: var(--conf-medium); }
        
        /* Top 5 Win Probability Badge */
        .top5-winprob {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.3rem 0.5rem;
            border-radius: 6px;
            background: var(--bg-input);
            border: 2px solid var(--border-color);
            margin-top: 0.4rem;
        }
        .top5-winprob.bestbet { border-color: var(--conf-bestbet); background: var(--conf-bestbet-dim); }
        .top5-winprob.elite { border-color: var(--conf-elite); background: var(--conf-elite-dim); }
        .top5-winprob.high { border-color: var(--conf-high); background: var(--conf-high-dim); }
        .top5-winprob.medium { border-color: var(--conf-medium); background: var(--conf-medium-dim); }
        
        .top5-winprob-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 800;
            line-height: 1.1;
        }
        .top5-winprob.bestbet .top5-winprob-value { color: var(--conf-bestbet); font-weight: 800; }
        .top5-winprob.elite .top5-winprob-value { color: var(--conf-elite); }
        .top5-winprob.high .top5-winprob-value { color: var(--conf-high); }
        .top5-winprob.medium .top5-winprob-value { color: var(--conf-medium); }
        
        .top5-winprob-label {
            font-size: 0.55rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }
        
        .top5-analysis-winprob {
            font-size: 0.85rem;
            color: var(--conf-bestbet);
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        /* Top 5 Header Right - Groups date and Analysis button */
        .top5-header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        /* Top 5 Analysis Toggle Button (in header) */
        .top5-analysis-toggle {
            padding: 0.35rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .top5-analysis-toggle:hover {
            background: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--accent-theme);
        }
        [data-theme="dark"] .top5-analysis-toggle:hover {
            border-color: var(--orange);
        }
        .top5-analysis-toggle.active {
            background: var(--navy);
            color: white;
            border-color: var(--navy);
        }
        [data-theme="dark"] .top5-analysis-toggle.active {
            background: var(--orange);
            border-color: var(--orange);
        }
        
        /* Top 5 Analysis Content - Hidden by default */
        .top5-analysis-content {
            display: none;
            margin-top: 0.4rem;
            padding-top: 0.4rem;
            border-top: 1px solid var(--border-color);
        }
        
        /* Show analysis when grid has .show-analysis class */
        .top5-grid.show-analysis .top5-analysis-content {
            display: block;
        }
        
        .top5-empty {
            grid-column: 1 / -1;
            text-align: center;
            padding: 1rem;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .top5-empty-icon {
            font-size: 1.75rem;
            margin-bottom: 0.35rem;
            opacity: 0.5;
        }
        
        .top5-note {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 0.5rem;
            text-align: center;
            padding: 0.35rem;
            background: var(--bg-input);
            border-radius: 6px;
        }

        /* Alert */
        .alert { padding: 0.75rem; border-radius: 8px; margin-bottom: 0.75rem; font-size: 0.8rem; display: flex; align-items: flex-start; gap: 0.5rem; background: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-secondary); }

        /* Spinner */
        .spinner { width: 16px; height: 16px; border: 2px solid var(--border-color); border-top-color: var(--accent-theme); border-radius: 50%; animation: spin 0.8s linear infinite; display: inline-block; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Footer */
        .footer { text-align: center; padding: 1.25rem; color: var(--text-muted); font-size: 0.75rem; }
        .footer-brand { font-family: 'Playfair Display', Georgia, serif; font-weight: 700; color: var(--accent-theme); }

        /* ==================== ADVANCED ANALYTICS STYLES ==================== */
        .analytics-section { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); }
        .analytics-section-title { font-size: 0.85rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.4rem; }
        
        .analytics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem; margin-top: 0.75rem; }
        .analytics-card { background: var(--bg-input); border-radius: 10px; padding: 0.75rem; border: 1px solid var(--border-color); }
        .analytics-card h4 { font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.4rem; }
        
        /* EV Display */
        .ev-display { text-align: center; padding: 0.35rem; }
        .ev-value { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; }
        .ev-value.positive { color: var(--accent-green); }
        .ev-value.negative { color: var(--accent-red); }
        .ev-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.04em; margin-top: 0.2rem; }
        
        /* Kelly Display */
        .kelly-display { display: flex; flex-direction: column; gap: 0.5rem; }
        .kelly-value { font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 700; color: var(--accent-theme); }
        .kelly-breakdown { display: flex; flex-direction: column; gap: 0.25rem; font-size: 0.7rem; color: var(--text-secondary); }
        .kelly-breakdown span { display: flex; justify-content: space-between; }
        
        /* Pace Mismatch */
        .pace-mismatch { display: flex; flex-direction: column; gap: 0.5rem; }
        .pace-bar-container { display: flex; align-items: center; gap: 0.5rem; }
        .pace-bar { flex: 1; height: 6px; background: var(--bg-card); border-radius: 3px; overflow: hidden; }
        .pace-bar-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }
        .pace-bar-fill.fast { background: var(--accent-yellow); }
        .pace-bar-fill.slow { background: var(--accent-blue); }
        .pace-label { font-family: 'JetBrains Mono', monospace; font-size: 0.65rem; color: var(--text-secondary); min-width: 35px; }
        .pace-verdict { text-align: center; padding: 0.5rem; background: var(--bg-card); border-radius: 6px; font-size: 0.75rem; color: var(--text-secondary); }
        .pace-verdict.extreme { background: var(--accent-yellow-dim); border: 1px solid rgba(245, 158, 11, 0.3); color: var(--accent-yellow); }
        
        /* Sharp Money Indicator */
        .sharp-indicator { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 8px; }
        .sharp-indicator.aligned { background: var(--accent-green-dim); border: 1px solid rgba(16, 185, 129, 0.3); }
        .sharp-indicator.against { background: var(--accent-red-dim); border: 1px solid rgba(239, 68, 68, 0.3); }
        .sharp-indicator.neutral { background: var(--bg-card); border: 1px solid var(--border-color); }
        .sharp-icon { font-size: 1.1rem; }
        .sharp-details { flex: 1; }
        .sharp-status { font-weight: 600; font-size: 0.8rem; margin-bottom: 0.1rem; }
        .sharp-move { font-size: 0.7rem; color: var(--text-secondary); }
        
        /* Regression Indicator */
        .regression-indicator { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--bg-card); border-radius: 6px; margin-bottom: 0.35rem; }
        .regression-arrow { font-size: 1.1rem; }
        .regression-text { flex: 1; font-size: 0.75rem; color: var(--text-secondary); }
        
        /* Correlation Badge */
        .correlation-badge { display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.25rem 0.5rem; border-radius: 15px; font-size: 0.65rem; font-weight: 500; }
        .correlation-badge.high { background: var(--accent-yellow-dim); color: var(--accent-yellow); border: 1px solid rgba(245, 158, 11, 0.3); }
        .correlation-badge.low { background: var(--accent-green-dim); color: var(--accent-green); border: 1px solid rgba(16, 185, 129, 0.3); }
        
        /* Bet Sizing */
        .bet-sizing { display: flex; flex-direction: column; gap: 1rem; padding: 1rem; background: var(--bg-input); border-radius: 12px; margin-top: 1rem; }
        .bet-sizing-header { display: flex; justify-content: space-between; align-items: center; }
        .bet-sizing-title { font-weight: 600; font-size: 0.9rem; }
        .unit-size { font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 700; color: var(--accent-theme); }
        .unit-breakdown { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; }
        .unit-option { text-align: center; padding: 0.75rem; background: var(--bg-card); border-radius: 8px; cursor: pointer; border: 1px solid var(--border-color); transition: all 0.2s; }
        .unit-option:hover { border-color: var(--accent-theme); }
        .unit-option.recommended { border-color: var(--accent-green); background: var(--accent-green-dim); }
        .unit-option-value { font-family: 'JetBrains Mono', monospace; font-weight: 600; font-size: 1rem; margin-bottom: 0.25rem; }
        .unit-option-label { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; }
        
        /* Game Script */
        .game-script { display: flex; flex-direction: column; gap: 0.5rem; }
        .script-scenario { display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem 0.75rem; background: var(--bg-card); border-radius: 8px; }
        .script-prob { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; font-weight: 600; min-width: 40px; }
        .script-bar { flex: 1; height: 6px; background: var(--bg-input); border-radius: 3px; overflow: hidden; }
        .script-bar-fill { height: 100%; border-radius: 3px; }
        .script-label { font-size: 0.75rem; color: var(--text-secondary); min-width: 100px; text-align: right; }
        
        /* Analytics Tab */
        .analytics-tab-grid { display: grid; gap: 1.5rem; }
        .analytics-summary-card { background: var(--bg-card); border-radius: 16px; padding: 1.5rem; border: 1px solid var(--border-color); }
        .analytics-summary-card h3 { font-size: 1rem; font-weight: 600; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem; }
        
        /* Toggle for analytics in game cards */
        .analytics-toggle { display: flex; align-items: center; justify-content: center; gap: 0.35rem; padding: 0.4rem; margin: 0 1rem 0.5rem; background: var(--bg-input); border-radius: 5px; cursor: pointer; font-size: 0.72rem; font-weight: 500; color: var(--text-secondary); transition: all 0.2s; border: 1px solid var(--border-color); }
        .analytics-toggle:hover { background: var(--bg-card-hover); color: var(--text-primary); }
        .analytics-content { display: none; margin-top: 1rem; }
        .analytics-content.visible { display: block; }
        
        /* Verdict Box - Main Pick Display */
        .verdict-box { background: var(--bg-input); border-radius: 12px; padding: 1.25rem; border: 1px solid var(--border-color); }
        .verdict-box.elite { background: linear-gradient(135deg, var(--conf-elite-dim), rgba(255, 140, 66, 0.05)); border-color: var(--conf-elite-border); }
        .verdict-box.high { background: linear-gradient(135deg, var(--conf-high-dim), rgba(30, 58, 95, 0.05)); border-color: var(--conf-high-border); }
        .verdict-box.medium { background: linear-gradient(135deg, var(--conf-medium-dim), rgba(74, 143, 212, 0.03)); border-color: var(--conf-medium-border); }
        .verdict-box.neutral { background: var(--bg-card); border-color: var(--border-color); }
        
        /* NEW: Game Header Row */
        .game-header-row { display: grid; grid-template-columns: 1fr auto 1fr; gap: 0.75rem; padding: 0.625rem 1rem; align-items: center; }
        .team-col { }
        .team-col.home { text-align: right; }
        .team-col .team-name { font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem; }
        .team-col .team-meta { font-size: 0.7rem; color: var(--text-muted); }
        .team-col .team-rating { font-size: 0.8rem; margin-top: 0.25rem; }
        .game-info-col { text-align: center; min-width: 120px; }
        .game-datetime { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.25rem; }
        .game-line { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; font-weight: 600; color: var(--text-primary); padding: 0.35rem 0.75rem; background: var(--bg-input); border-radius: 6px; }
        
        /* NEW: Picks Row - Side by Side */
        .picks-row { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; padding: 0.75rem 1rem; }
        @media (max-width: 600px) { .picks-row { grid-template-columns: 1fr; } }
        
        .pick-col { background: var(--bg-input); border-radius: 10px; padding: 0.75rem; border: 1px solid var(--border-color); display: flex; flex-direction: column; min-height: 120px; }
        .pick-col.has-pick { border-color: var(--conf-medium-border); background: var(--conf-medium-dim); }
        .pick-col.has-pick.bestbet { border-color: var(--conf-bestbet-border); background: linear-gradient(135deg, var(--conf-bestbet-dim), transparent); }
        .pick-col.has-pick.high { border-color: var(--conf-high-border); background: linear-gradient(135deg, var(--conf-high-dim), transparent); }
        .pick-col.no-pick { opacity: 0.6; }
        
        .pick-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem; }
        .pick-type-label { font-size: 0.65rem; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; }
        
        .pick-confidence { width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: 700; color: white; }
        .pick-confidence.bestbet { background: var(--conf-bestbet); }
        .pick-confidence.elite { background: var(--conf-elite); }
        .pick-confidence.high { background: var(--conf-high); }
        .pick-confidence.medium { background: var(--conf-medium); }
        .pick-confidence.low { background: var(--text-muted); }
        
        .pick-main { display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.4rem; }
        .pick-icon { font-size: 1.25rem; }
        .pick-team-name { font-size: 1rem; font-weight: 700; color: var(--text-primary); }
        .pick-line-value { font-family: 'JetBrains Mono', monospace; font-size: 1rem; font-weight: 600; color: var(--accent-theme); }
        
        .pick-metrics { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.35rem; margin-bottom: 0.5rem; }
        .pick-metric { text-align: center; padding: 0.3rem; background: var(--bg-card); border-radius: 5px; }
        .pm-value { display: block; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; font-weight: 600; color: var(--text-primary); }
        .pm-value.positive { color: var(--accent-green); }
        .pm-label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; }
        
        .btn-track { width: 100%; padding: 0.6rem; background: var(--conf-high); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 0.8rem; cursor: pointer; transition: all 0.2s; margin-top: auto; }
        .btn-track:hover { background: var(--conf-elite); transform: translateY(-1px); }
        
        .no-pick-msg { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1.25rem 0.5rem; color: var(--text-muted); font-size: 0.8rem; gap: 0.25rem; min-height: 80px; }
        .no-pick-msg span:first-child { font-size: 1.25rem; opacity: 0.6; }
        
        .no-data-msg { text-align: center; padding: 1.5rem; color: var(--text-muted); font-size: 0.85rem; }
        
        .drill-summary { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.75rem; line-height: 1.5; }
        
        .verdict-header { display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; }
        .verdict-icon { font-size: 1.5rem; }
        .verdict-pick { font-size: 1.1rem; font-weight: 700; color: var(--text-primary); }
        .verdict-line { font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; font-weight: 600; color: var(--accent-theme); }
        .verdict-summary { font-size: 0.9rem; color: var(--text-secondary); line-height: 1.5; margin-bottom: 1rem; }
        
        .verdict-metrics { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; padding: 0.85rem; background: var(--bg-card); border-radius: 10px; border: 1px solid var(--border-light); }
        .verdict-metric { text-align: center; }
        .metric-value { display: block; font-family: 'JetBrains Mono', monospace; font-size: 1.15rem; font-weight: 800; color: var(--text-primary); }
        .metric-value.positive { color: var(--accent-green); }
        .metric-value.negative { color: var(--accent-red); }
        .metric-label { font-size: 0.7rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.06em; font-weight: 600; }
        
        /* Drill Down Content */
        .drill-down-content { display: none; margin: 0 0.5rem 0.4rem; padding: 0.4rem; background: var(--bg-secondary); border-radius: 5px; border: 1px solid var(--border-color); }
        .drill-down-content.visible { display: block; }
        
        /* Analysis Sections - Compact & Clear */
        .analysis-section { margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color); }
        .analysis-section:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
        
        .section-header-large { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem; }
        .section-icon { font-size: 1.1rem; }
        .section-header-large > span:nth-child(2) { font-size: 1rem; font-weight: 700; color: var(--text-primary); letter-spacing: 0.02em; }
        .section-badge { font-size: 0.7rem; font-weight: 700; padding: 0.2rem 0.5rem; border-radius: 10px; background: var(--bg-input); color: var(--text-secondary); margin-left: auto; }
        .section-badge.high { background: var(--accent-blue-dim); color: var(--accent-blue); }
        
        .section-explainer { font-size: 0.72rem; color: var(--text-muted); margin-bottom: 0.5rem; font-style: italic; }
        
        /* Highlighted Reasoning Box */
        .highlight-section { background: var(--orange-dim); border-radius: 10px; padding: 0.75rem; margin-bottom: 1rem; border: 1px solid rgba(255, 140, 66, 0.2); }
        .reasoning-box { }
        .reasoning-item { font-size: 0.85rem; color: var(--text-primary); line-height: 1.5; margin-bottom: 0.4rem; padding: 0.5rem 0.75rem; background: var(--bg-input); border-radius: 6px; border-left: 3px solid var(--accent-theme); }
        .reasoning-item:last-child { margin-bottom: 0; }
        .reasoning-item strong { color: var(--accent-theme); }
        
        /* ==================== ANALYST INSIGHT BOX ==================== */
        .analyst-insight-box {
            background: linear-gradient(135deg, var(--bg-input) 0%, var(--bg-secondary) 100%);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--accent-theme);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
        }
        
        .analyst-insight-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.35rem;
        }
        
        .analyst-insight-text {
            font-size: 0.85rem;
            color: var(--text-primary);
            line-height: 1.5;
            margin: 0;
            font-style: italic;
        }
        
        /* ==================== CLEAN ANALYSIS STYLES ==================== */
        .analysis-section-clean {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid var(--border-color);
        }
        
        .analysis-header-clean {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        .analysis-title-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .analysis-icon { font-size: 1rem; }
        .analysis-title { font-size: 0.85rem; font-weight: 700; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.03em; }
        
        .score-pill {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 700;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            background: var(--bg-input);
            color: var(--text-secondary);
        }
        .score-pill.elite { background: var(--conf-elite-dim); color: var(--conf-elite); }
        .score-pill.high { background: var(--conf-high-dim); color: var(--conf-high); }
        .score-pill.medium { background: var(--conf-medium-dim); color: var(--conf-medium); }
        
        .analysis-grid-clean {
            display: grid;
            grid-template-columns: 60px 1fr auto;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        @media (max-width: 500px) {
            .analysis-grid-clean {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
        }
        
        /* Mini Score Ring */
        .score-ring-mini {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: conic-gradient(
                var(--gauge-color, var(--accent-green)) calc(var(--score, 0) * 3.6deg),
                var(--bg-input) 0deg
            );
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .score-ring-mini-inner {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .score-ring-mini-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        /* Component Bars Clean */
        .component-bars-clean {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            flex: 1;
            min-width: 0;
        }
        
        .cb-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .cb-name {
            font-size: 0.65rem;
            color: var(--text-muted);
            width: 65px;
            flex-shrink: 0;
        }
        
        .cb-track {
            flex: 1;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            overflow: hidden;
            min-width: 60px;
        }
        
        .cb-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .cb-fill.green { background: var(--accent-green); }
        .cb-fill.blue { background: var(--accent-blue); }
        .cb-fill.yellow { background: var(--accent-yellow); }
        .cb-fill.purple { background: #8b5cf6; }
        
        .cb-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-secondary);
            width: 16px;
            text-align: right;
            flex-shrink: 0;
        }
        
        /* Key Stats Clean */
        .key-stats-clean {
            display: flex;
            gap: 0.75rem;
            flex-shrink: 0;
        }
        @media (max-width: 500px) {
            .key-stats-clean {
                justify-content: center;
            }
        }
        
        .stat-item-clean {
            text-align: center;
            min-width: 45px;
        }
        
        .stat-val-clean {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .stat-val-clean.positive { color: var(--accent-green); }
        
        .stat-lbl-clean {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Projection Comparison */
        .projection-compare {
            background: var(--bg-input);
            border-radius: 8px;
            padding: 0.6rem;
        }
        
        .proj-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.35rem;
        }
        .proj-row:last-child { margin-bottom: 0; }
        
        .proj-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            width: 40px;
            flex-shrink: 0;
        }
        
        .proj-bar {
            flex: 1;
            height: 18px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .proj-fill {
            height: 100%;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding-left: 0.5rem;
            font-size: 0.65rem;
            font-weight: 600;
            color: white;
            transition: width 0.3s ease;
        }
        .proj-fill.vegas { background: var(--text-muted); }
        .proj-fill.model { background: var(--accent-blue); }
        
        .proj-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            width: 40px;
            text-align: right;
            flex-shrink: 0;
        }
        
        /* Factors Section Clean */
        .factors-section-clean {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }
        
        .factors-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-weight: 600;
        }
        
        .factors-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }
        
        .factor-chip-clean {
            font-size: 0.68rem;
            padding: 0.2rem 0.5rem;
            border-radius: 10px;
            background: var(--bg-input);
            color: var(--text-secondary);
        }
        .factor-chip-clean.positive { background: var(--accent-green-dim); color: var(--accent-green); }
        .factor-chip-clean.negative { background: var(--accent-red-dim); color: var(--accent-red); }
        .factor-chip-clean.info { background: var(--accent-blue-dim); color: var(--accent-blue); }
        
        /* ==================== END CLEAN ANALYSIS STYLES ==================== */
        
        /* ==================== V2 ANALYSIS METHODOLOGY STYLES ==================== */
        
        /* Two-Column Analysis Layout - Compact Side-by-Side */
        .v2-analysis-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        @media (max-width: 680px) {
            .v2-analysis-grid {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
        }
        
        /* V2 Analysis Panel Container - Minimal & Clean */
        .v2-analysis-panel {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
            height: fit-content;
        }
        .v2-analysis-panel.has-edge {
            border-color: var(--accent-green);
            border-width: 1.5px;
        }
        .v2-analysis-panel.no-edge {
            opacity: 0.85;
        }
        
        /* V2 Panel Header - Minimal */
        .v2-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
            padding-bottom: 0.35rem;
            border-bottom: 1px solid var(--border-light);
        }
        .v2-panel-title {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .v2-panel-icon { font-size: 0.75rem; }
        .v2-panel-name { 
            font-size: 0.7rem; 
            font-weight: 700; 
            color: var(--text-primary); 
            text-transform: uppercase; 
            letter-spacing: 0.02em; 
        }
        .v2-no-edge-badge {
            font-size: 0.65rem;
            color: var(--accent-yellow);
            margin-left: 0.5rem;
        }
        
        /* V2 Action Banner - Minimal */
        .v2-action-banner {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }
        .v2-action-banner.bet {
            background: var(--accent-green-dim);
            color: var(--accent-green);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        .v2-action-banner.pass {
            background: var(--bg-input);
            color: var(--text-muted);
        }
        
        /* V2 Combined Edge + Probability Bar - Minimal */
        .v2-edge-prob-bar {
            position: relative;
            height: 18px;
            background: var(--bg-input);
            border-radius: 3px;
            margin-bottom: 0.4rem;
            overflow: hidden;
        }
        .v2-edge-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green));
            border-radius: 6px 0 0 6px;
            transition: width 0.4s ease;
        }
        .v2-edge-fill.negative {
            background: linear-gradient(90deg, var(--accent-yellow), var(--accent-red));
        }
        .v2-prob-overlay {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 255, 255, 0.15) 2px,
                rgba(255, 255, 255, 0.15) 4px
            );
            border-radius: 6px 0 0 6px;
            pointer-events: none;
        }
        .v2-breakeven-marker {
            position: absolute;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: var(--text-muted);
            opacity: 0.7;
        }
        .v2-breakeven-label {
            position: absolute;
            top: -14px;
            font-size: 0.55rem;
            color: var(--text-muted);
            transform: translateX(-50%);
            white-space: nowrap;
        }
        .v2-bar-labels {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 0.4rem;
            font-size: 0.55rem;
            font-weight: 600;
            pointer-events: none;
        }
        .v2-bar-edge-label { color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .v2-bar-prob-label { color: var(--text-secondary); font-size: 0.55rem; }
        
        /* V2 Metrics Row - Adaptive 2x2 Grid for Side-by-Side */
        .v2-metrics-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.25rem;
            margin-bottom: 0.4rem;
        }
        .v2-metric-card {
            text-align: center;
            padding: 0.3rem 0.15rem;
            background: var(--bg-input);
            border-radius: 4px;
            transition: background 0.2s, border 0.2s;
            border: 1px solid transparent;
        }
        .v2-metric-card.highlight {
            background: var(--accent-green-dim);
            border-color: rgba(34, 197, 94, 0.2);
        }
        .v2-metric-value {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.1;
        }
        .v2-metric-card.highlight .v2-metric-value {
            color: var(--accent-green);
        }
        .v2-metric-label {
            display: block;
            font-size: 0.45rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.02em;
            margin-top: 0.05rem;
        }
        
        /* V2 Vegas vs Model Comparison (retained from v1) */
        .v2-comparison-bar {
            background: var(--bg-input);
            border-radius: 4px;
            padding: 0.3rem 0.4rem;
            margin-bottom: 0.35rem;
        }
        .v2-comp-row {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            margin-bottom: 0.2rem;
        }
        .v2-comp-row:last-child { margin-bottom: 0; }
        .v2-comp-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            width: 32px;
            flex-shrink: 0;
        }
        .v2-comp-track {
            flex: 1;
            height: 10px;
            background: var(--bg-secondary);
            border-radius: 2px;
            overflow: hidden;
        }
        .v2-comp-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .v2-comp-fill.vegas { background: var(--text-muted); }
        .v2-comp-fill.model { background: var(--accent-blue); }
        .v2-comp-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            font-weight: 600;
            color: var(--text-primary);
            width: 36px;
            text-align: right;
            flex-shrink: 0;
        }
        
        /* V2 Context Chips - Minimal */
        .v2-context-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.2rem;
            margin-bottom: 0.35rem;
        }
        .v2-chip {
            font-size: 0.5rem;
            padding: 0.15rem 0.3rem;
            border-radius: 6px;
            background: var(--bg-input);
            color: var(--text-secondary);
            cursor: help;
            transition: transform 0.1s;
        }
        .v2-chip:hover { transform: scale(1.02); }
        .v2-chip.positive { background: var(--accent-green-dim); color: var(--accent-green); }
        .v2-chip.negative { background: var(--accent-red-dim); color: var(--accent-red); }
        .v2-chip.warning { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .v2-chip.info { background: var(--accent-blue-dim); color: var(--accent-blue); }
        
        /* V2 Key Number Alert - Minimal */
        .v2-key-number-alert {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.4rem;
            background: var(--accent-yellow-dim);
            border: 1px solid rgba(234, 179, 8, 0.3);
            border-radius: 4px;
            font-size: 0.55rem;
            color: var(--accent-yellow);
            margin-bottom: 0.35rem;
        }
        .v2-key-number-alert .alert-icon { font-size: 0.7rem; }
        
        /* V2 No Edge Explanation Box - Minimal */
        .v2-no-edge-box {
            background: var(--accent-yellow-dim);
            border: 1px solid rgba(234, 179, 8, 0.3);
            border-radius: 4px;
            padding: 0.3rem 0.4rem;
            margin-bottom: 0.35rem;
        }
        .v2-no-edge-title {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--accent-yellow);
            margin-bottom: 0.15rem;
        }
        .v2-no-edge-reasons {
            margin: 0;
            padding-left: 0.9rem;
            font-size: 0.55rem;
            color: var(--text-secondary);
        }
        .v2-no-edge-reasons li { margin-bottom: 0.15rem; }
        .v2-no-edge-reasons li:last-child { margin-bottom: 0; }
        
        /* V2 Model Lean (when no bet) */
        .v2-model-lean {
            margin-top: 0.3rem;
            padding: 0.3rem 0.4rem;
            background: var(--bg-input);
            border-radius: 4px;
            font-size: 0.6rem;
            color: var(--text-muted);
        }
        
        /* V2 Analyst Take - Auto-generated */
        .v2-analyst-take {
            background: linear-gradient(135deg, var(--bg-input) 0%, var(--bg-card) 100%);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--accent-theme);
            border-radius: 5px;
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.5rem;
        }
        .v2-analyst-label {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.15rem;
        }
        .v2-analyst-text {
            font-size: 0.75rem;
            color: var(--text-primary);
            line-height: 1.4;
            margin: 0;
            font-style: italic;
        }
        
        /* ==================== END V2 ANALYSIS METHODOLOGY STYLES ==================== */
        
        /* Compact Grid */
        .compact-grid { margin-bottom: 0.4rem; }
        .compact-row { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.4rem; margin-bottom: 0.3rem; align-items: center; }
        @media (max-width: 600px) { .compact-row { grid-template-columns: 1fr 1fr; } }
        .cg-label { font-size: 0.7rem; color: var(--text-muted); }
        .cg-value { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; font-weight: 600; color: var(--text-primary); }
        .cg-value.elite { color: var(--accent-green); }
        .cg-value.good { color: var(--accent-blue); }
        .cg-value.ok { color: var(--accent-yellow); }
        .cg-value.bad { color: var(--accent-red); }
        
        /* Threshold Bar */
        .threshold-bar { position: relative; height: 5px; background: var(--bg-input); border-radius: 2px; margin: 0.5rem 0 0.25rem; overflow: visible; }
        .threshold-fill { height: 100%; background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green)); border-radius: 2px; transition: width 0.3s; }
        .threshold-markers { position: absolute; top: 0; left: 0; right: 0; height: 100%; }
        .threshold-markers .marker { position: absolute; top: -12px; font-size: 0.5rem; color: var(--text-muted); transform: translateX(-50%); }
        .threshold-markers .marker.good { color: var(--accent-blue); }
        .threshold-markers .marker.great { color: var(--accent-green); }
        .threshold-label { font-size: 0.68rem; color: var(--text-muted); }
        .threshold-label span.elite { color: var(--accent-green); font-weight: 600; }
        .threshold-label span.good { color: var(--accent-blue); font-weight: 600; }
        .threshold-label span.ok { color: var(--accent-yellow); font-weight: 600; }
        .threshold-label span.bad { color: var(--accent-red); font-weight: 600; }
        
        /* Units Display */
        .units-display { display: flex; align-items: center; gap: 0.4rem; margin: 0.5rem 0; }
        .units-label { font-size: 0.75rem; color: var(--text-secondary); }
        .unit-chip { font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; font-weight: 600; padding: 0.25rem 0.5rem; background: var(--bg-input); border-radius: 6px; color: var(--text-secondary); }
        .unit-chip.selected { background: var(--accent-green-dim); color: var(--accent-green); border: 1px solid rgba(16, 185, 129, 0.3); }
        
        /* Signal Display */
        .signal-display { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; border-radius: 8px; margin-bottom: 0.4rem; }
        .signal-display.good { background: var(--accent-green-dim); border: 1px solid rgba(16, 185, 129, 0.2); }
        .signal-display.bad { background: var(--accent-red-dim); border: 1px solid rgba(239, 68, 68, 0.2); }
        .signal-display.neutral { background: var(--bg-input); border: 1px solid var(--border-color); }
        .signal-icon-lg { font-size: 1.1rem; }
        .signal-content { display: flex; flex-direction: column; gap: 0.05rem; }
        .signal-content strong { font-size: 0.8rem; color: var(--text-primary); }
        .signal-content span { font-size: 0.7rem; color: var(--text-secondary); }
        
        /* Pace Display */
        .pace-display { display: flex; align-items: center; gap: 0.4rem; padding: 0.4rem; background: var(--bg-input); border-radius: 6px; font-size: 0.75rem; color: var(--text-secondary); }
        .pace-display.extreme { background: var(--accent-yellow-dim); color: var(--accent-yellow); border: 1px solid rgba(245, 158, 11, 0.2); }
        .pace-icon { font-size: 0.9rem; }
        
        /* Script Compact */
        .script-compact { display: flex; flex-direction: column; gap: 0.25rem; }
        .script-item { display: flex; align-items: center; gap: 0.4rem; }
        .script-name { font-size: 0.68rem; color: var(--text-muted); min-width: 80px; }
        .script-bar-sm { flex: 1; height: 4px; background: var(--bg-input); border-radius: 2px; overflow: hidden; }
        .script-fill { height: 100%; border-radius: 2px; }
        .script-pct { font-family: 'JetBrains Mono', monospace; font-size: 0.68rem; color: var(--text-secondary); min-width: 26px; text-align: right; }
        
        /* Factors Compact */
        .factors-compact { display: flex; flex-wrap: wrap; gap: 0.35rem; }
        .factor-chip { font-size: 0.72rem; padding: 0.25rem 0.5rem; border-radius: 12px; background: var(--bg-input); color: var(--text-secondary); }
        .factor-chip.positive { background: var(--accent-green-dim); color: var(--accent-green); }
        .factor-chip.negative { background: var(--accent-red-dim); color: var(--accent-red); }
        .factor-chip.neutral { background: var(--bg-input); color: var(--text-muted); }
        
        /* Rankings Tab */
        .rankings-table-container { overflow-x: auto; border-radius: 12px; border: 1px solid var(--border-color); }
        .rankings-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        .rankings-table th { background: var(--bg-card); padding: 0.75rem 0.5rem; text-align: left; font-weight: 600; color: var(--text-secondary); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.03em; border-bottom: 2px solid var(--border-color); position: sticky; top: 0; }
        .rankings-table th.sortable { cursor: pointer; transition: color 0.2s; }
        .rankings-table th.sortable:hover { color: var(--accent-theme); }
        [data-theme="dark"] .rankings-table th.sortable:hover { color: var(--orange); }
        .rankings-table td { padding: 0.6rem 0.5rem; border-bottom: 1px solid var(--border-color); }
        .rankings-table td.positive { color: var(--accent-green); }
        .rankings-table td.negative { color: var(--accent-red); }
        .rankings-table tr:hover { background: var(--bg-card-hover); }
        .rankings-table tr.elite { background: linear-gradient(90deg, var(--accent-green-dim), transparent); }
        .rankings-table tr.contender { background: linear-gradient(90deg, var(--accent-blue-dim), transparent); }
        
        .rank-cell { font-family: 'JetBrains Mono', monospace; font-weight: 700; text-align: center; }
        .rank-cell.top-5 { color: var(--accent-green); }
        .rank-cell.top-15 { color: var(--accent-blue); }
        .rank-cell.top-40 { color: var(--accent-yellow); }
        
        .team-cell { display: flex; align-items: center; gap: 0.5rem; }
        .team-cell-name { font-weight: 600; color: var(--text-primary); }
        .team-cell-record { font-size: 0.7rem; color: var(--text-muted); }
        
        .conf-badge { font-size: 0.7rem; padding: 0.2rem 0.4rem; border-radius: 4px; background: var(--bg-input); color: var(--text-secondary); }
        .conf-badge.power { background: var(--accent-blue-dim); color: var(--accent-blue); }
        
        .score-cell { font-family: 'JetBrains Mono', monospace; font-weight: 700; }
        .score-cell.elite { color: var(--accent-green); }
        .score-cell.high { color: var(--accent-blue); }
        .score-cell.medium { color: var(--accent-yellow); }
        
        .rating-cell { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; }
        .rating-cell.positive { color: var(--accent-green); }
        .rating-cell.negative { color: var(--accent-red); }
        
        .ceiling-floor { font-size: 0.75rem; padding: 0.2rem 0.5rem; border-radius: 4px; }
        .ceiling-floor.champ { background: var(--accent-green-dim); color: var(--accent-green); }
        .ceiling-floor.ff { background: var(--accent-blue-dim); color: var(--accent-blue); }
        .ceiling-floor.e8 { background: rgba(139, 92, 246, 0.15); color: rgb(139, 92, 246); }
        .ceiling-floor.s16 { background: var(--accent-yellow-dim); color: var(--accent-yellow); }
        .ceiling-floor.r32 { background: var(--bg-input); color: var(--text-secondary); }
        .ceiling-floor.r64 { background: var(--bg-input); color: var(--text-muted); }
        .ceiling-floor.bubble { background: var(--accent-red-dim); color: var(--accent-red); }
        
        /* Top Teams Grid */
        .top-teams-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.75rem; }
        .team-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; transition: all 0.2s; }
        .team-card:hover { border-color: var(--accent-theme); transform: translateY(-2px); }
        .team-card.elite { border-left: 4px solid var(--accent-green); }
        .team-card.contender { border-left: 4px solid var(--accent-blue); }
        
        .team-card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem; }
        .team-card-rank { font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 800; }
        .team-card-rank.top-5 { color: var(--accent-green); }
        .team-card-rank.top-15 { color: var(--accent-blue); }
        .team-card-score { font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; font-weight: 700; padding: 0.25rem 0.5rem; border-radius: 6px; background: var(--bg-input); }
        .team-card-score.elite { background: var(--accent-green-dim); color: var(--accent-green); }
        
        .team-card-name { font-weight: 800; font-size: 1.05rem; color: var(--text-primary); margin-bottom: 0.3rem; letter-spacing: -0.01em; }
        .team-card-conf { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.75rem; }
        
        .team-card-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; }
        .team-card-stat { text-align: center; }
        .team-card-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; font-weight: 600; }
        .team-card-stat-value.positive { color: var(--accent-green); }
        .team-card-stat-value.negative { color: var(--accent-red); }
        .team-card-stat-label { font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; }
        
        .team-card-projection { margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; font-size: 0.75rem; }
        .projection-item { display: flex; flex-direction: column; align-items: center; gap: 0.15rem; }
        .projection-label { color: var(--text-muted); font-size: 0.65rem; }
        
        /* Conference Summary */
        .conference-summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .conf-summary-card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 1rem; text-align: center; }
        .conf-summary-value { font-family: 'JetBrains Mono', monospace; font-size: 1.5rem; font-weight: 700; color: var(--text-primary); }
        .conf-summary-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; margin-top: 0.25rem; }
        .conf-summary-card.highlight { border-color: var(--accent-theme); background: var(--orange-dim); }
        [data-theme="light"] .conf-summary-card.highlight { background: linear-gradient(135deg, rgba(30, 58, 95, 0.08), transparent); border-color: var(--navy); }

        /* =============================================================================
           MOBILE RESPONSIVE STYLES
           ============================================================================= */
        
        @media (max-width: 768px) {
            /* Base adjustments */
            .container {
                padding: 0.5rem;
            }
            
            /* Sticky nav wrapper mobile */
            .sticky-nav-wrapper {
                margin: -0.5rem -0.5rem 0 -0.5rem;
                padding: 0.5rem 0.5rem 0 0.5rem;
            }
            
            /* Header - Stack vertically */
            .header {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.75rem;
                border-radius: 10px;
                margin-bottom: 0.5rem;
            }
            
            .header-left {
                flex-direction: column;
                text-align: center;
                gap: 0.35rem;
            }
            
            .logo-img {
                width: 36px;
                height: 36px;
            }
            
            .logo-title {
                font-size: 1.1rem;
            }
            
            .logo-tagline {
                font-size: 0.55rem;
            }
            
            .header-right {
                width: 100%;
                justify-content: center;
                gap: 0.4rem;
            }
            
            .header-status {
                display: none;
            }
            
            /* Hamburger menu mobile */
            .hamburger-btn {
                width: 38px;
                height: 38px;
            }
            
            .hamburger-dropdown {
                right: -0.5rem;
                min-width: 180px;
            }
            
            /* Settings Panel */
            .settings-panel .settings-content {
                grid-template-columns: 1fr;
                padding: 0.75rem;
            }
            
            .settings-input {
                font-size: 16px; /* Prevents iOS zoom on focus */
            }
            
            .btn-refresh {
                width: 100%;
                justify-content: center;
            }
            
            /* Navigation Tabs - Scrollable */
            .tabs-container {
                padding: 0.2rem;
                gap: 0.15rem;
                margin-bottom: 0.5rem;
                border-radius: 8px;
                -webkit-overflow-scrolling: touch;
            }
            
            .tab {
                padding: 0.5rem 0.75rem;
                font-size: 0.75rem;
                min-width: max-content;
                flex-shrink: 0;
            }
            
            /* Ensure active tab is always visible on mobile */
            .tab.active {
                background: var(--navy);
                color: white;
            }
            
            [data-theme="dark"] .tab.active {
                background: var(--orange);
                color: white;
            }
            
            /* Section Header & Filters */
            .section-header {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .section-title {
                font-size: 0.95rem;
                text-align: center;
            }
            
            .filter-pills {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.35rem;
            }
            
            .filter-select {
                flex: 1;
                min-width: 120px;
                padding: 0.4rem 0.6rem;
                font-size: 16px; /* Prevents iOS zoom */
            }
            
            /* Team Search Mobile */
            .team-search-container {
                flex: 1;
                min-width: 100px;
                max-width: none;
            }
            
            .team-search-input {
                padding: 0.35rem 0.5rem;
                font-size: 0.75rem;
            }
            
            .team-search-dropdown {
                max-height: 180px;
            }
            
            .filter-pill {
                padding: 0.4rem 0.6rem;
                font-size: 0.7rem;
            }
            
            /* Picks Summary Widget */
            .picks-summary-widget {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.25rem;
                padding: 0.35rem;
                margin-bottom: 0.5rem;
            }
            
            .picks-summary-card {
                padding: 0.3rem;
            }
            
            .picks-summary-count {
                font-size: 1rem;
            }
            
            .picks-summary-label {
                font-size: 0.5rem;
            }
            
            .picks-summary-range {
                display: none;
            }
            
            .picks-summary-winrate {
                font-size: 0.5rem;
                padding: 0.08rem 0.25rem;
            }
            
            /* Game Cards - Condensed */
            .games-grid {
                gap: 0.4rem;
            }
            
            .game-card {
                border-radius: 8px;
            }
            
            /* Compact header - teams on one row */
            .game-header-row {
                display: flex;
                flex-wrap: wrap;
                justify-content: space-between;
                align-items: center;
                gap: 0.2rem;
                padding: 0.5rem 0.6rem;
            }
            
            .team-col {
                flex: 1;
                min-width: 0;
            }
            
            .team-col.away {
                text-align: left !important;
            }
            
            .team-col.home {
                text-align: right !important;
            }
            
            .team-col .team-name {
                font-size: 0.75rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .team-col .team-meta {
                font-size: 0.55rem;
            }
            
            .team-col .team-rating {
                font-size: 0.65rem;
            }
            
            .game-info-col {
                order: 0;
                flex: 0 0 auto;
                padding: 0;
                border: none;
                margin: 0;
                min-width: 65px;
            }
            
            .game-datetime {
                font-size: 0.55rem;
            }
            
            .game-line {
                font-size: 0.65rem;
                padding: 0.15rem 0.35rem;
            }
            
            /* Picks Row - Side by side on mobile */
            .picks-row {
                grid-template-columns: 1fr 1fr;
                gap: 0.3rem;
                padding: 0.4rem 0.6rem 0.6rem;
            }
            
            .pick-col {
                padding: 0.5rem;
                border-radius: 6px;
                min-height: 90px;
            }
            
            .pick-header-row {
                margin-bottom: 0.2rem;
            }
            
            .pick-type-label {
                font-size: 0.5rem;
            }
            
            .pick-confidence {
                width: 20px;
                height: 20px;
                font-size: 0.6rem;
            }
            
            .pick-main {
                margin-bottom: 0.3rem;
                gap: 0.2rem;
            }
            
            .pick-icon {
                font-size: 0.75rem;
            }
            
            .pick-team-name {
                font-size: 0.7rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 65px;
            }
            
            .pick-line-value {
                font-size: 0.7rem;
            }
            
            .pick-metrics {
                gap: 0.15rem;
                margin-bottom: 0.3rem;
            }
            
            .pick-metric {
                padding: 0.15rem;
            }
            
            .pm-value {
                font-size: 0.65rem;
            }
            
            .pm-label {
                font-size: 0.45rem;
            }
            
            /* Smaller Track button */
            .btn-track, .btn.btn-track {
                padding: 0.35rem;
                font-size: 0.65rem;
                min-height: 28px;
            }
            
            /* No pick message */
            .no-pick-msg {
                padding: 0.75rem 0.35rem;
                font-size: 0.7rem;
                min-height: 60px;
            }
            
            .no-pick-msg span:first-child {
                font-size: 1rem;
            }
            
            /* Analytics Toggle - More compact */
            .analytics-toggle {
                padding: 0.4rem;
                font-size: 0.65rem;
                margin: 0 0.6rem 0.4rem;
            }
            
            /* Drill Down Content */
            .drill-down-content {
                margin: 0 0.6rem 0.5rem;
                padding: 0.6rem;
            }
            
            .section-header-large > span:nth-child(2) {
                font-size: 0.8rem;
            }
            
            .compact-row {
                grid-template-columns: 1fr 1fr;
                gap: 0.25rem;
            }
            
            .cg-value {
                font-size: 0.75rem;
            }
            
            .cg-label {
                font-size: 0.6rem;
            }
            
            /* Tracker Stats */
            .tracker-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.4rem;
            }
            
            .tracker-stat-card {
                padding: 0.6rem;
            }
            
            .tracker-stat-value {
                font-size: 1.15rem;
            }
            
            /* Validation */
            .validation-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.4rem;
            }
            
            .validation-card {
                padding: 0.6rem;
            }
            
            .validation-log {
                gap: 0.4rem;
            }
            
            .validation-item {
                padding: 0.6rem;
                flex-direction: column;
                align-items: flex-start;
                gap: 0.4rem;
            }
            
            .validation-result {
                width: 100%;
                justify-content: space-between;
            }
            
            /* Rankings Table */
            .rankings-table {
                font-size: 0.7rem;
            }
            
            .rankings-table th,
            .rankings-table td {
                padding: 0.4rem 0.25rem;
            }
            
            /* Hide less important columns on mobile */
            .rankings-table th:nth-child(6),
            .rankings-table td:nth-child(6),
            .rankings-table th:nth-child(7),
            .rankings-table td:nth-child(7),
            .rankings-table th:nth-child(8),
            .rankings-table td:nth-child(8) {
                display: none;
            }
            
            /* Info Cards */
            .info-card {
                padding: 0.75rem;
                margin-bottom: 0.5rem;
            }
            
            .info-card h3 {
                font-size: 0.9rem;
            }
            
            .info-card p {
                font-size: 0.8rem;
            }
            
            /* Alerts */
            .alert {
                padding: 0.5rem;
                font-size: 0.75rem;
                margin-bottom: 0.5rem;
            }
            
            /* Empty States */
            .empty-state {
                padding: 1.5rem 0.75rem;
            }
            
            .empty-icon {
                font-size: 2rem;
            }
            
            .empty-title {
                font-size: 0.9rem;
            }
            
            /* Footer */
            .footer {
                padding: 0.75rem;
                font-size: 0.7rem;
            }
            
            /* Best Bets Tab */
            .best-bet-card {
                padding: 0.75rem;
            }
        }
        
        /* Extra small devices (phones in portrait) */
        @media (max-width: 375px) {
            .container {
                padding: 0.25rem;
            }
            
            .header {
                padding: 0.5rem;
            }
            
            .logo-title {
                font-size: 0.95rem;
            }
            
            .tab {
                padding: 0.35rem 0.5rem;
                font-size: 0.65rem;
            }
            
            /* Ensure active tab visible on small screens */
            .tab.active {
                background: var(--navy);
                color: white;
            }
            
            [data-theme="dark"] .tab.active {
                background: var(--orange);
                color: white;
            }
            
            .picks-summary-widget {
                gap: 0.2rem;
                padding: 0.25rem;
            }
            
            .picks-summary-card {
                padding: 0.25rem;
            }
            
            .picks-summary-count {
                font-size: 0.85rem;
            }
            
            .picks-summary-label {
                font-size: 0.45rem;
            }
            
            /* Game cards even more compact */
            .game-header-row {
                padding: 0.45rem 0.5rem;
            }
            
            .team-col .team-name {
                font-size: 0.75rem;
                font-weight: 800;
            }
            
            .team-col .team-meta {
                font-size: 0.5rem;
            }
            
            .team-col .team-rating {
                font-size: 0.6rem;
            }
            
            .game-info-col {
                min-width: 60px;
            }
            
            .game-datetime {
                font-size: 0.55rem;
            }
            
            .game-line {
                font-size: 0.6rem;
                padding: 0.15rem 0.3rem;
            }
            
            .picks-row {
                padding: 0.4rem 0.5rem 0.5rem;
                gap: 0.4rem;
            }
            
            .pick-col {
                padding: 0.4rem;
                min-height: 70px;
            }
            
            .pick-type-label {
                font-size: 0.5rem;
            }
            
            .pick-confidence {
                width: 18px;
                height: 18px;
                font-size: 0.55rem;
            }
            
            .pick-team-name {
                font-size: 0.7rem;
                font-weight: 800;
                max-width: 55px;
            }
            
            .pick-line-value {
                font-size: 0.7rem;
            }
            
            .pick-icon {
                font-size: 0.7rem;
            }
            
            .pick-metrics {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.1rem;
            }
            
            .pick-metric {
                padding: 0.1rem;
            }
            
            .pm-value {
                font-size: 0.55rem;
            }
            
            .pm-label {
                font-size: 0.4rem;
            }
            
            .btn-track {
                padding: 0.25rem;
                font-size: 0.55rem;
                min-height: 24px;
            }
            
            .analytics-toggle {
                padding: 0.3rem;
                font-size: 0.55rem;
                margin: 0 0.4rem 0.3rem;
            }
        }
        
        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            /* Larger touch targets - but respect mobile compact sizes */
            .filter-pill,
            .tab,
            .btn,
            .analytics-toggle {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Track button can be smaller on mobile for compact view */
            .btn-track {
                min-height: 32px;
            }
            
            /* Remove hover effects that don't work well on touch */
            .game-card:hover {
                transform: none;
                box-shadow: var(--shadow-card);
            }
            
            .filter-pill:hover,
            .tab:hover {
                background: transparent;
                color: var(--text-muted);
            }
            
            /* Ensure active states are always visible on touch */
            .tab.active {
                background: var(--navy) !important;
                color: white !important;
            }
            
            [data-theme="dark"] .tab.active {
                background: var(--orange) !important;
                color: white !important;
            }
            
            .filter-pill.active {
                background: var(--navy) !important;
                color: white !important;
            }
            
            [data-theme="dark"] .filter-pill.active {
                background: var(--orange) !important;
                color: white !important;
            }
        }
        
        /* Landscape phone optimization */
        @media (max-width: 768px) and (orientation: landscape) {
            .header {
                flex-direction: row;
                padding: 0.75rem 1rem;
            }
            
            .header-left {
                flex-direction: row;
            }
            
            .picks-summary-widget {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .game-header-row {
                grid-template-columns: 1fr auto 1fr;
            }
            
            .game-info-col {
                order: 0;
                padding-bottom: 0;
                border-bottom: none;
                margin-bottom: 0;
            }
            
            .team-col.away { text-align: left !important; }
            .team-col.home { text-align: right !important; }
            
            .picks-row {
                grid-template-columns: 1fr 1fr;
            }
        }

        /* ========== VALIDATION TAB REDESIGN ========== */
        .val-hero {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
            border: 2px solid var(--conf-bestbet);
            border-radius: 14px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }
        .val-hero-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        .val-hero-title {
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--conf-bestbet);
        }
        .val-hero-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        .val-hero-stats {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.75rem;
        }
        .val-hero-stat {
            text-align: center;
            background: var(--bg-input);
            padding: 0.75rem 0.5rem;
            border-radius: 10px;
        }
        .val-hero-stat.primary {
            background: var(--orange-dim);
        }
        .val-hero-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 800;
            white-space: nowrap;
        }
        .val-hero-stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }
        .val-hero-split {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .val-hero-split-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }
        .val-hero-split-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .val-section {
            margin-bottom: 1rem;
        }
        .val-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }
        .val-section-title {
            font-weight: 700;
            font-size: 0.95rem;
        }
        .val-section-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .val-rating-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }
        .val-rating-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 0.75rem 0.5rem;
            text-align: center;
            transition: border-color 0.15s;
            min-width: 0;
            overflow: hidden;
        }
        .val-rating-card.has-data {
            border-left: 3px solid var(--conf-bestbet);
        }
        .val-rating-card-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .val-rating-card-balls {
            margin: 0.35rem 0;
            min-height: 16px;
        }
        .val-rating-card-record {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 800;
            margin: 0.25rem 0;
        }
        .val-rating-card-stats {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            font-size: 0.7rem;
        }
        .val-rating-card-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .val-rating-card-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 0.75rem;
            white-space: nowrap;
        }
        .val-rating-card-stat-label {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        .val-rating-card-range {
            font-size: 0.55rem;
            color: var(--text-muted);
            margin-top: 0.35rem;
            white-space: nowrap;
        }

        .val-all-picks-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: 1rem;
        }
        .val-all-picks-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            list-style: none;
        }
        .val-all-picks-toggle::-webkit-details-marker { display: none; }
        .val-all-picks-toggle::before {
            content: '';
            font-size: 0.6rem;
            margin-right: 0.5rem;
            transition: transform 0.2s;
        }
        details[open] > .val-all-picks-toggle::before {
            transform: rotate(90deg);
        }
        .val-all-picks-record {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 0.85rem;
        }
        .val-all-picks-content {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border-color);
        }
        .val-all-picks-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .val-all-stat {
            text-align: center;
            background: var(--bg-input);
            padding: 0.5rem;
            border-radius: 6px;
        }
        .val-all-stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
            font-size: 0.85rem;
        }
        .val-all-stat-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        .val-all-picks-breakdown {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        .val-all-breakdown-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-input);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
        }
        .val-all-breakdown-label {
            font-weight: 600;
            color: var(--text-secondary);
        }
        .val-all-breakdown-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 700;
        }

        .val-picks-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .val-picks-toggle {
            display: flex;
            background: var(--bg-input);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        .val-pick-filter {
            padding: 0.35rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.15s;
        }
        .val-pick-filter.active {
            background: var(--orange);
            color: white;
        }
        .val-pick-filter:hover:not(.active) {
            background: var(--bg-secondary);
        }
        .val-picks-count {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        @media (max-width: 768px) {
            .val-hero-stats { grid-template-columns: repeat(3, 1fr); }
            .val-rating-grid { grid-template-columns: repeat(3, 1fr); }
            .val-all-picks-grid { grid-template-columns: repeat(3, 1fr); }
            .val-all-picks-breakdown { grid-template-columns: 1fr; }
        }
        @media (max-width: 480px) {
            .val-hero-stats { grid-template-columns: repeat(2, 1fr); }
            .val-rating-grid { grid-template-columns: repeat(2, 1fr); }
            .val-all-picks-grid { grid-template-columns: repeat(2, 1fr); }
        }

        /* ========== ADVANCED VALIDATION PANEL ========== */
        .adv-validation-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .adv-validation-toggle {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.875rem 1rem;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            transition: background 0.15s;
        }

        .adv-validation-toggle:hover {
            background: var(--bg-secondary);
        }

        .adv-validation-toggle:focus {
            outline: none;
            background: var(--bg-secondary);
        }

        .adv-validation-toggle:focus-visible {
            box-shadow: inset 0 0 0 2px var(--orange);
        }

        .adv-validation-toggle-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .adv-validation-toggle-icon {
            transition: transform 0.2s;
        }

        .adv-validation-panel.expanded .adv-validation-toggle-icon {
            transform: rotate(90deg);
        }

        .adv-validation-badge {
            font-size: 0.7rem;
            font-weight: 700;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            background: var(--orange-dim);
            color: var(--orange);
        }

        .adv-validation-content {
            display: none;
            padding: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .adv-validation-panel.expanded .adv-validation-content {
            display: block;
        }

        .adv-val-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .adv-val-card {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 0.75rem 0.5rem;
            text-align: center;
            min-width: 0;
            overflow: hidden;
        }

        .adv-val-card-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.35rem;
            white-space: nowrap;
        }

        .adv-val-card-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .adv-val-card-value.good { color: var(--accent-green); }
        .adv-val-card-value.warning { color: var(--accent-yellow); }
        .adv-val-card-value.bad { color: var(--accent-red); }

        .adv-val-card-subtitle {
            font-size: 0.6rem;
            color: var(--text-secondary);
            margin-top: 0.2rem;
            line-height: 1.3;
        }

        .adv-val-section {
            margin-top: 1.25rem;
        }

        .adv-val-section-title {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .calibration-chart {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 0.75rem;
            position: relative;
        }

        .calibration-chart svg {
            width: 100%;
            height: auto;
            display: block;
        }

        .calibration-line-perfect {
            stroke: var(--text-muted);
            stroke-width: 1;
            stroke-dasharray: 4,4;
            fill: none;
        }

        .calibration-line-model {
            stroke: var(--orange);
            stroke-width: 2.5;
            fill: none;
        }

        .calibration-dot {
            fill: var(--orange);
        }

        .calibration-ci {
            fill: var(--orange);
            opacity: 0.15;
        }

        .baseline-comparison {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
        }

        .baseline-card {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            min-width: 0;
        }

        .baseline-card-header {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 0.4rem;
        }

        .baseline-card-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            padding: 0.2rem 0;
        }

        .baseline-card-label {
            color: var(--text-secondary);
        }

        .baseline-card-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }

        .baseline-card-value.better { color: var(--accent-green); }
        .baseline-card-value.worse { color: var(--accent-red); }
        .baseline-card-value.same { color: var(--text-muted); }

        .adv-val-note {
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: var(--bg-input);
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 1rem;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .adv-val-note-icon {
            flex-shrink: 0;
        }

        .adv-val-awaiting {
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
        }

        .adv-val-awaiting-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        /* Data Integrity Notice */
        .data-integrity-notice {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-card) 100%);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1.25rem;
        }

        .data-integrity-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .data-integrity-icon {
            font-size: 1.25rem;
        }

        .data-integrity-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .data-integrity-status {
            margin-left: auto;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .data-integrity-status.healthy {
            background: var(--accent-green-dim);
            color: var(--accent-green);
        }

        .data-integrity-status.warning {
            background: var(--accent-yellow-dim);
            color: var(--accent-yellow);
        }

        .data-integrity-status.concern {
            background: var(--accent-red-dim);
            color: var(--accent-red);
        }

        .data-integrity-checks {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.5rem;
        }

        .integrity-check {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 6px;
        }

        .integrity-check-icon {
            font-size: 0.9rem;
        }

        .integrity-check-icon.pass { color: var(--accent-green); }
        .integrity-check-icon.fail { color: var(--accent-red); }
        .integrity-check-icon.warn { color: var(--accent-yellow); }

        .integrity-check-label {
            color: var(--text-secondary);
            flex: 1;
        }

        .integrity-check-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.7rem;
        }

        .ci-tooltip {
            font-size: 0.7rem;
            color: var(--text-muted);
            cursor: help;
            border-bottom: 1px dotted var(--text-muted);
        }

        /* Residuals Plot Styling */
        .residuals-chart {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 0.75rem;
            position: relative;
        }

        .residuals-chart svg {
            width: 100%;
            height: auto;
            display: block;
        }

        .residuals-zero-line {
            stroke: var(--text-muted);
            stroke-width: 1;
            stroke-dasharray: 4,4;
        }

        .residuals-dot {
            fill: var(--orange);
            opacity: 0.6;
            transition: opacity 0.15s, r 0.15s;
        }

        .residuals-dot:hover {
            opacity: 1;
            r: 6;
        }

        .residuals-dot.positive {
            fill: var(--accent-green);
        }

        .residuals-dot.negative {
            fill: var(--accent-red);
        }

        .residuals-band {
            fill: var(--accent-blue);
            opacity: 0.08;
        }

        .residuals-trend {
            stroke: var(--navy);
            stroke-width: 1.5;
            stroke-dasharray: 2,2;
            fill: none;
            opacity: 0.6;
        }

        [data-theme="dark"] .residuals-trend {
            stroke: var(--orange);
        }

        .residuals-summary {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.75rem 1.25rem;
            margin-top: 0.5rem;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .residuals-summary-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            white-space: nowrap;
        }

        .residuals-summary-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .residuals-summary-dot.positive { background: var(--accent-green); }
        .residuals-summary-dot.negative { background: var(--accent-red); }
        .residuals-summary-dot.neutral { background: var(--text-muted); }

        @media (max-width: 640px) {
            .adv-val-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
            .adv-val-card-value { font-size: 1.1rem; }
            .adv-val-card-title { font-size: 0.6rem; }

            .calibration-chart {
                padding: 0.5rem;
            }

            .residuals-chart {
                padding: 0.5rem;
            }

            .residuals-summary {
                gap: 0.5rem 0.75rem;
            }
            .baseline-comparison {
                grid-template-columns: 1fr;
            }
        }

        /* Share Top 10 container - must be hidden by default (critical inline CSS) */
        .share-top10-container {
            display: none !important;
            position: fixed;
            top: -9999px;
            left: -9999px;
            z-index: -1;
            visibility: hidden;
        }
        .share-top10-container.share-mode {
            display: block !important;
            position: relative;
            top: 0;
            left: 0;
            z-index: 10000;
            visibility: visible;
        }

        /* ========== SCREENSHOT-MATCHING TOP 10 STYLES ========== */

        /* Container */
        .ss-container {
            background: #f5f5f5;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            color: #1e3a5f;
            padding: 28px 36px 24px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        .ss-desktop {
            width: 1000px;
            min-height: 980px;
        }
        .ss-mobile {
            width: 540px;
            min-height: 1500px;
        }

        /* Watermark */
        .ss-watermark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.04;
            pointer-events: none;
            z-index: 0;
        }
        .ss-watermark-img {
            width: 350px;
            height: auto;
            display: block;
        }
        .ss-mobile .ss-watermark-img {
            width: 250px;
        }

        /* Header */
        .ss-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
            position: relative;
            z-index: 1;
        }
        .ss-header-left {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 16px;
        }
        .ss-header-badge {
            height: 75px;
            width: auto;
            display: block;
        }
        .ss-header-titles {
            display: flex;
            flex-direction: column;
        }
        .ss-title {
            font-family: 'Playfair Display', Georgia, serif;
            font-size: 42px;
            font-weight: 700;
            color: #1e3a5f;
            margin: 0;
            line-height: 1;
            font-style: italic;
            white-space: nowrap;
        }
        .ss-subtitle {
            font-size: 13px;
            color: #64748b;
            margin: 8px 0 0;
            white-space: nowrap;
        }
        .ss-header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }
        .ss-date-badge {
            background: #1e3a5f;
            color: #fff;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
        }

        /* Stats Bar */
        .ss-stats-bar {
            background: linear-gradient(135deg, #1e3a5f 0%, #2a4a70 100%);
            border-radius: 12px;
            padding: 16px 0;
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin-bottom: 18px;
            border: 2px solid #ff8c42;
            position: relative;
            z-index: 1;
        }
        .ss-stat {
            text-align: center;
            flex: 1;
        }
        .ss-stat-value {
            font-size: 26px;
            font-weight: 700;
            color: #fff;
            display: block;
        }
        .ss-stat-value.highlight {
            color: #ff8c42;
        }
        .ss-stat-value.positive {
            color: #22c55e;
        }
        .ss-stat-label {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
            display: block;
        }

        /* Cards Grid */
        .ss-cards-grid {
            display: grid;
            gap: 12px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }
        .ss-desktop .ss-cards-grid {
            grid-template-columns: repeat(2, 1fr);
        }
        .ss-mobile .ss-cards-grid {
            grid-template-columns: 1fr;
        }

        /* Card */
        .ss-card {
            background: #fff;
            border-radius: 12px;
            display: flex;
            align-items: stretch;
            box-shadow: 0 2px 10px rgba(30, 58, 95, 0.1);
            overflow: hidden;
            min-height: 125px;
            border-left: 5px solid #1e3a5f;
        }
        .ss-card[data-tier="elite"] {
            border-left-color: #ff8c42;
        }

        .ss-card-rank {
            width: 48px;
            min-width: 48px;
            background: #1e3a5f;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 20px;
        }

        .ss-card-content {
            flex: 1;
            padding: 14px 18px 12px 16px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .ss-card-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 16px;
        }

        .ss-card-left {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .ss-card-right {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-width: 80px;
            text-align: center;
        }

        .ss-pick-label {
            font-weight: 700;
            font-size: 17px;
            color: #1e3a5f;
            line-height: 1.2;
        }
        .ss-pick-line {
            color: #ff8c42;
            font-weight: 700;
        }

        .ss-tier-badge {
            font-size: 9px;
            font-weight: 700;
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            text-transform: uppercase;
            background: #1e3a5f;
            margin-bottom: 6px;
            white-space: nowrap;
            letter-spacing: 0.3px;
        }
        .ss-tier-badge.bestbet {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);
        }
        .ss-tier-badge.elite {
            background: #ff8c42;
        }
        .ss-tier-badge.strong {
            background: #1e3a5f;
        }
        .ss-tier-badge.value {
            background: #94a3b8;
        }

        .ss-rating {
            font-size: 14px;
            text-align: center;
            margin-bottom: 4px;
            letter-spacing: -1px;
        }

        .ss-win-prob {
            font-size: 22px;
            font-weight: 700;
            color: #1e3a5f;
            text-align: center;
            line-height: 1;
        }
        .ss-win-prob.bestbet {
            color: #f59e0b;
        }
        .ss-win-prob.elite {
            color: #ff8c42;
        }
        .ss-win-prob-label {
            font-size: 9px;
            color: #94a3b8;
            text-transform: uppercase;
            text-align: center;
            margin-top: 3px;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .ss-matchup {
            font-size: 12px;
            color: #64748b;
            line-height: 1.3;
        }

        .ss-game-time {
            font-size: 12px;
            color: #1e3a5f;
            font-weight: 600;
        }

        .ss-emoji-reason {
            font-size: 12px;
            color: #1e3a5f;
            font-weight: 500;
        }

        .ss-card-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #f0f0f0;
        }

        .ss-model-text {
            font-size: 11px;
            color: #64748b;
            flex: 1;
        }

        .ss-rating-display {
            display: flex;
            gap: 1px;
            align-items: center;
            margin-left: 10px;
            flex-shrink: 0;
        }

        .ss-rating-display svg {
            display: inline-block;
            vertical-align: middle;
        }

        /* Rating Legend */
        .ss-rating-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px 16px;
            padding: 12px 16px;
            margin-top: 16px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(255, 140, 66, 0.05));
            border-radius: 8px;
            border: 1px solid rgba(245, 158, 11, 0.2);
        }
        .ss-legend-title {
            width: 100%;
            text-align: center;
            font-size: 10px;
            font-weight: 700;
            color: #f59e0b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .ss-legend-item {
            font-size: 10px;
            color: #64748b;
        }

        /* Footer */
        .ss-footer {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            position: relative;
            z-index: 1;
        }
        .ss-footer-left {
            flex: 1;
        }
        .ss-footer-center {
            flex: 1;
            display: flex;
            justify-content: center;
        }
        .ss-footer-right {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        .ss-footer-icon {
            height: 44px;
            width: auto;
            display: block;
        }
        .ss-tagline {
            font-size: 11px;
            color: #1e3a5f;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .ss-disclaimer {
            font-size: 9px;
            color: #94a3b8;
            line-height: 1.4;
            text-align: left;
        }

        /* Mobile adjustments */
        .ss-mobile .ss-header {
            flex-direction: column;
            gap: 12px;
        }
        .ss-mobile .ss-stats-bar {
            flex-wrap: wrap;
            padding: 12px;
        }
        .ss-mobile .ss-stat {
            min-width: 45%;
            margin-bottom: 8px;
        }
        .ss-mobile .ss-footer {
            flex-direction: column;
            gap: 12px;
            text-align: center;
        }
        .ss-mobile .ss-disclaimer {
            text-align: center;
        }

        /* Keep old classes for backwards compatibility but hide them */
        .share-premium .share-card-header {
            display: flex;
            align-items: baseline;
            gap: 10px;
            margin-bottom: 4px;
        }
        .share-premium .share-team {
            font-weight: 700;
            font-size: 15px;
            color: var(--premium-text);
            letter-spacing: -0.2px;
        }
        .share-premium .share-line {
            font-weight: 600;
            font-size: 15px;
            color: var(--premium-platinum);
            font-family: 'JetBrains Mono', monospace;
        }
        .share-premium .share-matchup {
            font-size: 11px;
            color: var(--premium-text-dim);
            margin-bottom: 6px;
        }
        .share-reason-premium {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .share-reason-emojis {
            font-size: 12px;
            letter-spacing: 2px;
        }
        .share-reason-text {
            font-size: 10px;
            color: var(--premium-gold);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .share-premium .share-card-right {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 18px;
            background: linear-gradient(135deg, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.1) 100%);
            min-width: 90px;
            border-left: 1px solid var(--premium-border);
        }
        .share-premium .share-prob {
            font-size: 22px;
            font-weight: 700;
            color: var(--prob-color);
            font-family: 'JetBrains Mono', monospace;
            text-shadow: 0 0 20px color-mix(in srgb, var(--prob-color) 30%, transparent);
        }
        .share-premium .share-prob-label {
            font-size: 7px;
            color: var(--premium-text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 2px;
        }

        /* Premium Footer */
        .share-footer-premium {
            margin-top: 14px;
            position: relative;
            z-index: 1;
        }
        .share-footer-accent {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--premium-gold), transparent);
            margin-bottom: 12px;
            box-shadow: 0 0 10px var(--premium-gold-dim);
        }
        .share-footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .share-footer-left-premium {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .share-footer-logo-premium {
            height: 28px;
            width: auto;
            opacity: 0.9;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }
        .share-tagline-premium {
            font-size: 12px;
            color: var(--premium-gold);
            font-style: italic;
            font-weight: 500;
        }
        .share-footer-right-premium {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .share-footer-badge-premium {
            height: 32px;
            width: auto;
            opacity: 0.7;
        }
        .share-disclaimer-premium {
            font-size: 9px;
            color: var(--premium-text-dim);
            text-align: right;
            letter-spacing: 0.3px;
        }

        /* Mobile adjustments for premium */
        .share-top10--mobile.share-premium .share-header-content {
            flex-direction: column;
            gap: 16px;
            align-items: flex-start;
        }
        .share-top10--mobile.share-premium .share-stats-bar-premium {
            flex-wrap: wrap;
            padding: 14px 18px;
            gap: 12px;
        }
        .share-top10--mobile.share-premium .share-stat-premium {
            min-width: 70px;
        }
        .share-top10--mobile.share-premium .share-stat-divider-premium {
            display: none;
        }
        .share-top10--mobile.share-premium .share-top10-card {
            min-height: 82px;
        }
        .share-top10--mobile.share-premium .share-footer-content {
            flex-direction: column;
            gap: 12px;
            text-align: center;
        }
        .share-top10--mobile.share-premium .share-footer-left-premium,
        .share-top10--mobile.share-premium .share-footer-right-premium {
            justify-content: center;
        }

        /* Metrics bar collapsed state */
        .metrics-bar.collapsed {
            max-height: 0 !important;
            opacity: 0 !important;
            padding: 0 !important;
            border: none !important;
            overflow: hidden !important;
            visibility: hidden !important;
        }
        
        /* Cloud Sync Styles */
        .cloud-sync-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
        }
        .cloud-sync-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-primary);
        }
        .cloud-sync-btn:hover {
            border-color: var(--orange);
            background: var(--bg-card-hover);
        }
        .cloud-sync-btn.google {
            background: #4285f4;
            color: white;
            border-color: #4285f4;
        }
        .cloud-sync-btn.google:hover {
            background: #3367d6;
            border-color: #3367d6;
        }
        .cloud-sync-btn.synced {
            background: linear-gradient(135deg, #34a853 0%, #2d9248 100%);
            color: white;
            border-color: #34a853;
        }
        .cloud-sync-btn.synced:hover {
            background: linear-gradient(135deg, #2d9248 0%, #267a3d 100%);
        }
        .cloud-sync-status {
            font-size: 0.7rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .cloud-sync-status.connected {
            color: #34a853;
        }
        .sync-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 0.5rem;
        }
        /* ========== UI OVERHAUL  REMAINING IMPROVEMENTS ========== */

        /* === Tab Switching Crossfade (2C) === */
        .tab-content {
            animation: tabFadeIn 0.2s ease;
        }
        @keyframes tabFadeIn {
            from { opacity: 0; }
            to   { opacity: 1; }
        }

        /* === Games At-A-Glance Summary (3B) === */
        .games-summary-bar {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .games-summary-chip {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.78rem;
            color: var(--text-secondary);
        }
        .games-summary-chip strong {
            font-family: 'JetBrains Mono', monospace;
            font-variant-numeric: tabular-nums;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        .games-summary-chip.highlight {
            background: var(--orange-dim);
            border-color: var(--orange);
        }
        .games-summary-chip.highlight strong {
            color: var(--orange);
        }

        /* === Time Group Headers (3D) === */
        .time-group-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            margin-top: 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
        }
        .time-group-header::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }
        .time-group-header:first-child { margin-top: 0; }

        /* === Best Bets Quick Stats (4B) === */
        .bb-quick-stats {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }
        .bb-quick-stat {
            font-size: 0.78rem;
            color: var(--text-secondary);
            padding: 0.35rem 0.65rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        .bb-quick-stat strong {
            font-family: 'JetBrains Mono', monospace;
            font-variant-numeric: tabular-nums;
            color: var(--text-primary);
        }

        /* === Best Bets Win Prob Larger (7/4C) === */
        .bb-pick-confidence-value {
            font-size: 1.5rem !important;
            font-weight: 700 !important;
            font-family: 'JetBrains Mono', monospace !important;
            font-variant-numeric: tabular-nums;
            line-height: 1;
        }

        /* === Track/Lock Button (4D) === */
        .bb-track-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            font-weight: 600;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .bb-track-btn:hover {
            background: var(--orange-dim);
            border-color: var(--orange);
            color: var(--orange);
        }
        .bb-track-btn.tracked {
            background: var(--accent-green-dim);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }
        .bb-track-btn.tracked:hover {
            background: var(--accent-red-dim);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        .bb-track-btn.tracked .track-label { display: inline; }
        .bb-track-btn.tracked .untrack-label { display: none; }
        .bb-track-btn.tracked:hover .track-label { display: none; }
        .bb-track-btn.tracked:hover .untrack-label { display: inline; }

        /* Game card track buttons - pinned to bottom */
        .game-track-btn {
            margin-top: auto;
            width: 100%;
            justify-content: center;
            font-size: 0.65rem !important;
            padding: 0.2rem 0.4rem !important;
            min-height: 28px;
        }

        /* ========== TRACKED BETS TAB ========== */
        .tracked-bets-page {
            max-width: 900px;
            margin: 0 auto;
        }
        .tracked-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            gap: 1rem;
        }
        .tracked-header h2 {
            font-family: 'Playfair Display', Georgia, serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }
        .tracked-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.15rem;
        }
        .tracked-header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        /* ---- 7-Day Strip ---- */
        .tracked-day-strip {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            margin-bottom: 1rem;
        }
        .tracked-day-arrow {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            flex-shrink: 0;
            min-height: 36px;
        }
        .tracked-day-arrow:hover {
            background: var(--orange-dim);
            border-color: var(--orange);
            color: var(--orange);
        }
        .tracked-day-arrow:disabled {
            opacity: 0.3;
            pointer-events: none;
        }
        .tracked-day-cards {
            display: flex;
            gap: 0.35rem;
            flex: 1;
            overflow: hidden;
        }
        .tracked-day-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.45rem 0.25rem;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            background: var(--bg-card);
            cursor: pointer;
            transition: all 0.15s;
            min-width: 0;
            min-height: 36px;
            position: relative;
        }
        .tracked-day-card:hover {
            border-color: var(--orange);
            background: var(--orange-dim);
        }
        .tracked-day-card.active {
            border-color: var(--orange);
            background: var(--orange-dim);
            box-shadow: 0 2px 8px rgba(255, 140, 66, 0.2);
        }
        .tracked-day-card.today {
            border-color: var(--orange);
        }
        .tracked-day-card-dow {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--text-muted);
            line-height: 1;
        }
        .tracked-day-card.active .tracked-day-card-dow,
        .tracked-day-card.today .tracked-day-card-dow {
            color: var(--orange);
        }
        .tracked-day-card-date {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.2;
            font-variant-numeric: tabular-nums;
        }
        .tracked-day-card.active .tracked-day-card-date {
            color: var(--orange);
        }
        .tracked-day-card-count {
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--text-muted);
            line-height: 1;
            margin-top: 1px;
        }
        .tracked-day-card.active .tracked-day-card-count {
            color: var(--orange);
        }
        .tracked-day-card-dot {
            position: absolute;
            top: 3px;
            right: 4px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--orange);
        }

        /* ---- Summary bar ---- */
        .tracked-summary {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.6rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }
        .tracked-summary-stat {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }
        .tracked-summary-stat strong {
            color: var(--text-primary);
            font-variant-numeric: tabular-nums;
        }

        /* ---- Picks grid ---- */
        .tracked-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .tracked-card {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.6rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: var(--shadow-sm);
            position: relative;
            transition: all 0.15s;
            overflow: hidden;
        }
        .tracked-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            border-radius: 10px 0 0 10px;
        }
        .tracked-card.tier-bestbet::before { background: var(--conf-bestbet); }
        .tracked-card.tier-elite::before { background: var(--conf-elite); }
        .tracked-card.tier-high::before { background: var(--conf-high); }
        .tracked-card.tier-medium::before { background: var(--conf-medium); }
        .tracked-card.tier-low::before { background: var(--conf-low); }

        .tracked-card-rank {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-muted);
            min-width: 22px;
            text-align: center;
        }

        .tracked-card-body {
            flex: 1;
            min-width: 0;
        }
        .tracked-card-pick {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .tracked-card-matchup {
            font-size: 0.7rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .tracked-card-meta {
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .tracked-card-prob {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.1rem;
            min-width: 44px;
        }
        .tracked-card-prob-value {
            font-size: 1rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .tracked-card-prob-value.bestbet { color: var(--conf-bestbet); }
        .tracked-card-prob-value.elite { color: var(--conf-elite); }
        .tracked-card-prob-value.high { color: var(--conf-high); }
        .tracked-card-prob-value.medium { color: var(--conf-medium); }
        .tracked-card-prob-value.low { color: var(--conf-low); }

        .tracked-card-type {
            font-size: 0.55rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        .tracked-card-remove {
            position: absolute;
            top: 4px;
            right: 6px;
            background: none;
            border: none;
            font-size: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            padding: 2px 4px;
            line-height: 1;
            min-height: auto;
        }

        /* W/L result toggle */
        .tracked-card-result {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
            min-width: 52px;
        }
        .tracked-result-btns {
            display: flex;
            gap: 3px;
        }
        .tracked-result-btn {
            padding: 3px 7px;
            border-radius: 5px;
            font-size: 0.6rem;
            font-weight: 700;
            cursor: pointer;
            border: 1.5px solid var(--border-color);
            background: var(--bg-input);
            color: var(--text-muted);
            transition: all 0.15s;
            line-height: 1;
            min-height: auto;
        }
        .tracked-result-btn:hover {
            border-color: var(--text-secondary);
            color: var(--text-primary);
        }
        .tracked-result-btn.win-active {
            background: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }
        .tracked-result-btn.loss-active {
            background: var(--accent-red);
            color: white;
            border-color: var(--accent-red);
        }
        .tracked-result-btn.push-active {
            background: var(--accent-yellow);
            color: #1a1a2e;
            border-color: var(--accent-yellow);
        }
        .tracked-result-source {
            font-size: 0.5rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .tracked-result-source.auto {
            color: var(--accent-green);
        }
        .tracked-result-locked {
            font-size: 0.85rem;
            font-weight: 800;
            padding: 2px 10px;
            border-radius: 5px;
            letter-spacing: 0.02em;
        }
        .tracked-result-locked.win { background: var(--accent-green); color: white; }
        .tracked-result-locked.loss { background: var(--accent-red); color: white; }
        .tracked-result-locked.push { background: var(--accent-yellow); color: #1a1a2e; }

        .tracked-card.result-win { border-color: rgba(76, 175, 80, 0.3); }
        .tracked-card.result-loss { border-color: rgba(244, 67, 54, 0.2); opacity: 0.8; }
        .tracked-card.result-push { border-color: rgba(255, 193, 7, 0.3); }

        .tracked-card:hover .tracked-card-remove { opacity: 1; }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .tracked-grid {
                grid-template-columns: 1fr;
                gap: 0.35rem;
            }
            .tracked-card {
                padding: 0.45rem 0.6rem;
                gap: 0.4rem;
            }
            .tracked-card-pick { font-size: 0.8rem; }
            .tracked-card-matchup { font-size: 0.65rem; }
            .tracked-card-prob-value { font-size: 0.9rem; }
            .tracked-card-rank { font-size: 0.65rem; min-width: 18px; }
            .tracked-card-remove { opacity: 0.5; }
            .tracked-result-btn { padding: 2px 5px; font-size: 0.55rem; }
            .tracked-result-locked { font-size: 0.75rem; padding: 2px 8px; }
            .tracked-card-result { min-width: 44px; }
            .tracked-header h2 { font-size: 1.2rem; }
            .tracked-summary { font-size: 0.75rem; gap: 0.6rem; padding: 0.5rem 0.75rem; }
            .tracked-day-strip { gap: 0.2rem; }
            .tracked-day-card { padding: 0.35rem 0.15rem; }
            .tracked-day-card-dow { font-size: 0.5rem; }
            .tracked-day-card-date { font-size: 0.75rem; }
            .tracked-day-card-count { font-size: 0.5rem; }
            .tracked-day-arrow { width: 30px; height: 30px; font-size: 0.85rem; min-height: 30px; }
        }

        /* === Rankings Search (5A/9) === */
        .rankings-search-container {
            position: relative;
            margin-bottom: 1rem;
        }
        .rankings-search-input {
            width: 100%;
            max-width: 320px;
            padding: 0.6rem 1rem 0.6rem 2.2rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 0.85rem;
            transition: border-color 0.2s;
        }
        .rankings-search-input:focus {
            outline: none;
            border-color: var(--orange);
        }
        .rankings-search-icon {
            position: absolute;
            left: 0.7rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.85rem;
            color: var(--text-muted);
            pointer-events: none;
        }

        /* === Rankings Sparkline Bars (5B) === */
        .rating-bar-container {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }
        .rating-bar {
            width: 40px;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-input);
            overflow: hidden;
            display: inline-block;
            vertical-align: middle;
        }
        .rating-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .rating-bar-fill.offense { background: var(--accent-green); }
        .rating-bar-fill.defense { background: var(--accent-blue); }

        /* === Rankings Top 25 Highlight (5C) === */
        .rankings-table tr.top-25 td:first-child {
            border-left: 3px solid var(--orange);
        }

        /* === Validation Hero Larger (6A) === */
        .val-hero-stat.primary .val-hero-stat-value {
            font-size: 2.2rem;
            font-family: 'Playfair Display', serif;
            font-weight: 800;
            line-height: 1.1;
        }
        .val-hero-stat-value {
            font-variant-numeric: tabular-nums;
        }

        /* === Tracker Pick Outcome Visual (6D) === */
        .tracker-pick.win {
            border-left: 3px solid var(--accent-green);
            background: linear-gradient(90deg, var(--accent-green-dim), transparent 60%);
        }
        .tracker-pick.loss {
            border-left: 3px solid var(--accent-red);
            background: linear-gradient(90deg, var(--accent-red-dim), transparent 60%);
        }
        .tracker-pick.push {
            border-left: 3px solid var(--accent-yellow);
            background: linear-gradient(90deg, var(--accent-yellow-dim), transparent 60%);
        }
        .tracker-pick.pending {
            border-left: 3px solid var(--border-color);
        }

        /* === Typography: Playfair for Section Titles (7A) === */
        .games-title-section h2,
        .section-title,
        .val-hero-title,
        .val-section-title {
            font-family: 'Playfair Display', serif;
            font-weight: 700;
        }

        /* === Typography: Tabular Nums (7C) === */
        .game-pick-value,
        .game-matchup-meta,
        .bb-pick-confidence-value,
        .bb-pick-badge,
        .val-hero-stat-value,
        .rankings-table td,
        .metric-chip-value,
        .tab-badge {
            font-variant-numeric: tabular-nums;
        }

        /* === Dark Mode Texture (8B) === */
        [data-theme="dark"] body {
            background-image: radial-gradient(ellipse at 15% 50%, rgba(30, 58, 95, 0.25), transparent 65%),
                              radial-gradient(ellipse at 85% 20%, rgba(255, 140, 66, 0.04), transparent 50%);
            background-attachment: fixed;
        }

        /* === Mobile Tab Bar Scroll (9B/10) === */
        @media (max-width: 600px) {
            .tabs-container {
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
                padding: 0.25rem 0.15rem;
            }
            .tabs-container::-webkit-scrollbar { display: none; }
            .tab { 
                font-size: 0.78rem;
                padding: 0.45rem 0.75rem;
                flex-shrink: 0;
            }
            .tab-divider { display: none; }
            .tab-legend-toggle { display: none; }
            .games-summary-bar { gap: 0.4rem; }
            .games-summary-chip { font-size: 0.7rem; padding: 0.3rem 0.5rem; }
        }

        /* === Smooth Expand/Collapse (10C) === */
        .drill-down-content {
            overflow: hidden;
            transition: opacity 0.25s ease, max-height 0.35s ease;
            opacity: 0;
            max-height: 0;
        }
        .drill-down-content.visible {
            opacity: 1;
            max-height: 2000px;
        }
        /* Override the earlier display:none rules with transition-friendly approach */
        .game-card-new .drill-down-content,
        .bb-pick-card .drill-down-content {
            display: block;
        }
        .game-card-new .drill-down-content.visible,
        .bb-pick-card .drill-down-content.visible {
            display: block;
            margin: 0 0.5rem 0.4rem;
            padding: 0.4rem;
        }

        /* === Loading Skeletons (10A) === */
        .skeleton-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem 1.25rem;
            margin-bottom: 0.5rem;
        }
        .skeleton-row {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        .skeleton-line {
            height: 14px;
            border-radius: 4px;
            background: linear-gradient(90deg, var(--bg-secondary) 25%, var(--bg-input) 50%, var(--bg-secondary) 75%);
            background-size: 200% 100%;
            animation: skeletonShimmer 1.5s ease-in-out infinite;
        }
        .skeleton-line.title { width: 55%; height: 18px; }
        .skeleton-line.meta  { width: 35%; height: 12px; margin-top: 0.4rem; }
        .skeleton-line.badge { width: 60px; height: 28px; border-radius: 6px; }
        .skeleton-line.prob  { width: 45px; height: 24px; border-radius: 6px; }
        @keyframes skeletonShimmer {
            0%   { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* === Back To Top FAB (10D) === */
        .back-to-top {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--navy);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            z-index: 40;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
        }
        .back-to-top.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        .back-to-top:hover {
            background: var(--orange);
        }
        [data-theme="dark"] .back-to-top {
            background: var(--orange);
        }
        [data-theme="dark"] .back-to-top:hover {
            background: var(--orange-hover);
        }

    </style>
    
    <!-- Google Identity Services -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
    <!-- Skip to main content link for keyboard users -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <div class="container" role="main" id="main-content">
        <div class="sticky-nav-wrapper">
        <header class="header">
            <div class="header-left">
                <a href="#main-content" class="brand-logo" aria-label="The Spread Sheet - Home">
                    <img src="assets/brand/logo-icon.png"
                         alt="The Spread Sheet logo - basketball with trend arrow"
                         class="brand-logo-img logo-img"
                         width="48"
                         height="48"
                         loading="eager"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                    <!-- SVG fallback if image fails to load -->
                    <svg class="logo-img" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="display:none;" aria-hidden="true">
                        <circle cx="50" cy="50" r="46" fill="#ff8c42" stroke="#1e3a5f" stroke-width="4"/>
                        <path d="M 50 4 Q 18 50 50 96" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                        <path d="M 50 4 Q 82 50 50 96" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                        <path d="M 6 40 Q 50 55 94 40" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                        <path d="M 6 60 Q 50 45 94 60" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                        <path d="M 25 68 L 42 48 L 58 58 L 78 32" fill="none" stroke="white" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
                        <polygon points="78,32 66,36 70,46" fill="white"/>
                    </svg>
                </a>
                <div class="logo-text-group">
                    <span class="logo-title">The Spread Sheet</span>
                    <span class="logo-tagline">Data Don't Lie</span>
                </div>
            </div>
            <div class="header-right">
                <div class="share-btn-group">
                    <button class="share-btn" id="shareDesktopBtn" onclick="exportTopTenAsImage('desktop')" title="Export Top 10 Picks">
                        <span class="share-btn-icon"></span>
                        <span class="share-btn-label">Export Top 10 Picks</span>
                    </button>
                </div>
                <div class="header-status">
                    <span class="status-dot" id="statusDot"></span>
                    <span id="lastUpdate">Not Connected</span>
                </div>
                <div class="hamburger-menu-container">
                    <button class="hamburger-btn" 
                            id="hamburgerBtn"
                            aria-label="Main menu"
                            aria-expanded="false"
                            aria-controls="hamburgerDropdown"
                            aria-haspopup="true">
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                    <div class="hamburger-dropdown" 
                         id="hamburgerDropdown"
                         role="menu"
                         aria-labelledby="hamburgerBtn">
                        <div class="menu-theme-row">
                            <span class="menu-theme-label">
                                <span class="menu-icon" id="themeIcon"></span>
                                <span>Dark Mode</span>
                            </span>
                            <button class="theme-toggle-switch" 
                                    id="themeToggleSwitch"
                                    role="switch"
                                    aria-checked="false"
                                    aria-label="Toggle dark mode"
                                    tabindex="0"></button>
                        </div>
                        <button class="hamburger-dropdown-item" role="menuitem" data-action="settings" tabindex="-1">
                            <span class="menu-icon"></span>
                            <span>Settings</span>
                        </button>
                        <button class="hamburger-dropdown-item" role="menuitem" data-action="refresh" tabindex="-1">
                            <span class="menu-icon"></span>
                            <span>Refresh Data</span>
                        </button>
                        <div class="hamburger-dropdown-divider" role="separator"></div>
                        <button class="hamburger-dropdown-item" role="menuitem" data-action="diagnostics" tabindex="-1">
                            <span class="menu-icon"></span>
                            <span>Model Diagnostics</span>
                        </button>
                        <button class="hamburger-dropdown-item" role="menuitem" data-action="how" tabindex="-1">
                            <span class="menu-icon"></span>
                            <span>How It Works</span>
                        </button>
                        <button class="hamburger-dropdown-item" role="menuitem" data-action="glossary" tabindex="-1">
                            <span class="menu-icon"></span>
                            <span>Glossary</span>
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <section class="settings-panel" id="settingsPanel" style="display:none!important;">
            <div class="settings-content">
                <div class="settings-field" style="flex:1;">
                    <label class="settings-label">Proxy Server URL</label>
                    <input class="settings-input" type="text" id="proxyUrl" placeholder="https://your-app.onrender.com">
                </div>
                <div class="settings-actions">
                    <button class="btn-refresh" id="refreshBtn" onclick="refreshAllData()" aria-busy="false">
                        <span class="refresh-icon-container">
                            <span class="refresh-basketball" aria-hidden="true">
                                <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="50" cy="50" r="46" fill="#ff8c42" stroke="#1e3a5f" stroke-width="4"/>
                                    <path d="M 50 4 Q 18 50 50 96" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                                    <path d="M 50 4 Q 82 50 50 96" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                                    <path d="M 6 40 Q 50 55 94 40" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                                    <path d="M 6 60 Q 50 45 94 60" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/>
                                </svg>
                            </span>
                        </span>
                        <span class="refresh-text">Refresh Data</span>
                    </button>
                    <span id="refreshStatus" class="sr-only" aria-live="polite" aria-atomic="true"></span>
                </div>
            </div>
            <div style="display:flex;gap:0.75rem;padding:0 1.25rem 1.25rem;flex-wrap:wrap;">
                <span class="status-badge" id="oddsStatus"> Odds</span>
                <span class="status-badge" id="ratingsStatus"> Ratings</span>
            </div>
        </section>

        <!-- Metrics Summary Bar - Collapsible quick overview of model performance -->
        <div class="metrics-bar-wrapper" id="metricsBarWrapper">
            <button class="metrics-bar-toggle" id="metricsBarToggle" onclick="toggleMetricsBar()" aria-expanded="false" aria-controls="metricsBar">
                <span class="metrics-bar-toggle-icon"></span>
                <span class="metrics-bar-toggle-text">Performance Stats</span>
                <span class="metrics-bar-toggle-preview" id="metricsBarPreview">--</span>
            </button>
            <div class="metrics-bar collapsed" id="metricsBar" role="region" aria-label="Performance summary" aria-hidden="true">
                <div class="metric-chip" id="metricRecord">
                    <span class="metric-chip-value" id="metricRecordValue">--</span>
                    <span class="metric-chip-label">Record</span>
                </div>
                <div class="metric-chip" id="metricWinRate">
                    <span class="metric-chip-value" id="metricWinRateValue">--</span>
                    <span class="metric-chip-label">Win %</span>
                    <span class="metric-chip-ci" id="metricWinRateCI"></span>
                </div>
                <div class="metric-chip" id="metricROI">
                    <span class="metric-chip-value" id="metricROIValue">--</span>
                    <span class="metric-chip-label">ROI</span>
                    <span class="metric-chip-ci" id="metricROICI"></span>
                </div>
                <div class="metric-chip" id="metricSampleSize">
                    <span class="metric-chip-value" id="metricSampleSizeValue">--</span>
                    <span class="metric-chip-label">n=</span>
                </div>
                <div class="metric-chip" id="metricLastUpdate">
                    <span class="metric-chip-value" id="metricLastUpdateValue">--</span>
                    <span class="metric-chip-label">Updated</span>
                </div>
            </div>
        </div>

        <div class="tabs-container" role="tablist" aria-label="Main navigation">
            <button class="tab active" onclick="switchTab('games')" id="tabGames" role="tab" aria-selected="true" aria-controls="gamesTab">Games <span class="tab-badge" id="tabGamesCount"></span></button>
            <button class="tab" onclick="switchTab('bestbets')" id="tabBestbets" role="tab" aria-selected="false" aria-controls="bestbetsTab">Best Bets <span class="tab-badge" id="tabBetsCount"></span></button>
            <button class="tab" onclick="switchTab('tracked')" id="tabTracked" role="tab" aria-selected="false" aria-controls="trackedTab">Tracked <span class="tab-badge" id="tabTrackedCount"></span></button>
            <span class="tab-divider"></span>
            <button class="tab" onclick="switchTab('rankings')" id="tabRankings" role="tab" aria-selected="false" aria-controls="rankingsTab">Rankings</button>
            <button class="tab" onclick="switchTab('bracket')" id="tabBracket" role="tab" aria-selected="false" aria-controls="bracketTab">March Madness</button>
            <button class="tab" onclick="switchTab('validation')" id="tabValidation" role="tab" aria-selected="false" aria-controls="validationTab">Record</button>
            <button class="tab-legend-toggle" onclick="document.getElementById('globalConfidenceLegend').classList.toggle('visible')" title="Toggle win probability legend" aria-label="Toggle legend">?</button>
        </div>
        </div>

        <!-- Unified Win% Legend - Shared across Games and Best Bets tabs -->
        <div class="confidence-legend confidence-legend--global" id="globalConfidenceLegend" role="region" aria-label="Win probability legend">
            <span class="confidence-legend-title">Win Probability</span>
            <div class="confidence-legend-items">
                <div class="confidence-legend-item">
                    <span class="confidence-legend-dot bestbet"></span>
                    <span class="confidence-legend-label">Best Bet</span>
                    <span class="confidence-legend-range">62%+</span>
                </div>
                <div class="confidence-legend-item">
                    <span class="confidence-legend-dot elite"></span>
                    <span class="confidence-legend-label">Elite</span>
                    <span class="confidence-legend-range">58-62%</span>
                </div>
                <div class="confidence-legend-item">
                    <span class="confidence-legend-dot high"></span>
                    <span class="confidence-legend-label">Strong</span>
                    <span class="confidence-legend-range">55-58%</span>
                </div>
                <div class="confidence-legend-item">
                    <span class="confidence-legend-dot medium"></span>
                    <span class="confidence-legend-label">Edge</span>
                    <span class="confidence-legend-range">52.4-55%</span>
                </div>
                <div class="confidence-legend-item">
                    <span class="confidence-legend-dot low"></span>
                    <span class="confidence-legend-label">No edge</span>
                    <span class="confidence-legend-range">&lt;52.4%</span>
                </div>
            </div>
        </div>

        <div id="gamesTab" class="tab-content">
            <div class="games-page-container">
                <!-- Sidebar Filters -->
                <div class="games-sidebar">
                    <!-- Conferences Filter -->
                    <div class="bb-filter-section">
                        <div class="bb-filter-title">Conferences</div>
                        <div class="bb-conf-list" id="gamesConfList">
                            <div class="bb-conf-item active" data-conf="all" onclick="setGamesConfFilter('all', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>All Conferences</span>
                            </div>
                            <div class="bb-conf-item" data-conf="ACC" onclick="setGamesConfFilter('ACC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>ACC</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Big Ten" onclick="setGamesConfFilter('Big Ten', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Big Ten</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Big 12" onclick="setGamesConfFilter('Big 12', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Big 12</span>
                            </div>
                            <div class="bb-conf-item" data-conf="SEC" onclick="setGamesConfFilter('SEC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>SEC</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Big East" onclick="setGamesConfFilter('Big East', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Big East</span>
                            </div>
                            <div class="bb-conf-item" data-conf="AAC" onclick="setGamesConfFilter('AAC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>AAC</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Mountain West" onclick="setGamesConfFilter('Mountain West', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Mountain West</span>
                            </div>
                            <div class="bb-conf-item" data-conf="WCC" onclick="setGamesConfFilter('WCC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>WCC</span>
                            </div>
                        </div>
                    </div>

                    <!-- Probability Slider -->
                    <div class="bb-filter-section">
                        <div class="bb-filter-title">Min Win Probability</div>
                        <div class="bb-slider-container">
                            <div class="bb-slider-header">
                                <span class="bb-slider-label">Show picks at or above</span>
                                <span class="bb-slider-value" id="gamesProbValue">54%</span>
                            </div>
                            <input type="range" class="bb-slider" id="gamesProbSlider" min="50" max="80" value="54" oninput="updateGamesProbSlider(this.value)">
                        </div>
                    </div>

                </div>

                <!-- Main Content -->
                <div class="games-main-content">
                    <!-- Header -->
                    <div class="games-header">
                        <div class="games-title-section">
                            <h2>Today's Games</h2>
                            <div class="games-subtitle">NCAA College Basketball matchups with spread & total analysis.</div>
                        </div>
                        <div class="games-header-controls">
                            <!-- Team Search -->
                            <div class="games-team-search-container games-team-search-header">
                                <input type="text" class="games-team-search-input" id="teamSearch" placeholder="Search team..." autocomplete="off" oninput="handleTeamSearch(this.value)">
                                <button class="games-team-search-clear" onclick="clearTeamSearch()"></button>
                                <div class="games-team-search-dropdown" id="teamSearchDropdown"></div>
                            </div>
                            <!-- Sort Pills using same style as Best Bets -->
                            <div class="bb-type-tabs">
                                <button class="bb-type-tab" onclick="sortGames('spread', this)">Spread</button>
                                <button class="bb-type-tab" onclick="sortGames('total', this)">Total</button>
                                <button class="bb-type-tab active" onclick="sortGames('time', this)">Time</button>
                            </div>
                        </div>
                    </div>

                    <!-- Games Summary Bar -->
                    <div class="games-summary-bar" id="gamesSummaryBar"></div>

                    <!-- Games List -->
                    <div class="games-list" id="gamesList">
                        <div class="loading-state-branded" id="gamesLoadingState">
                            <img src="assets/brand/logo-icon.png" alt="" class="loading-logo" aria-hidden="true">
                            <p class="loading-text">Click <strong>Refresh Data</strong> to load today's games</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="bestbetsTab" class="tab-content" style="display:none;">
            <div class="bb-page-container">
                <!-- Sidebar Filters -->
                <div class="bb-sidebar">
                    <!-- Conferences Filter -->
                    <div class="bb-filter-section">
                        <div class="bb-filter-title">Conferences</div>
                        <div class="bb-conf-list" id="bbConfList">
                            <div class="bb-conf-item active" data-conf="all" onclick="setBBConfFilter('all', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>All Conferences</span>
                            </div>
                            <div class="bb-conf-item" data-conf="ACC" onclick="setBBConfFilter('ACC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>ACC</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Big Ten" onclick="setBBConfFilter('Big Ten', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Big Ten</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Big 12" onclick="setBBConfFilter('Big 12', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Big 12</span>
                            </div>
                            <div class="bb-conf-item" data-conf="SEC" onclick="setBBConfFilter('SEC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>SEC</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Big East" onclick="setBBConfFilter('Big East', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Big East</span>
                            </div>
                            <div class="bb-conf-item" data-conf="AAC" onclick="setBBConfFilter('AAC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>AAC</span>
                            </div>
                            <div class="bb-conf-item" data-conf="Mountain West" onclick="setBBConfFilter('Mountain West', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>Mountain West</span>
                            </div>
                            <div class="bb-conf-item" data-conf="WCC" onclick="setBBConfFilter('WCC', this)">
                                <div class="bb-conf-checkbox"></div>
                                <span>WCC</span>
                            </div>
                        </div>
                    </div>

                    <!-- Probability Slider -->
                    <div class="bb-filter-section">
                        <div class="bb-filter-title">Probability</div>
                        <div class="bb-slider-container">
                            <div class="bb-slider-header">
                                <span class="bb-slider-label">Min Win %</span>
                                <span class="bb-slider-value" id="bbProbValue">54%</span>
                            </div>
                            <input type="range" class="bb-slider" id="bbProbSlider" min="50" max="80" value="54" oninput="updateBBProbSlider(this.value)">
                        </div>
                    </div>
                </div>

                <!-- Main Content -->
                <div class="bb-main-content">
                    <!-- Header -->
                    <div class="bb-header">
                        <div class="bb-title-section">
                            <h2>CBB Best Bets</h2>
                            <div class="bb-subtitle">Advanced Spread & Total analytics for NCAA College Basketball.</div>
                        </div>
                        <div class="bb-header-controls">
                            <!-- Team Search -->
                            <div class="bb-team-search-container">
                                <input type="text" class="bb-team-search-input" id="bbTeamSearch" placeholder="Search team..." autocomplete="off" oninput="handleBBTeamSearch(this.value)">
                                <button class="bb-team-search-clear" onclick="clearBBTeamSearch()"></button>
                                <div class="bb-team-search-dropdown" id="bbTeamSearchDropdown"></div>
                            </div>
                            <!-- Type Tabs -->
                            <div class="bb-type-tabs">
                                <button class="bb-type-tab" id="bbTabSpread" onclick="setBBTypeTab('spread', this)">Spread Picks</button>
                                <button class="bb-type-tab" id="bbTabTotal" onclick="setBBTypeTab('total', this)">Total Picks</button>
                                <button class="bb-type-tab active" id="bbTabValue" onclick="setBBTypeTab('value', this)">Highest Value</button>
                                <button class="bb-type-tab active" id="bbTabToday" onclick="toggleBBToday(this)" title="Show only today's games">Today</button>
                            </div>
                        </div>
                    </div>

                    <!-- Quick Stats Bar -->
                    <div class="bb-quick-stats" id="bbQuickStats"></div>

                    <!-- Picks List -->
                    <div id="bestBetsList" class="bb-picks-list">
                        <div class="loading-state-branded" id="bestBetsLoadingState">
                            <img src="assets/brand/logo-icon.png" alt="" class="loading-logo" aria-hidden="true">
                            <p class="loading-text">Click <strong>Refresh Data</strong> to load best bets</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ====== TRACKED BETS TAB ====== -->
        <div id="trackedTab" class="tab-content" style="display:none;">
            <div class="tracked-bets-page">
                <!-- Header -->
                <div class="tracked-header">
                    <div class="tracked-title-section">
                        <h2>My Tracked Picks</h2>
                        <div class="tracked-subtitle">Your personally selected bets  screenshot & share</div>
                    </div>
                    <div class="tracked-header-actions">
                        <button class="bb-track-btn" onclick="clearTrackedBetsForDay()" style="color:var(--accent-red);border-color:var(--accent-red);" id="trackedClearDayBtn"> Clear Day</button>
                    </div>
                </div>

                <!-- 7-Day Strip -->
                <div class="tracked-day-strip">
                    <button class="tracked-day-arrow" id="trackedDayBack" onclick="shiftTrackedWeek(-7)"></button>
                    <div class="tracked-day-cards" id="trackedDayCards"></div>
                    <button class="tracked-day-arrow" id="trackedDayForward" onclick="shiftTrackedWeek(7)"></button>
                </div>

                <!-- Summary for selected day -->
                <div class="tracked-summary" id="trackedDaySummary" style="display:none;"></div>

                <!-- Picks grid for selected day -->
                <div class="tracked-grid" id="trackedBetsGrid">
                    <div class="bb-empty-state" style="grid-column:1/-1;">
                        <div class="bb-empty-icon"></div>
                        <div class="bb-empty-title">No tracked picks yet</div>
                        <div class="bb-empty-text">Use the  Track button on any pick in the Games or Best Bets tab to add it here.</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="rankingsTab" class="tab-content" style="display:none;">
            <div class="section-header">
                <h2 class="section-title">Team Rankings</h2>
                <div class="rankings-search-container">
                    <span class="rankings-search-icon"></span>
                    <input type="text" class="rankings-search-input" id="rankingsSearchInput" placeholder="Search teams..." oninput="filterRankingsBySearch(this.value)">
                </div>
                <div class="filter-pills">
                    <select class="filter-select" id="rankingsConfFilter" onchange="renderRankings()">
                        <option value="all">All Teams</option>
                        <option value="power">Power Conferences</option>
                        <option value="ACC">ACC</option>
                        <option value="Big 12">Big 12</option>
                        <option value="Big Ten">Big Ten</option>
                        <option value="Big East">Big East</option>
                        <option value="SEC">SEC</option>
                        <option value="AAC">AAC</option>
                        <option value="Mountain West">Mountain West</option>
                        <option value="WCC">WCC</option>
                        <option value="MVC">Missouri Valley</option>
                        <option value="A-10">Atlantic 10</option>
                    </select>
                </div>
            </div>
            
            <!-- Methodology Explanation -->
            <div class="info-card">
                <h3>How We Calculate Team Scores</h3>
                <p>Our <strong>Composite Score (0-100)</strong> ranks teams for futures betting value by weighting key efficiency metrics:</p>
                <div class="weight-grid">
                    <div class="weight-card"><strong>40%</strong> Net Rating</div>
                    <div class="weight-card"><strong>20%</strong> Offensive Rating</div>
                    <div class="weight-card"><strong>20%</strong> Defensive Rating</div>
                    <div class="weight-card"><strong>10%</strong> KenPom Rank</div>
                    <div class="weight-card"><strong>10%</strong> Conference Strength</div>
                </div>
                <p class="info-card--note"><strong>NET (Net Rating)</strong> = Offensive Rating  Defensive Rating. It measures points scored vs allowed per 100 possessions, adjusted for opponent strength. A +15 NET is elite; negative means below average.</p>
            </div>
            
            <!-- Conference Summary (when viewing a specific conference) -->
            <div id="conferenceSummary" style="display:none;">
                <div class="conference-summary-grid" id="confSummaryGrid"></div>
            </div>
            
            <!-- Full Rankings Table -->
            <h3 class="section-subtitle" id="rankingsTableTitle">Full Rankings</h3>
            <div class="rankings-table-container">
                <table class="rankings-table" id="rankingsTable">
                    <thead>
                        <tr>
                            <th style="width:50px;">Rank</th>
                            <th>Team</th>
                            <th>Conf</th>
                            <th class="sortable" onclick="sortRankings('composite')">Score </th>
                            <th class="sortable" onclick="sortRankings('netRating')">Net</th>
                            <th class="sortable" onclick="sortRankings('offRating')">Off</th>
                            <th class="sortable" onclick="sortRankings('defRating')">Def</th>
                            <th class="sortable" onclick="sortRankings('sosRank')">SOS</th>
                            <th>Ceiling</th>
                            <th>Floor</th>
                        </tr>
                    </thead>
                    <tbody id="rankingsTableBody">
                    </tbody>
                </table>
            </div>
        </div>


        <div id="bracketTab" class="tab-content" style="display:none;">
            <div class="section-header">
                <h2 class="section-title"> March Madness</h2>
                <div class="bracket-sim-controls">
                    <button class="btn btn-primary" onclick="runBracketSimulation()"> Simulate Tournament</button>
                    <select id="simCountSelect" class="styled-select">
                        <option value="1">Single Sim</option>
                        <option value="100">100 sims</option>
                        <option value="500">500 sims</option>
                        <option value="1000" selected>1,000 sims</option>
                        <option value="5000">5,000 sims</option>
                    </select>
                    <button class="btn btn-secondary" onclick="analyzeContenders()"> Contenders</button>
                </div>
                <details style="margin-top:0.75rem;margin-bottom:0.75rem;">
                    <summary style="cursor:pointer;font-size:0.8rem;font-weight:600;color:var(--text-secondary);padding:0.3rem 0;"> Simulation Config</summary>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:0.75rem;margin-top:0.5rem;padding:0.75rem;background:var(--bg-input);border-radius:8px;">
                        <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;cursor:pointer;">
                            <input type="checkbox" id="toggleAutoBids" checked> Auto-Bids (conf champs)
                        </label>
                        <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;cursor:pointer;">
                            <input type="checkbox" id="toggleFirstFour" checked> First Four (68 teams)
                        </label>
                        <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;cursor:pointer;">
                            <input type="checkbox" id="toggleAvoidConf" checked> Avoid same-conf R64
                        </label>
                        <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;cursor:pointer;">
                            <input type="checkbox" id="toggleBalance" checked> Balance regions
                        </label>
                        <div style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;" title="Compresses win probability for large rating gaps. 1.0 = no compression (pure Log5), 0.5 = heavy compression (more upsets). Applied to rating differences >10 pts.">
                            <label for="dampSlider">Mismatch damp:</label>
                            <input type="range" id="dampSlider" min="0.5" max="1" step="0.05" value="0.85" style="width:80px;">
                            <span id="dampValue" style="font-family:JetBrains Mono,monospace;min-width:28px;">0.85</span>
                        </div>
                        <div style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;">
                            <label for="playInSeedSelect">Play-in line:</label>
                            <select id="playInSeedSelect" class="styled-select" style="min-width:60px;padding:0.2rem;">
                                <option value="11" selected>11-seed</option>
                                <option value="12">12-seed</option>
                            </select>
                        </div>
                        <div style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;">
                            <label for="rngSeedInput">RNG seed:</label>
                            <input type="number" id="rngSeedInput" placeholder="Random" style="width:70px;padding:0.2rem 0.4rem;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:4px;color:var(--text-primary);font-size:0.75rem;">
                        </div>
                        <div style="display:flex;align-items:center;gap:0.4rem;font-size:0.75rem;" title="Max cross-region swap attempts per seed-line conflict before the system preserves bracket integrity and logs the unresolved conflict.">
                            <label for="swapLimitInput">Swap limit/line:</label>
                            <input type="number" id="swapLimitInput" value="3" min="1" max="12" style="width:45px;padding:0.2rem 0.4rem;background:var(--bg-secondary);border:1px solid var(--border-color);border-radius:4px;color:var(--text-primary);font-size:0.75rem;text-align:center;">
                        </div>
                    </div>
                </details>
                <script>
                    document.getElementById('dampSlider')?.addEventListener('input', function() {
                        document.getElementById('dampValue').textContent = this.value;
                    });
                </script>
            </div>
            
            <div id="fieldSelectionPanel" style="display:none;"></div>
            <div id="swapLogPanel" style="display:none;"></div>
            <div id="monteCarloPanel" style="display:none;margin-bottom:1rem;"></div>

            <div id="contendersSection" style="display:none;">
                <div class="info-card" style="margin-bottom:1rem;">
                    <h3> Tournament Contender Analysis</h3>
                    <p style="margin-bottom:0.5rem;">Based on 25 years of March Madness data, here are the key metrics that predict tournament success:</p>
                    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:1rem;margin-top:1rem;">
                        <div style="background:var(--bg-input);padding:0.75rem;border-radius:8px;border-left:3px solid gold;">
                            <strong style="color:gold;"> Champion Profile</strong>
                            <ul style="margin:0.5rem 0 0 1rem;font-size:0.85rem;">
                                <li>Top 20 in BOTH offense & defense efficiency</li>
                                <li>1, 2, or 3 seed (33 of 34 champs since 1985)</li>
                                <li>Top 6 overall in advanced metrics</li>
                                <li>Power conference team</li>
                            </ul>
                        </div>
                        <div style="background:var(--bg-input);padding:0.75rem;border-radius:8px;border-left:3px solid silver;">
                            <strong style="color:silver;"> Final Four Profile</strong>
                            <ul style="margin:0.5rem 0 0 1rem;font-size:0.85rem;">
                                <li>Top 25 in offensive efficiency</li>
                                <li>Top 25 in defensive efficiency</li>
                                <li>1-4 seed (37 of 40 FF teams last decade)</li>
                                <li>Top 25 in margin of victory</li>
                            </ul>
                        </div>
                        <div style="background:var(--bg-input);padding:0.75rem;border-radius:8px;border-left:3px solid #cd7f32;">
                            <strong style="color:#cd7f32;"> Elite 8 Profile</strong>
                            <ul style="margin:0.5rem 0 0 1rem;font-size:0.85rem;">
                                <li>Top 40 in offensive efficiency</li>
                                <li>Top 40 in defensive efficiency</li>
                                <li>Usually 1-5 seed</li>
                                <li>Balanced on both ends</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div id="contendersGrid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:1rem;margin-bottom:1.5rem;"></div>
            </div>
            
            <div class="alert"><span></span><div><strong>NCAA Tournament Simulator v3:</strong> Builds a 68-team field with auto-bids &amp; at-larges, seeds 1-68 with conference-strength tiebreaks, S-curve bracketing with conference conflict avoidance &amp; region balancing, First Four play-ins, and Monte Carlo simulation for title/FF/E8/S16 odds. All adjustments logged. Click any game for analysis.</div></div>
            
            <div id="bracketStatus" class="bracket-status"></div>
            <div id="bracketStatsBar" class="bracket-stats-bar" style="display:none;"></div>
            <div id="bracketWrapper" class="bracket-wrapper">
                <div class="empty-state"><div class="empty-icon"></div><div class="empty-title">Load Data First</div><p class="empty-text">Refresh data and click "Simulate Tournament" to generate bracket</p></div>
            </div>
        </div>

        <div id="validationTab" class="tab-content" style="display:none;">
            <div class="section-header">
                <h2 class="section-title">Model Record</h2>
                <div class="tracker-actions">
                    <select id="timeFrameSelect" class="styled-select" onchange="changeTimeFrame(this.value)" style="min-width:120px;">
                        <option value="7">Last 7 Days</option>
                        <option value="14">Last 14 Days</option>
                        <option value="30" selected>Last 30 Days</option>
                        <option value="90">Last 90 Days</option>
                        <option value="v51">v5.1 Only</option>
                        <option value="all">All Time</option>
                    </select>
                    <button class="tracker-btn" onclick="exportPredictionsBackup()" title="Export backup"></button>
                    <button class="tracker-btn" onclick="importPredictionsBackup()" title="Import backup"></button>
                    <div class="sync-divider"></div>
                    <div class="cloud-sync-group">
                        <button class="cloud-sync-btn google" id="googleSignInBtn" onclick="signInWithGoogle()" title="Sign in with Google">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                            Sign In
                        </button>
                        <button class="cloud-sync-btn synced" id="cloudSyncBtn" onclick="syncToCloud()" title="Sync to Google Drive" style="display:none;">
                             Sync
                        </button>
                        <span class="cloud-sync-status" id="cloudSyncStatus"></span>
                    </div>
                </div>
            </div>

            <!-- ====== FILTER TABS ====== -->
            <div class="record-filter-strip">
                <button class="record-filter-btn active" data-filter="bestbets" onclick="setRecordFilter('bestbets', this)">Best Bets</button>
                <button class="record-filter-btn" data-filter="all" onclick="setRecordFilter('all', this)">All Bets</button>
                <span class="record-filter-divider"></span>
                <button class="record-filter-btn ball-filter" data-filter="ball5" onclick="setRecordFilter('ball5', this)" title="5 Basketball Locks"></button>
                <button class="record-filter-btn ball-filter" data-filter="ball4" onclick="setRecordFilter('ball4', this)" title="4 Basketball Elite"></button>
                <button class="record-filter-btn ball-filter" data-filter="ball3" onclick="setRecordFilter('ball3', this)" title="3 Basketball Strong"></button>
                <button class="record-filter-btn ball-filter" data-filter="ball2" onclick="setRecordFilter('ball2', this)" title="2 Basketball Solid"></button>
                <button class="record-filter-btn ball-filter" data-filter="ball1" onclick="setRecordFilter('ball1', this)" title="1 Basketball Good"></button>
            </div>

            <!-- ====== HERO STATS ====== -->
            <div class="val-hero" id="valHero">
                <div class="val-hero-header">
                    <div class="val-hero-title" id="valHeroTitle"> Best Bets</div>
                    <div class="val-hero-meta" id="valHeroMeta">--</div>
                </div>
                <div class="val-hero-stats">
                    <div class="val-hero-stat primary">
                        <div class="val-hero-stat-value" id="bbHeroRecord">0-0</div>
                        <div class="val-hero-stat-label">Record</div>
                    </div>
                    <div class="val-hero-stat">
                        <div class="val-hero-stat-value" id="bbHeroWinRate">--</div>
                        <div class="val-hero-stat-label">Win Rate</div>
                    </div>
                    <div class="val-hero-stat">
                        <div class="val-hero-stat-value" id="bbHeroROI">--</div>
                        <div class="val-hero-stat-label">ROI</div>
                    </div>
                    <div class="val-hero-stat">
                        <div class="val-hero-stat-value" id="bbHeroUnits">--</div>
                        <div class="val-hero-stat-label">Units</div>
                    </div>
                    <div class="val-hero-stat">
                        <div class="val-hero-stat-value" id="bbHeroStreak">--</div>
                        <div class="val-hero-stat-label">Streak</div>
                    </div>
                </div>
                <div class="val-hero-split" id="bbHeroSplit"></div>
                <!-- Trend indicator -->
                <div class="val-hero-trend" id="valHeroTrend"></div>
            </div>

            <!-- ====== ROLLING WIN RATE CHART ====== -->
            <div class="val-section">
                <div class="val-section-header">
                    <div class="val-section-title">Win Rate Trend</div>
                    <div class="val-section-subtitle" id="rollingChartSubtitle">7-day rolling average</div>
                </div>
                <div class="chart-container" id="rollingWinRateChart">
                    <div class="chart-placeholder">Loading chart data...</div>
                </div>
            </div>

            <!-- ====== BASKETBALL RATING TIERS ====== -->
            <div class="val-section" id="valRatingSection">
                <div class="val-section-header">
                    <div class="val-section-title">Performance by Rating</div>
                    <div class="val-section-subtitle">Higher ratings = higher model confidence</div>
                </div>
                <div class="val-rating-grid" id="valRatingGrid"></div>
            </div>

            <!-- ====== ROI / CUMULATIVE CHART ====== -->
            <div class="val-section">
                <div class="val-section-header">
                    <div class="val-section-title">Profit & Loss</div>
                    <div class="chart-tabs">
                        <button class="chart-tab active" onclick="switchChart('roi', this)">Daily ROI</button>
                        <button class="chart-tab" onclick="switchChart('cumulative', this)">Cumulative Units</button>
                    </div>
                </div>
                <div class="chart-container" id="performanceChart">
                    <div class="chart-placeholder">Loading chart data...</div>
                </div>
            </div>

            <!-- ====== SPREAD VS TOTAL BREAKDOWN ====== -->
            <div class="val-section">
                <div class="val-section-header">
                    <div class="val-section-title">Type Breakdown</div>
                </div>
                <div class="record-type-breakdown" id="recordTypeBreakdown"></div>
            </div>

            <!-- ====== RECENT PICKS ====== -->
            <div class="val-section">
                <div class="val-section-header">
                    <div class="val-section-title">Recent Picks</div>
                    <span class="val-picks-count" id="picksCountLabel">0 picks</span>
                </div>
                <div class="tracker-picks-list" id="trackerPicksList">
                    <div class="tracker-empty">
                        <div class="tracker-empty-icon"></div>
                        <div class="tracker-empty-title">No Predictions Yet</div>
                        <div class="tracker-empty-text">Click "Refresh Data" to capture today's predictions. They'll automatically resolve when games complete.</div>
                    </div>
                </div>
            </div>

            <!-- Day Detail Modal (keep) -->
            <div class="day-detail-modal" id="dayDetailModal" style="display:none;">
                <div class="day-detail-content">
                    <div class="day-detail-header">
                        <h3 id="dayDetailTitle">Day Details</h3>
                        <button class="day-detail-close" onclick="closeDayDetail()"></button>
                    </div>
                    <div class="day-detail-body" id="dayDetailBody"></div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-bottom:0.5rem;">
                <svg style="width:24px;height:24px;" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs><linearGradient id="footerBallGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#ff8c42"/><stop offset="100%" style="stop-color:#e86a1c"/></linearGradient></defs>
                    <circle cx="50" cy="50" r="45" fill="url(#footerBallGrad)" stroke="#1e3a5f" stroke-width="4"/>
                    <path d="M 50 5 Q 20 50 50 95" fill="none" stroke="#1e3a5f" stroke-width="3"/>
                    <path d="M 50 5 Q 80 50 50 95" fill="none" stroke="#1e3a5f" stroke-width="3"/>
                    <path d="M 8 40 Q 50 55 92 40" fill="none" stroke="#1e3a5f" stroke-width="3"/>
                    <path d="M 8 60 Q 50 45 92 60" fill="none" stroke="#1e3a5f" stroke-width="3"/>
                    <path d="M 20 70 L 40 50 L 55 60 L 80 30" fill="none" stroke="white" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
                    <polygon points="80,30 68,35 73,45" fill="white"/>
                </svg>
                <span class="footer-brand">The Spread Sheet</span>
            </div>
            <div style="font-size:0.7rem;letter-spacing:0.1em;">DATA DON'T LIE</div>
        </footer>
    </div>

    <!-- Share Top 10 Container (hidden, rendered on-demand for capture) -->
    <div class="share-top10-container" id="shareTopTen" aria-hidden="true">
        <!-- Content populated dynamically by renderShareableTop10() -->
    </div>

    <!-- Toast notification for share feedback -->
    <div class="share-toast" id="shareToast" role="status" aria-live="polite"></div>

    <script>
        // ============================================================
        // SPREADSHEET V2.2 - COLLEGE BASKETBALL BETTING MODEL
        // ============================================================
        // 
        // ============================================================
        // SpreadSheetV2 REMOVED  All analysis now routes through
        // SpreadSheetV3Enhanced (below). The V2 IIFE, its backward-
        // compatibility analyzeGame() wrapper, and AdvancedAnalytics
        // were dead code shadowed by the V3Enhanced override.
        //
        // Patch 1 of 5  Modeling audit 2026-02-09
        // ============================================================
        //
        // STUB: Anything that touched SpreadSheetV2.Constants or
        // SpreadSheetV2.Presentation now gets a forward reference
        // that will be populated after SpreadSheetV3Enhanced loads.
        // ============================================================

        const SpreadSheetV2 = null; // sentinel  any accidental reference will throw

// ============================================================
// SPREADSHEET V3.1 - ENHANCED CALIBRATED MODEL
// ============================================================
//
// ENHANCEMENTS OVER V3.0:
//   1. Rest days differential (back-to-back penalty)
//   2. Tempo-adjusted matchup calculations
//   3. Conference strength adjustments
//   4. Recency-weighted ratings
//   5. Travel distance/fatigue factors
//   6. Rivalry game detection
//   7. Situational spots (lookahead, revenge)
//
// These features are proven to have predictive value in
// college basketball betting markets.
// ============================================================

const SpreadSheetV3Enhanced = (function() {
    'use strict';

    const DEBUG = () => window.__debugV3Enhanced === true;
    const log = (...args) => DEBUG() && console.log('[V3Enhanced]', ...args);

    // =========================================================================
    // ENHANCED CONFIGURATION
    // =========================================================================
    let CONFIG = {
        // Base projection parameters
        // Research-backed: Spreads ~10-11 , Totals ~12-18  (Boyd's Bets historical data)
        // Totals have higher variance due to pace/scoring dependencies on both teams
        SPREAD_STD_DEV: 11.0,
        TOTAL_STD_DEV: 13.5,           // Empirical CBB total stddev ~13-14 pts (higher variance than spreads)
        BASE_HCA: 3.2,
        D1_AVG_TEMPO: 67.5,            // D1 avg possessions per game (KenPom 2024-25 baseline)
        D1_AVG_EFF: 100,               // KenPom efficiency baseline

        // REMOVED: MARGIN_MULTIPLIER (was 0.48, under-projected by 52%)
        // Now derived per-game as gamePace / 100 (~0.675 on average)
        //
        // REMOVED: PACE_FACTOR (was 0.70, applied as flat multiplier)
        // Now derived from actual team tempos via multiplicative interaction

        // Calibration parameters
        PLATT_A: 0.85,
        PLATT_B: 0.0,
        SHRINKAGE_FACTOR: 0.06,        // Reduced from 0.20  light regularizer only

        // Market regression: blend model projections toward Vegas lines
        // Vegas lines are highly efficient  large disagreements usually mean model error
        TOTAL_MARKET_WEIGHT: 0.35,     // 35% Vegas, 65% model for totals
        SPREAD_MARKET_WEIGHT: 0.25,    // 25% Vegas, 75% model for spreads
        MAX_TOTAL_EDGE: 12,            // Cap total edge at 12 pts (prevents 90%+ fantasies)
        MAX_SPREAD_EDGE: 10,           // Cap spread edge at 10 pts

        // Feature weights (learned via fitting)
        FEATURE_WEIGHTS: {
            restDays: 0.8,           // Points per rest day advantage
            backToBack: -2.5,        // Penalty for B2B (on top of rest)
            tempoMismatch: 0.15,     // Adjustment per tempo differential point
            conferenceStrength: 1.0, // Weight for conference adjustment
            recencyWeight: 0.65,     // How much to weight recent form (vs season)
            travelFatigue: 0.4,      // Points per 1000 miles traveled
            altitude: 1.2,           // Altitude advantage (Colorado, Utah, etc.)
            rivalry: -1.5,           // Favorite penalty in rivalry games
            revenge: 0.8,            // Boost when facing former team
            lookahead: -1.0,         // Penalty for lookahead spots
        },

        // Probability bounds
        PROB_FLOOR: 0.05,
        PROB_CEILING: 0.95,

        // Kelly parameters
        KELLY_FRACTION: 0.25,
        MAX_BET_FRACTION: 0.03,
        MIN_PROB_EDGE: 0.025,

        // Early-season shrinkage (Patch 4)
        // Equivalent sample size of conference-mean prior.
        // At gamesPlayed=8, team rating and prior are weighted 50/50.
        // By gamesPlayed=25, team data dominates (~76% weight).
        SHRINKAGE_PRIOR: 8,

        // EWM team form (Patch 8)
        // Half-life in days: how quickly older games decay in the form calc.
        // 14 days  last 5-6 games dominate. Blend controls how much
        // the EWM delta (vs season average) adjusts the projection.
        EWM_HALF_LIFE: 14,
        EWM_BLEND: 0.30,           // 0 = ignore form, 1 = fully trust EWM delta

        // State
        isCalibrated: false,
        calibrationSampleSize: 0,
        lastCalibrationDate: null
    };

    // =========================================================================
    // CONFERENCE DATA
    // =========================================================================

    const CONFERENCE_STRENGTH = {
        // Power conferences (positive adjustment for road teams)
        'Big 12': { strength: 1.0, hca: 4.2, difficulty: 1.15 },
        'SEC': { strength: 0.95, hca: 3.9, difficulty: 1.12 },
        'Big Ten': { strength: 0.90, hca: 3.8, difficulty: 1.10 },
        'ACC': { strength: 0.85, hca: 3.6, difficulty: 1.08 },
        'Big East': { strength: 0.80, hca: 3.5, difficulty: 1.05 },
        'Pac-12': { strength: 0.70, hca: 3.4, difficulty: 1.02 },

        // Mid-majors
        'AAC': { strength: 0.50, hca: 3.2, difficulty: 0.95 },
        'Mountain West': { strength: 0.45, hca: 3.3, difficulty: 0.93 },
        'WCC': { strength: 0.40, hca: 3.0, difficulty: 0.90 },
        'Atlantic 10': { strength: 0.35, hca: 3.0, difficulty: 0.88 },
        'MVC': { strength: 0.30, hca: 2.8, difficulty: 0.85 },

        // Low-majors
        'MAC': { strength: 0.15, hca: 2.5, difficulty: 0.80 },
        'CUSA': { strength: 0.15, hca: 2.5, difficulty: 0.80 },
        'Sun Belt': { strength: 0.10, hca: 2.4, difficulty: 0.78 },
        'CAA': { strength: 0.10, hca: 2.4, difficulty: 0.78 },
        'Horizon': { strength: 0.05, hca: 2.3, difficulty: 0.75 },
        'Summit': { strength: 0.00, hca: 2.2, difficulty: 0.73 },
        'Big Sky': { strength: 0.00, hca: 2.2, difficulty: 0.73 },
        'Southland': { strength: -0.05, hca: 2.0, difficulty: 0.70 },
        'OVC': { strength: -0.05, hca: 2.0, difficulty: 0.70 },
        'MAAC': { strength: -0.10, hca: 2.0, difficulty: 0.68 },
        'NEC': { strength: -0.15, hca: 1.8, difficulty: 0.65 },
        'SWAC': { strength: -0.20, hca: 1.8, difficulty: 0.62 },
        'MEAC': { strength: -0.25, hca: 1.5, difficulty: 0.60 },
    };

    // Default for unknown conferences
    const DEFAULT_CONFERENCE = { strength: 0.0, hca: 3.0, difficulty: 0.85 };

    // =========================================================================
    // RIVALRY GAMES (Favorites historically underperform)
    // =========================================================================

    const RIVALRIES = [
        // ACC
        ['Duke', 'North Carolina'], ['Duke', 'UNC'],
        ['Louisville', 'Kentucky'],
        ['Virginia', 'Virginia Tech'],
        ['NC State', 'North Carolina'], ['NC State', 'UNC'],
        ['Wake Forest', 'Duke'],

        // Big Ten
        ['Michigan', 'Michigan State'], ['Michigan', 'Michigan St'],
        ['Indiana', 'Purdue'],
        ['Ohio State', 'Michigan'], ['Ohio St', 'Michigan'],
        ['Illinois', 'Northwestern'],
        ['Iowa', 'Iowa State'], ['Iowa', 'Iowa St'],
        ['Wisconsin', 'Minnesota'],

        // Big 12
        ['Kansas', 'Kansas State'], ['Kansas', 'Kansas St'],
        ['Kansas', 'Missouri'],
        ['Texas', 'Texas Tech'],
        ['Oklahoma', 'Oklahoma State'], ['Oklahoma', 'Oklahoma St'],
        ['Baylor', 'Texas'],
        ['Iowa State', 'Iowa'], ['Iowa St', 'Iowa'],

        // SEC
        ['Kentucky', 'Louisville'],
        ['Auburn', 'Alabama'],
        ['Florida', 'Florida State'], ['Florida', 'Florida St'],
        ['Tennessee', 'Vanderbilt'],
        ['Ole Miss', 'Mississippi State'], ['Ole Miss', 'Mississippi St'],

        // Pac-12
        ['UCLA', 'USC'],
        ['Arizona', 'Arizona State'], ['Arizona', 'Arizona St'],
        ['Oregon', 'Oregon State'], ['Oregon', 'Oregon St'],
        ['Colorado', 'Colorado State'], ['Colorado', 'Colorado St'],

        // Big East
        ['Georgetown', 'Syracuse'],
        ['Villanova', 'Georgetown'],
        ['UConn', 'Syracuse'],
        ['St. John\'s', 'Seton Hall'],

        // Other notable
        ['Gonzaga', 'Saint Mary\'s'],
        ['Cincinnati', 'Xavier'],
        ['Memphis', 'Tennessee'],
    ];

    // =========================================================================
    // TEAM LOCATIONS (for travel distance calculations)
    // =========================================================================

    const TEAM_LOCATIONS = {
        // ACC
        'Duke': { lat: 35.9940, lon: -78.9426, altitude: 400 },
        'North Carolina': { lat: 35.9049, lon: -79.0469, altitude: 500 },
        'UNC': { lat: 35.9049, lon: -79.0469, altitude: 500 },
        'Virginia': { lat: 38.0336, lon: -78.5080, altitude: 480 },
        'Louisville': { lat: 38.2178, lon: -85.7587, altitude: 460 },
        'Wake Forest': { lat: 36.1345, lon: -80.2772, altitude: 900 },
        'NC State': { lat: 35.7847, lon: -78.6699, altitude: 400 },
        'Florida State': { lat: 30.4419, lon: -84.2985, altitude: 200 },
        'Florida St': { lat: 30.4419, lon: -84.2985, altitude: 200 },
        'Miami': { lat: 25.7157, lon: -80.2790, altitude: 10 },
        'Syracuse': { lat: 43.0362, lon: -76.1336, altitude: 400 },
        'Boston College': { lat: 42.3355, lon: -71.1685, altitude: 50 },
        'Clemson': { lat: 34.6776, lon: -82.8374, altitude: 850 },
        'Georgia Tech': { lat: 33.7756, lon: -84.3963, altitude: 1000 },
        'Notre Dame': { lat: 41.7052, lon: -86.2353, altitude: 720 },
        'Pittsburgh': { lat: 40.4443, lon: -79.9608, altitude: 1200 },
        'Virginia Tech': { lat: 37.2296, lon: -80.4139, altitude: 2100 },

        // Big Ten
        'Michigan': { lat: 42.2659, lon: -83.7485, altitude: 880 },
        'Michigan State': { lat: 42.7251, lon: -84.4791, altitude: 840 },
        'Michigan St': { lat: 42.7251, lon: -84.4791, altitude: 840 },
        'Ohio State': { lat: 40.0067, lon: -83.0305, altitude: 760 },
        'Ohio St': { lat: 40.0067, lon: -83.0305, altitude: 760 },
        'Indiana': { lat: 39.1793, lon: -86.5129, altitude: 760 },
        'Purdue': { lat: 40.4432, lon: -86.9290, altitude: 620 },
        'Illinois': { lat: 40.0964, lon: -88.2357, altitude: 740 },
        'Iowa': { lat: 41.6627, lon: -91.5550, altitude: 680 },
        'Wisconsin': { lat: 43.0695, lon: -89.4121, altitude: 860 },
        'Minnesota': { lat: 44.9727, lon: -93.2277, altitude: 840 },
        'Northwestern': { lat: 42.0565, lon: -87.6753, altitude: 600 },
        'Nebraska': { lat: 40.8202, lon: -96.7005, altitude: 1180 },
        'Maryland': { lat: 38.9869, lon: -76.9426, altitude: 140 },
        'Rutgers': { lat: 40.5018, lon: -74.4479, altitude: 100 },
        'Penn State': { lat: 40.8123, lon: -77.8559, altitude: 1200 },
        'Penn St': { lat: 40.8123, lon: -77.8559, altitude: 1200 },

        // Big 12
        'Kansas': { lat: 38.9543, lon: -95.2558, altitude: 1020 },
        'Kansas State': { lat: 39.2014, lon: -96.5946, altitude: 1060 },
        'Kansas St': { lat: 39.2014, lon: -96.5946, altitude: 1060 },
        'Baylor': { lat: 31.5585, lon: -97.1164, altitude: 470 },
        'Texas': { lat: 30.2849, lon: -97.7341, altitude: 500 },
        'Texas Tech': { lat: 33.5843, lon: -101.8783, altitude: 3200 },
        'TCU': { lat: 32.7096, lon: -97.3631, altitude: 650 },
        'Oklahoma': { lat: 35.2058, lon: -97.4457, altitude: 1200 },
        'Oklahoma State': { lat: 36.1261, lon: -97.0712, altitude: 900 },
        'Oklahoma St': { lat: 36.1261, lon: -97.0712, altitude: 900 },
        'Iowa State': { lat: 42.0140, lon: -93.6358, altitude: 940 },
        'Iowa St': { lat: 42.0140, lon: -93.6358, altitude: 940 },
        'West Virginia': { lat: 39.6480, lon: -79.9676, altitude: 960 },
        'Cincinnati': { lat: 39.1329, lon: -84.5150, altitude: 480 },
        'Houston': { lat: 29.7199, lon: -95.3422, altitude: 50 },
        'UCF': { lat: 28.6024, lon: -81.2001, altitude: 80 },
        'BYU': { lat: 40.2518, lon: -111.6493, altitude: 4550 },
        'Arizona': { lat: 32.2319, lon: -110.9501, altitude: 2400 },
        'Arizona State': { lat: 33.4242, lon: -111.9281, altitude: 1100 },
        'Arizona St': { lat: 33.4242, lon: -111.9281, altitude: 1100 },
        'Colorado': { lat: 40.0076, lon: -105.2659, altitude: 5430 },
        'Utah': { lat: 40.7649, lon: -111.8421, altitude: 4330 },

        // SEC
        'Kentucky': { lat: 38.0278, lon: -84.5049, altitude: 980 },
        'Tennessee': { lat: 35.9544, lon: -83.9295, altitude: 900 },
        'Auburn': { lat: 32.6035, lon: -85.4898, altitude: 700 },
        'Alabama': { lat: 33.2140, lon: -87.5391, altitude: 220 },
        'Florida': { lat: 29.6499, lon: -82.3486, altitude: 170 },
        'Georgia': { lat: 33.9480, lon: -83.3773, altitude: 700 },
        'LSU': { lat: 30.4123, lon: -91.1837, altitude: 60 },
        'Arkansas': { lat: 36.0672, lon: -94.1785, altitude: 1400 },
        'Ole Miss': { lat: 34.3619, lon: -89.5343, altitude: 500 },
        'Mississippi State': { lat: 33.4561, lon: -88.7954, altitude: 280 },
        'Mississippi St': { lat: 33.4561, lon: -88.7954, altitude: 280 },
        'South Carolina': { lat: 33.9932, lon: -81.0289, altitude: 300 },
        'Missouri': { lat: 38.9404, lon: -92.3277, altitude: 760 },
        'Vanderbilt': { lat: 36.1447, lon: -86.8027, altitude: 600 },
        'Texas A&M': { lat: 30.6122, lon: -96.3408, altitude: 320 },

        // Big East
        'UConn': { lat: 41.8075, lon: -72.2540, altitude: 640 },
        'Villanova': { lat: 40.0378, lon: -75.3458, altitude: 410 },
        'Creighton': { lat: 41.2656, lon: -96.0109, altitude: 1040 },
        'Marquette': { lat: 43.0389, lon: -87.9308, altitude: 620 },
        'Xavier': { lat: 39.1489, lon: -84.4734, altitude: 550 },
        'Georgetown': { lat: 38.9076, lon: -77.0723, altitude: 70 },
        'Providence': { lat: 41.8395, lon: -71.4352, altitude: 50 },
        'St. John\'s': { lat: 40.7232, lon: -73.7949, altitude: 80 },
        'Seton Hall': { lat: 40.7423, lon: -74.2440, altitude: 180 },
        'Butler': { lat: 39.8403, lon: -86.1689, altitude: 720 },
        'DePaul': { lat: 41.9239, lon: -87.6555, altitude: 590 },

        // Other notable
        'Gonzaga': { lat: 47.6662, lon: -117.4050, altitude: 1940 },
        'Saint Mary\'s': { lat: 37.8407, lon: -122.1088, altitude: 50 },
        'San Diego State': { lat: 32.7749, lon: -117.0719, altitude: 420 },
        'San Diego St': { lat: 32.7749, lon: -117.0719, altitude: 420 },
        'Memphis': { lat: 35.1182, lon: -89.9372, altitude: 280 },
        'SMU': { lat: 32.8430, lon: -96.7851, altitude: 470 },
        'Dayton': { lat: 39.7401, lon: -84.1796, altitude: 740 },
        'VCU': { lat: 37.5486, lon: -77.4530, altitude: 160 },
        'Saint Louis': { lat: 38.6370, lon: -90.2340, altitude: 460 },
        'St. Bonaventure': { lat: 42.0821, lon: -78.4826, altitude: 1540 },
    };

    // =========================================================================
    // MATH UTILITIES
    // =========================================================================

    /**
     * Derive expected game pace from team tempos.
     * Returns D1 average (67.5) when no tempo data available.
     * Used by both spread and total projections to replace
     * the old static MARGIN_MULTIPLIER and PACE_FACTOR.
     */
    function getGamePace(context) {
        const avg = CONFIG.D1_AVG_TEMPO;
        if (context.homePace && context.awayPace) {
            return (context.homePace + context.awayPace) / 2;
        }
        if (context.homePace) return (context.homePace + avg) / 2;
        if (context.awayPace) return (avg + context.awayPace) / 2;
        return avg;
    }

    function normalCDF(x) {
        const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
        const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
        const sign = x < 0 ? -1 : 1;
        const absX = Math.abs(x) / Math.SQRT2;
        const t = 1.0 / (1.0 + p * absX);
        const poly = ((((a5 * t + a4) * t + a3) * t + a2) * t + a1);
        const y = 1.0 - poly * t * Math.exp(-absX * absX);
        return 0.5 * (1.0 + sign * y);
    }

    function logit(p) {
        p = Math.max(1e-10, Math.min(1 - 1e-10, p));
        return Math.log(p / (1 - p));
    }

    function sigmoid(x) {
        if (x > 500) return 1;
        if (x < -500) return 0;
        return 1 / (1 + Math.exp(-x));
    }

    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Haversine distance between two lat/lon points (in miles)
     */
    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 3959; // Earth's radius in miles
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // =========================================================================
    // FEATURE CALCULATIONS
    // =========================================================================

    /**
     * Calculate rest days advantage
     * @param {number} homeRestDays - Days since home team's last game
     * @param {number} awayRestDays - Days since away team's last game
     * @returns {object} Rest adjustment details
     */
    function calculateRestAdvantage(homeRestDays, awayRestDays) {
        // Default to 2 days if not provided (typical schedule)
        homeRestDays = homeRestDays != null ? homeRestDays : 2;
        awayRestDays = awayRestDays != null ? awayRestDays : 2;

        // Cap at 7 days (diminishing returns after a week)
        homeRestDays = Math.min(homeRestDays, 7);
        awayRestDays = Math.min(awayRestDays, 7);

        const restDiff = homeRestDays - awayRestDays;
        let adjustment = restDiff * CONFIG.FEATURE_WEIGHTS.restDays;

        // Extra penalty for back-to-back (0 or 1 days rest)
        const homeB2B = homeRestDays <= 1;
        const awayB2B = awayRestDays <= 1;

        if (awayB2B && !homeB2B) {
            adjustment += Math.abs(CONFIG.FEATURE_WEIGHTS.backToBack);
        } else if (homeB2B && !awayB2B) {
            adjustment -= Math.abs(CONFIG.FEATURE_WEIGHTS.backToBack);
        }

        return {
            homeRestDays,
            awayRestDays,
            restDiff,
            homeB2B,
            awayB2B,
            adjustment,
            description: homeB2B ? 'Home B2B' : awayB2B ? 'Away B2B' :
                         restDiff > 1 ? `Home +${restDiff} rest` :
                         restDiff < -1 ? `Away +${-restDiff} rest` : 'Even rest'
        };
    }

    /**
     * Calculate tempo mismatch adjustment
     * Fast vs slow teams create systematic biases
     */
    function calculateTempoAdjustment(homePace, awayPace, isTotal = false) {
        // Default paces if not provided (D1 average is ~68)
        homePace = homePace || 68;
        awayPace = awayPace || 68;

        const avgPace = (homePace + awayPace) / 2;
        const paceDiff = Math.abs(homePace - awayPace);

        let spreadAdj = 0;
        let totalAdj = 0;

        // Fast vs slow matchups: the slower team often controls pace
        // This can cause unders to hit more often
        if (paceDiff > 5) {
            // Significant pace mismatch
            const slowerPace = Math.min(homePace, awayPace);

            // Total adjustment: game plays closer to slower team's pace
            // Markets often overestimate totals in these spots
            totalAdj = (68 - slowerPace) * 0.3; // Negative = lean under

            // Spread adjustment: faster team may struggle
            const fasterTeamHome = homePace > awayPace;
            if (fasterTeamHome) {
                spreadAdj = -0.5; // Fast team at home vs slow team
            } else {
                spreadAdj = 0.5;  // Slow team at home vs fast team
            }
        }

        // High-paced games have more variance
        const varianceMultiplier = avgPace > 72 ? 1.05 : avgPace < 64 ? 0.95 : 1.0;

        return {
            homePace,
            awayPace,
            avgPace,
            paceDiff,
            spreadAdjustment: spreadAdj,
            totalAdjustment: totalAdj,
            varianceMultiplier,
            description: paceDiff > 5 ? 'Pace mismatch' : 'Similar tempos'
        };
    }

    /**
     * Calculate conference strength adjustment
     */
    /**
     * Conference adjustment (Patch 3: simplified)
     *
     * KenPom ratings already account for strength of schedule, so the
     * cross-conference strength adjustment was double-counting.
     * Conference-specific HCA values were unvalidated  replaced with
     * a single CONFIG.BASE_HCA applied uniformly.
     */
    function calculateConferenceAdjustment(homeConf, awayConf, isNeutral = false) {
        const homeConfData = CONFERENCE_STRENGTH[homeConf] || DEFAULT_CONFERENCE;
        const awayConfData = CONFERENCE_STRENGTH[awayConf] || DEFAULT_CONFERENCE;
        const isConfGame = homeConf === awayConf;

        // Single HCA value  no per-conference override (KenPom already adjusts)
        const dynamicHCA = isNeutral ? 0 : CONFIG.BASE_HCA;

        // Cross-conference adjustment removed (was double-counting SOS)
        const crossConfAdj = 0;

        return {
            homeConference: homeConf,
            awayConference: awayConf,
            isConferenceGame: isConfGame,
            homeStrength: homeConfData.strength,
            awayStrength: awayConfData.strength,
            dynamicHCA,
            crossConfAdjustment: crossConfAdj,
            homeDifficulty: homeConfData.difficulty,
            awayDifficulty: awayConfData.difficulty
        };
    }

    // =========================================================================
    // EWM TEAM FORM (Patch 8)
    // =========================================================================

    /**
     * Exponentially weighted moving average of team performance.
     *
     * Uses a half-life approach: recent games count more, older games decay.
     * This replaces the crude last5/last10 blend with a smooth decay that
     * naturally handles uneven schedules (bye weeks, postponements).
     *
     * Input: array of recent game results sorted most-recent-first:
     *   [{ netMargin: 12, daysAgo: 1 }, { netMargin: -5, daysAgo: 4 }, ...]
     *
     * netMargin = team's actual scoring margin that game (positive = win).
     * daysAgo = days between that game and the current prediction date.
     *
     * @param {Array} recentGameResults  [{netMargin, daysAgo}] most-recent-first
     * @param {number} halfLife  days for weight to halve (default CONFIG.EWM_HALF_LIFE)
     * @returns {number|null} weighted average net margin, or null if no data
     */
    function ewmTeamForm(recentGameResults, halfLife) {
        if (!recentGameResults || recentGameResults.length === 0) return null;

        halfLife = halfLife || CONFIG.EWM_HALF_LIFE || 14;
        const lambda = Math.LN2 / halfLife;
        let weightedSum = 0;
        let weightSum = 0;

        for (const game of recentGameResults) {
            if (typeof game.netMargin !== 'number' || typeof game.daysAgo !== 'number') continue;
            const w = Math.exp(-lambda * Math.max(0, game.daysAgo));
            weightedSum += w * game.netMargin;
            weightSum += w;
        }

        return weightSum > 0 ? weightedSum / weightSum : null;
    }

    /**
     * Calculate recency-weighted ratings
     * More recent performance is weighted higher
     */
    function calculateRecencyAdjustedRatings(team, recentForm = null) {
        // recentForm should be { last5NetRating, last10NetRating } or similar
        if (!recentForm || !team) {
            return {
                adjustedNetRating: team?.netRating || 0,
                adjustedOffRating: team?.offRating || 100,
                adjustedDefRating: team?.defRating || 100,
                formTrend: 'unknown'
            };
        }

        const seasonNet = team.netRating || 0;
        const recentNet = recentForm.last5NetRating || recentForm.recentNetRating || seasonNet;

        // Weighted average: recent form gets more weight
        const weight = CONFIG.FEATURE_WEIGHTS.recencyWeight;
        const adjustedNet = weight * recentNet + (1 - weight) * seasonNet;

        // Determine trend
        const diff = recentNet - seasonNet;
        let trend = 'stable';
        if (diff > 3) trend = 'hot';
        else if (diff > 1) trend = 'improving';
        else if (diff < -3) trend = 'cold';
        else if (diff < -1) trend = 'declining';

        return {
            seasonNetRating: seasonNet,
            recentNetRating: recentNet,
            adjustedNetRating: adjustedNet,
            adjustedOffRating: team.offRating, // Could also weight these
            adjustedDefRating: team.defRating,
            formTrend: trend,
            trendValue: diff
        };
    }

    /**
     * Calculate travel fatigue adjustment
     */
    function calculateTravelFatigue(homeTeam, awayTeam, awayPreviousLocation = null) {
        const homeLoc = TEAM_LOCATIONS[homeTeam];
        const awayLoc = TEAM_LOCATIONS[awayTeam];

        if (!homeLoc || !awayLoc) {
            return {
                distance: 0,
                travelAdjustment: 0,
                altitudeAdjustment: 0,
                totalAdjustment: 0,
                description: 'Location unknown'
            };
        }

        // Distance from away team's home to game location
        const distance = haversineDistance(awayLoc.lat, awayLoc.lon, homeLoc.lat, homeLoc.lon);

        // If we know where away team was previously, calculate total recent travel
        let totalTravel = distance;
        if (awayPreviousLocation) {
            const prevLoc = TEAM_LOCATIONS[awayPreviousLocation];
            if (prevLoc) {
                const prevDistance = haversineDistance(prevLoc.lat, prevLoc.lon, homeLoc.lat, homeLoc.lon);
                totalTravel = Math.max(distance, prevDistance); // Use worse case
            }
        }

        // Travel fatigue: significant over 1500 miles
        let travelAdj = 0;
        if (totalTravel > 1500) {
            travelAdj = (totalTravel / 1000) * CONFIG.FEATURE_WEIGHTS.travelFatigue;
            travelAdj = Math.min(travelAdj, 2.5); // Cap at 2.5 points
        }

        // Altitude adjustment (affects visitors to high-altitude venues)
        let altitudeAdj = 0;
        if (homeLoc.altitude > 4000 && awayLoc.altitude < 2000) {
            altitudeAdj = CONFIG.FEATURE_WEIGHTS.altitude;
        } else if (homeLoc.altitude > 3000 && awayLoc.altitude < 1000) {
            altitudeAdj = CONFIG.FEATURE_WEIGHTS.altitude * 0.6;
        }

        return {
            distance: Math.round(distance),
            totalTravel: Math.round(totalTravel),
            homeAltitude: homeLoc.altitude,
            awayAltitude: awayLoc.altitude,
            travelAdjustment: travelAdj,
            altitudeAdjustment: altitudeAdj,
            totalAdjustment: travelAdj + altitudeAdj,
            description: distance > 2000 ? 'Long travel' :
                         distance > 1000 ? 'Moderate travel' : 'Short travel'
        };
    }

    /**
     * Check if this is a rivalry game
     */
    function isRivalryGame(homeTeam, awayTeam) {
        const homeNorm = homeTeam.toLowerCase().replace(/[^a-z]/g, '');
        const awayNorm = awayTeam.toLowerCase().replace(/[^a-z]/g, '');

        for (const [team1, team2] of RIVALRIES) {
            const t1 = team1.toLowerCase().replace(/[^a-z]/g, '');
            const t2 = team2.toLowerCase().replace(/[^a-z]/g, '');

            if ((homeNorm.includes(t1) || t1.includes(homeNorm)) &&
                (awayNorm.includes(t2) || t2.includes(awayNorm))) {
                return true;
            }
            if ((homeNorm.includes(t2) || t2.includes(homeNorm)) &&
                (awayNorm.includes(t1) || t1.includes(awayNorm))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Calculate rivalry adjustment (favorites tend to underperform)
     */
    function calculateRivalryAdjustment(homeTeam, awayTeam, projectedMargin) {
        const isRivalry = isRivalryGame(homeTeam, awayTeam);

        if (!isRivalry) {
            return { isRivalry: false, adjustment: 0 };
        }

        // In rivalry games, the favorite tends to underperform
        // Shrink the projected margin toward 0
        let adjustment = 0;
        if (Math.abs(projectedMargin) > 3) {
            // Favorite should give up some points
            adjustment = projectedMargin > 0
                ? CONFIG.FEATURE_WEIGHTS.rivalry
                : -CONFIG.FEATURE_WEIGHTS.rivalry;
        }

        return {
            isRivalry: true,
            adjustment,
            description: 'Rivalry game - favorites historically underperform'
        };
    }

    /**
     * Detect lookahead spot (big game coming up)
     */
    function calculateLookaheadAdjustment(team, nextOpponent, nextOpponentRank) {
        // If next game is against a top-25 team or major rival
        if (!nextOpponent || !nextOpponentRank) {
            return { isLookahead: false, adjustment: 0 };
        }

        const isLookahead = nextOpponentRank <= 25;

        return {
            isLookahead,
            nextOpponent,
            nextOpponentRank,
            adjustment: isLookahead ? CONFIG.FEATURE_WEIGHTS.lookahead : 0,
            description: isLookahead ? `Possible lookahead to ${nextOpponent}` : null
        };
    }

    // =========================================================================
    // CALIBRATION (Same as V3, but with feature-adjusted projections)
    // =========================================================================

    function plattCalibrate(rawProb) {
        const logitP = logit(rawProb);
        const calibratedLogit = CONFIG.PLATT_A * logitP + CONFIG.PLATT_B;
        return sigmoid(calibratedLogit);
    }

    function applyShrinkage(prob) {
        return (1 - CONFIG.SHRINKAGE_FACTOR) * prob + CONFIG.SHRINKAGE_FACTOR * 0.5;
    }

    function calibrateProbability(rawProb) {
        if (CONFIG.isCalibrated) {
            // Platt scaling is the principled calibration  sufficient on its own.
            // Light shrinkage (6%) adds mild regularization without destroying signal.
            let p = plattCalibrate(rawProb);
            p = applyShrinkage(p);
            return clamp(p, CONFIG.PROB_FLOOR, CONFIG.PROB_CEILING);
        }
        // No calibration data: use shrinkage alone as a conservative prior
        return clamp(applyShrinkage(rawProb), CONFIG.PROB_FLOOR, CONFIG.PROB_CEILING);
    }

    // =========================================================================
    // ENHANCED PROJECTION WITH ALL FEATURES
    // =========================================================================

    // =========================================================================
    // EARLY-SEASON SHRINKAGE (Patch 4)
    // =========================================================================

    /**
     * Bayesian shrinkage: pull team ratings toward conference mean
     * based on games played. Stabilises volatile early-season estimates.
     *
     * weight = gamesPlayed / (gamesPlayed + priorStrength)
     *    gamesPlayed = 0   weight = 0   (100% prior)
     *    gamesPlayed = 8   weight = 0.5 (50/50)
     *    gamesPlayed = 25  weight = 0.76
     */
    function shrinkRating(teamRating, conferenceMean, gamesPlayed, priorStrength) {
        priorStrength = priorStrength || CONFIG.SHRINKAGE_PRIOR;
        gamesPlayed = gamesPlayed || 25; // default = mid-season (minimal shrinkage)
        const weight = gamesPlayed / (gamesPlayed + priorStrength);
        return weight * teamRating + (1 - weight) * conferenceMean;
    }

    /**
     * Compute conference average net rating from the CONFERENCE_STRENGTH table.
     * Returns a rough centre for shrinkage  the exact number matters less
     * than having *some* pull toward centre for small-sample teams.
     *
     * Power conferences  positive mean, low-majors  near/below zero.
     */
    function getConferenceMean(conference) {
        const conf = CONFERENCE_STRENGTH[conference];
        if (!conf) return 0; // unknown conference  shrink toward league average
        // Map strength (0.25  1.0) to a net-rating proxy (5  +10)
        return conf.strength * 10;
    }

    // =========================================================================
    // ENHANCED PROJECTION WITH ALL FEATURES
    // =========================================================================

    /**
     * Project spread with all feature adjustments
     */
    function projectSpreadEnhanced(home, away, context = {}) {
        // Apply early-season shrinkage (Patch 4)
        const homeNet = shrinkRating(
            home.netRating,
            getConferenceMean(home.conference),
            home.gamesPlayed
        );
        const awayNet = shrinkRating(
            away.netRating,
            getConferenceMean(away.conference),
            away.gamesPlayed
        );

        // Derive per-game margin multiplier from actual tempo
        // KenPom ratings are per-100-possessions; multiply by possessions/100
        // to convert to expected game points. D1 avg ~67.5  multiplier ~0.675
        const gamePace = getGamePace(context);
        const paceMultiplier = gamePace / 100;

        let margin = (homeNet - awayNet) * paceMultiplier;

        // DEBUG: Log spread calculation (first 3 games)
        if (!window.__spreadDebugCount) window.__spreadDebugCount = 0;
        if (window.__spreadDebugCount < 3) {
            console.log(`[projectSpreadEnhanced] ${home.name} vs ${away.name}: rawNet=${home.netRating}/${away.netRating}, shrunkNet=${homeNet.toFixed(1)}/${awayNet.toFixed(1)}, pace=${gamePace.toFixed(1)}, mult=${paceMultiplier.toFixed(3)}, baseMargin=${margin.toFixed(1)}`);
            window.__spreadDebugCount++;
        }

        // Get conference data for dynamic HCA
        const confAdj = calculateConferenceAdjustment(
            home.conference,
            away.conference,
            context.isNeutral
        );
        margin += confAdj.dynamicHCA;
        margin += confAdj.crossConfAdjustment;

        // Rest advantage
        if (context.homeRestDays != null || context.awayRestDays != null) {
            const restAdj = calculateRestAdvantage(context.homeRestDays, context.awayRestDays);
            margin += restAdj.adjustment;
        }

        // Travel fatigue
        if (home.name && away.name) {
            const travelAdj = calculateTravelFatigue(home.name, away.name, context.awayPreviousGame);
            margin += travelAdj.totalAdjustment;
        }

        // Rivalry adjustment
        if (home.name && away.name) {
            const rivalryAdj = calculateRivalryAdjustment(home.name, away.name, margin);
            margin += rivalryAdj.adjustment;
        }

        // Tempo mismatch adjustment (for spread)
        // When pace differs significantly, the slower team tends to control tempo,
        // which can disrupt the faster team's rhythm
        if (context.homePace && context.awayPace) {
            const paceDiff = Math.abs(context.homePace - context.awayPace);
            if (paceDiff > 5) {
                const fasterTeamHome = context.homePace > context.awayPace;
                // Faster team at home gets slight penalty (opponent slows them)
                // Slower team at home gets slight boost (controls pace)
                margin += fasterTeamHome ? -0.5 : 0.5;
            }
        }

        // Lookahead adjustment
        if (context.homeNextOpponent || context.awayNextOpponent) {
            if (margin > 3 && context.homeNextOpponentRank <= 25) {
                margin += CONFIG.FEATURE_WEIGHTS.lookahead;
            }
            if (margin < -3 && context.awayNextOpponentRank <= 25) {
                margin -= CONFIG.FEATURE_WEIGHTS.lookahead;
            }
        }

        // Recency / form adjustment (Patch 8: prefer EWM over legacy blend)
        //
        // Priority: EWM game-level data  legacy recentForm  skip
        // The form delta is converted to game points using paceMultiplier.
        {
            let homeFormAdj = 0;
            let awayFormAdj = 0;

            // Home team form
            if (context.homeRecentGames && context.homeRecentGames.length >= 3) {
                const ewm = ewmTeamForm(context.homeRecentGames);
                if (ewm !== null) {
                    homeFormAdj = (ewm - (home.netRating || 0)) * CONFIG.EWM_BLEND;
                }
            } else if (context.homeRecentForm) {
                const homeRecency = calculateRecencyAdjustedRatings(home, context.homeRecentForm);
                homeFormAdj = (homeRecency.adjustedNetRating - home.netRating) * 0.5;
            }

            // Away team form
            if (context.awayRecentGames && context.awayRecentGames.length >= 3) {
                const ewm = ewmTeamForm(context.awayRecentGames);
                if (ewm !== null) {
                    awayFormAdj = (ewm - (away.netRating || 0)) * CONFIG.EWM_BLEND;
                }
            } else if (context.awayRecentForm) {
                const awayRecency = calculateRecencyAdjustedRatings(away, context.awayRecentForm);
                awayFormAdj = (awayRecency.adjustedNetRating - away.netRating) * 0.5;
            }

            margin += homeFormAdj * paceMultiplier;
            margin -= awayFormAdj * paceMultiplier;
        }

        // DEBUG: Log final spread (first 3 games)
        if (!window.__spreadDebugCount2) window.__spreadDebugCount2 = 0;
        if (window.__spreadDebugCount2 < 3) {
            console.log(`[projectSpreadEnhanced] ${home.name} vs ${away.name}: FINAL margin=${margin.toFixed(1)}, projectedSpread=${(-margin).toFixed(1)}`);
            window.__spreadDebugCount2++;
        }

        return -margin; // Convert to spread format
    }

    /**
     * Project total with feature adjustments
     */
    function projectTotalEnhanced(home, away, context = {}) {
        // Apply early-season shrinkage to off/def ratings (Patch 4)
        const homeOff = shrinkRating(home.offRating, 100, home.gamesPlayed);
        const homeDef = shrinkRating(home.defRating, 100, home.gamesPlayed);
        const awayOff = shrinkRating(away.offRating, 100, away.gamesPlayed);
        const awayDef = shrinkRating(away.defRating, 100, away.gamesPlayed);

        const D1 = CONFIG.D1_AVG_EFF; // 100

        // MATCHUP-SPECIFIC expected efficiency (multiplicative interaction):
        // "How does THIS offense perform vs THAT defense?"
        //
        // If homeOff=110 (10% above avg) and awayDef=95 (5% below avg, i.e. good D),
        // expected efficiency = 110 * 95 / 100 = 104.5
        //
        // This captures the INTERACTION between specific units rather than
        // averaging them away. Two elite offenses vs two bad defenses produces
        // a much higher total than the old formula allowed.
        const homeExpEff = homeOff * awayDef / D1;
        const awayExpEff = awayOff * homeDef / D1;

        // Expected game pace from team tempos
        const gamePace = getGamePace(context);

        // Total = (combined efficiency) * (possessions / 100)
        let total = (homeExpEff + awayExpEff) * gamePace / 100;

        // Pace mismatch drag: when tempos differ significantly, the slower
        // team tends to control pace. Drag the estimate toward slower tempo.
        if (context.homePace && context.awayPace) {
            const paceDiff = Math.abs(context.homePace - context.awayPace);
            if (paceDiff > 4) {
                const slowerPace = Math.min(context.homePace, context.awayPace);
                const dragFactor = Math.min(0.3, paceDiff * 0.03);
                const adjustedPace = gamePace * (1 - dragFactor) + slowerPace * dragFactor;
                total = (homeExpEff + awayExpEff) * adjustedPace / 100;
            }
        }

        // Travel can lead to tired legs and lower scoring
        if (home.name && away.name) {
            const travelAdj = calculateTravelFatigue(home.name, away.name);
            if (travelAdj.distance > 2000) {
                total -= 1.5;
            }
        }

        // Back-to-back games can affect scoring
        if (context.homeRestDays != null || context.awayRestDays != null) {
            const restAdj = calculateRestAdvantage(context.homeRestDays, context.awayRestDays);
            if (restAdj.homeB2B || restAdj.awayB2B) {
                total -= 1.0;
            }
        }

        return total;
    }

    function calculateEdge(projected, vegas, type) {
        if (type === 'spread') {
            return vegas - projected;
        } else {
            return projected - vegas;
        }
    }

    // =========================================================================
    // MAIN ANALYSIS FUNCTION (ENHANCED)
    // =========================================================================

    /**
     * Analyze game with all enhanced features
     *
     * @param {object} home - Home team { name, netRating, offRating, defRating, conference, rank }
     * @param {object} away - Away team { name, netRating, offRating, defRating, conference, rank }
     * @param {number} vegasSpread - Vegas spread line
     * @param {number} vegasTotal - Vegas total line
     * @param {object} context - Optional context with additional features:
     *   - homeRestDays, awayRestDays: Days since last game
     *   - homePace, awayPace: Team tempo (possessions per game)
     *   - isNeutral: Is this a neutral site game?
     *   - homeRecentForm, awayRecentForm: Recent performance { last5NetRating }
     *   - awayPreviousGame: Where away team played last (for travel calculation)
     *   - homeNextOpponent, awayNextOpponent: Next game opponent (lookahead)
     *   - homeNextOpponentRank, awayNextOpponentRank: Next opponent's rank
     */
    function analyze(home, away, vegasSpread, vegasTotal, context = {}) {
        const odds = context.odds || -110;

        // Validation
        if (!home || !away) {
            return { error: 'Missing team ratings', hasData: false };
        }

        if (!validateRatings(home) || !validateRatings(away)) {
            return { error: 'Invalid team ratings', hasData: false };
        }

        if (vegasSpread == null || vegasTotal == null) {
            const projectedSpread = projectSpreadEnhanced(home, away, context);
            const projectedTotal = projectTotalEnhanced(home, away, context);
            return {
                hasData: true,
                projection: { spread: projectedSpread, total: projectedTotal },
                spread: null,
                total: null,
                noVegasLines: true
            };
        }

        // Enhanced projections with all features
        const projectedSpread = projectSpreadEnhanced(home, away, context);
        const projectedTotal = projectTotalEnhanced(home, away, context);
        const spreadEdge = calculateEdge(projectedSpread, vegasSpread, 'spread');
        const totalEdge = calculateEdge(projectedTotal, vegasTotal, 'total');

        // Market regression: blend model projection toward Vegas
        // Vegas lines are efficient  large model disagreements are usually model error
        const regressedSpread = projectedSpread * (1 - CONFIG.SPREAD_MARKET_WEIGHT) + vegasSpread * CONFIG.SPREAD_MARKET_WEIGHT;
        const regressedTotal = projectedTotal * (1 - CONFIG.TOTAL_MARKET_WEIGHT) + vegasTotal * CONFIG.TOTAL_MARKET_WEIGHT;
        const regressedSpreadEdge = calculateEdge(regressedSpread, vegasSpread, 'spread');
        const regressedTotalEdge = calculateEdge(regressedTotal, vegasTotal, 'total');

        // Cap edges to prevent absurd probabilities
        const cappedSpreadEdge = Math.max(-CONFIG.MAX_SPREAD_EDGE, Math.min(CONFIG.MAX_SPREAD_EDGE, regressedSpreadEdge));
        const cappedTotalEdge = Math.max(-CONFIG.MAX_TOTAL_EDGE, Math.min(CONFIG.MAX_TOTAL_EDGE, regressedTotalEdge));

        // Get tempo adjustment for variance
        const tempoAdj = calculateTempoAdjustment(context.homePace, context.awayPace);
        const adjustedSpreadStdDev = CONFIG.SPREAD_STD_DEV * tempoAdj.varianceMultiplier;
        const adjustedTotalStdDev = CONFIG.TOTAL_STD_DEV * tempoAdj.varianceMultiplier;

        // Calculate probabilities with adjusted variance using regressed edges
        const rawHomeCoverProb = normalCDF(cappedSpreadEdge / adjustedSpreadStdDev);
        const homeCoverProb = calibrateProbability(rawHomeCoverProb);
        const awayCoverProb = 1 - homeCoverProb;

        const rawOverProb = normalCDF(cappedTotalEdge / adjustedTotalStdDev);
        const overProb = calibrateProbability(rawOverProb);
        const underProb = 1 - overProb;

        // Determine picks (use raw edge direction, regressed probabilities)
        const spreadPickSide = spreadEdge >= 0 ? 'home' : 'away';
        const spreadPickProb = spreadEdge >= 0 ? homeCoverProb : awayCoverProb;
        const spreadPickLine = spreadEdge >= 0 ? vegasSpread : -vegasSpread;
        const spreadPickTeam = spreadEdge >= 0 ? home.name : away.name;

        const totalPickSide = totalEdge >= 0 ? 'over' : 'under';
        const totalPickProb = totalEdge >= 0 ? overProb : underProb;

        // Kelly sizing
        const spreadBetSize = calculateKelly(spreadPickProb, odds);
        const totalBetSize = calculateKelly(totalPickProb, odds);

        // Collect feature details for transparency
        const features = collectFeatureDetails(home, away, context, projectedSpread);

        return {
            hasData: true,
            projection: {
                spread: regressedSpread,
                total: regressedTotal,
                rawSpread: projectedSpread,
                rawTotal: projectedTotal,
                baseSpread: (home.netRating - away.netRating) * (getGamePace(context) / 100) + CONFIG.BASE_HCA
            },
            spread: {
                edge: Math.abs(cappedSpreadEdge),
                side: spreadPickSide,
                line: spreadPickLine,
                team: spreadPickTeam,
                probability: spreadPickProb,
                betSize: spreadBetSize,
                rawProbability: spreadEdge >= 0 ? rawHomeCoverProb : 1 - rawHomeCoverProb,
                rawEdge: Math.abs(spreadEdge)
            },
            total: {
                edge: Math.abs(cappedTotalEdge),
                side: totalPickSide,
                line: vegasTotal,
                probability: totalPickProb,
                betSize: totalBetSize,
                rawProbability: totalEdge >= 0 ? rawOverProb : 1 - rawOverProb,
                rawEdge: Math.abs(totalEdge)
            },
            features,
            calibrationApplied: CONFIG.isCalibrated,
            adjustedStdDev: {
                spread: adjustedSpreadStdDev,
                total: adjustedTotalStdDev
            }
        };
    }

    /**
     * Collect all feature adjustments for transparency
     */
    function collectFeatureDetails(home, away, context, projectedMargin) {
        const features = {};

        // Rest
        if (context.homeRestDays != null || context.awayRestDays != null) {
            features.rest = calculateRestAdvantage(context.homeRestDays, context.awayRestDays);
        }

        // Conference
        features.conference = calculateConferenceAdjustment(
            home.conference,
            away.conference,
            context.isNeutral
        );

        // Travel
        if (home.name && away.name) {
            features.travel = calculateTravelFatigue(home.name, away.name, context.awayPreviousGame);
        }

        // Tempo
        if (context.homePace || context.awayPace) {
            features.tempo = calculateTempoAdjustment(context.homePace, context.awayPace);
        }

        // Rivalry
        if (home.name && away.name) {
            features.rivalry = calculateRivalryAdjustment(home.name, away.name, projectedMargin);
        }

        // Recency
        if (context.homeRecentForm) {
            features.homeForm = calculateRecencyAdjustedRatings(home, context.homeRecentForm);
        }
        if (context.awayRecentForm) {
            features.awayForm = calculateRecencyAdjustedRatings(away, context.awayRecentForm);
        }

        return features;
    }

    function validateRatings(team) {
        return typeof team.netRating === 'number' && !isNaN(team.netRating) &&
               typeof team.offRating === 'number' && !isNaN(team.offRating) &&
               typeof team.defRating === 'number' && !isNaN(team.defRating);
    }

    function calculateKelly(probability, odds) {
        odds = odds === undefined ? -110 : odds;
        const breakeven = odds > 0 ? 100 / (odds + 100) : Math.abs(odds) / (Math.abs(odds) + 100);
        if (probability < breakeven + CONFIG.MIN_PROB_EDGE) {
            return 0;
        }
        const p = probability;
        const q = 1 - p;
        const b = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
        const fullKelly = (b * p - q) / b;
        if (fullKelly <= 0) return 0;
        return Math.min(fullKelly * CONFIG.KELLY_FRACTION, CONFIG.MAX_BET_FRACTION);
    }

    // =========================================================================
    // PARAMETER FITTING (Extended for feature weights)
    // =========================================================================

    function computeLogLoss(predictions, params) {
        const epsilon = 1e-15;
        let totalLoss = 0;

        for (const pred of predictions) {
            let p = sigmoid(params.A * logit(pred.rawProb) + params.B);
            p = (1 - params.shrinkage) * p + params.shrinkage * 0.5;
            p = Math.max(epsilon, Math.min(1 - epsilon, p));
            const loss = -(pred.outcome * Math.log(p) + (1 - pred.outcome) * Math.log(1 - p));
            totalLoss += loss;
        }

        return totalLoss / predictions.length;
    }

    /**
     * Build raw prediction objects from game array (DRY helper)
     * Used by both fitParameters and time-series CV
     */
    function buildRawPredictions(games) {
        const preds = [];
        for (const game of games) {
            try {
                if (!game.home || !game.away || game.vegasSpread == null) continue;
                if (!game.actualResult || (game.actualResult !== 'win' && game.actualResult !== 'loss')) continue;

                const context = {
                    homeRestDays: game.homeRestDays,
                    awayRestDays: game.awayRestDays,
                    homePace: game.homePace,
                    awayPace: game.awayPace,
                    isNeutral: game.isNeutral
                };

                const projectedSpread = projectSpreadEnhanced(game.home, game.away, context);
                const edge = calculateEdge(projectedSpread, game.vegasSpread, 'spread');
                const rawProb = normalCDF(Math.abs(edge) / CONFIG.SPREAD_STD_DEV);
                const outcome = game.actualResult === 'win' ? 1 : 0;

                preds.push({ rawProb, outcome, edge: Math.abs(edge), date: game.gameDate });
            } catch (e) {
                log('buildRawPredictions skip:', e.message);
            }
        }
        return preds;
    }

    /**
     * Fit calibration parameters with temporal holdout (Patch 2  leakage fix)
     *
     * CRITICAL CHANGE: Parameters are selected on a TRAIN split and validated
     * on a chronologically-later HOLDOUT split. Only applied if holdout improves.
     * Previous version used all data for both fitting and evaluation (leakage).
     */
    function fitParameters(historicalData) {
        if (!historicalData || historicalData.length < 50) {
            console.warn('[V3Enhanced] Insufficient data for fitting (need 50+, have',
                historicalData ? historicalData.length : 0, ')');
            return CONFIG;
        }

        log('Fitting parameters on', historicalData.length, 'games (temporal holdout)');

        // Sort chronologically  CRITICAL for time-series integrity
        const sorted = [...historicalData]
            .filter(g => g.gameDate)
            .sort((a, b) => new Date(a.gameDate) - new Date(b.gameDate));

        // 70/30 temporal split
        const splitIdx = Math.floor(sorted.length * 0.7);
        const trainGames = sorted.slice(0, splitIdx);
        const holdoutGames = sorted.slice(splitIdx);

        const trainPreds = buildRawPredictions(trainGames);
        const holdoutPreds = buildRawPredictions(holdoutGames);

        if (trainPreds.length < 30 || holdoutPreds.length < 15) {
            console.warn('[V3Enhanced] Insufficient valid predictions after split',
                { train: trainPreds.length, holdout: holdoutPreds.length });
            return CONFIG;
        }

        // Grid search on TRAIN data only
        let bestLogLoss = Infinity;
        let bestParams = { A: 0.85, B: 0, shrinkage: 0.20 };

        const AValues = [0.6, 0.7, 0.8, 0.85, 0.9, 1.0];
        const BValues = [-0.1, -0.05, 0, 0.05, 0.1];
        const shrinkageValues = [0.10, 0.15, 0.20, 0.25, 0.30];

        for (const A of AValues) {
            for (const B of BValues) {
                for (const shrinkage of shrinkageValues) {
                    const logLoss = computeLogLoss(trainPreds, { A, B, shrinkage });
                    if (logLoss < bestLogLoss) {
                        bestLogLoss = logLoss;
                        bestParams = { A, B, shrinkage };
                    }
                }
            }
        }

        // Evaluate on HOLDOUT (this is the honest number)
        const holdoutLL = computeLogLoss(holdoutPreds, bestParams);
        const baselineLL = computeLogLoss(holdoutPreds, { A: 1, B: 0, shrinkage: 0 });

        console.log(`[V3Enhanced] Calibration (temporal holdout):`);
        console.log(`  Best params: A=${bestParams.A}, B=${bestParams.B}, shrinkage=${bestParams.shrinkage}`);
        console.log(`  Train LL: ${bestLogLoss.toFixed(4)} (n=${trainPreds.length})`);
        console.log(`  Holdout LL: ${holdoutLL.toFixed(4)} vs baseline: ${baselineLL.toFixed(4)} (n=${holdoutPreds.length})`);

        // Only apply if holdout improves over uncalibrated baseline
        if (holdoutLL < baselineLL) {
            console.log(`   Calibration improves holdout by ${(baselineLL - holdoutLL).toFixed(4)}  applying`);
            CONFIG.PLATT_A = bestParams.A;
            CONFIG.PLATT_B = bestParams.B;
            CONFIG.SHRINKAGE_FACTOR = bestParams.shrinkage;
            CONFIG.isCalibrated = true;
            CONFIG.calibrationSampleSize = trainPreds.length;
            CONFIG.lastCalibrationDate = new Date().toISOString();
            saveCalibration();
        } else {
            console.warn(`   Calibration did NOT improve holdout (${holdoutLL.toFixed(4)} >= ${baselineLL.toFixed(4)})  keeping defaults`);
        }

        return CONFIG;
    }

    function saveCalibration() {
        try {
            const data = {
                PLATT_A: CONFIG.PLATT_A,
                PLATT_B: CONFIG.PLATT_B,
                SHRINKAGE_FACTOR: CONFIG.SHRINKAGE_FACTOR,
                FEATURE_WEIGHTS: CONFIG.FEATURE_WEIGHTS,
                isCalibrated: CONFIG.isCalibrated,
                calibrationSampleSize: CONFIG.calibrationSampleSize,
                lastCalibrationDate: CONFIG.lastCalibrationDate
            };
            localStorage.setItem('spreadsheet_v3enhanced_calibration', JSON.stringify(data));
        } catch (e) {
            console.warn('[V3Enhanced] Could not save calibration');
        }
    }

    function loadCalibration() {
        try {
            const saved = localStorage.getItem('spreadsheet_v3enhanced_calibration');
            if (saved) {
                const data = JSON.parse(saved);
                CONFIG.PLATT_A = data.PLATT_A || 0.85;
                CONFIG.PLATT_B = data.PLATT_B || 0;
                CONFIG.SHRINKAGE_FACTOR = data.SHRINKAGE_FACTOR || 0.20;
                if (data.FEATURE_WEIGHTS) {
                    CONFIG.FEATURE_WEIGHTS = { ...CONFIG.FEATURE_WEIGHTS, ...data.FEATURE_WEIGHTS };
                }
                CONFIG.isCalibrated = data.isCalibrated || false;
                CONFIG.calibrationSampleSize = data.calibrationSampleSize || 0;
                CONFIG.lastCalibrationDate = data.lastCalibrationDate || null;
                return true;
            }
        } catch (e) {}
        return false;
    }

    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    // TIME-SERIES CROSS-VALIDATION (Patch 6)
    // =========================================================================

    /**
     * Expanding-window time-series CV fold generator.
     *
     * Protocol: train on games [0..t], validate on [t+1..t+k], slide forward.
     * This mirrors real usage: always train on the past, predict the future.
     *
     * @param {Array} sortedGames  games sorted by gameDate ascending
     * @param {number} minTrainSize  minimum games before first fold (default 50)
     * @param {number} foldSize  games per validation fold (default 30)
     * @returns {Array} fold objects with trainPreds/valPreds arrays
     */
    function timeSeriesCV(sortedGames, minTrainSize = 50, foldSize = 30) {
        const folds = [];
        let startVal = minTrainSize;

        while (startVal + foldSize <= sortedGames.length) {
            const trainGames = sortedGames.slice(0, startVal);
            const valGames = sortedGames.slice(startVal, startVal + foldSize);

            const trainPreds = buildRawPredictions(trainGames);
            const valPreds = buildRawPredictions(valGames);

            if (trainPreds.length >= 30 && valPreds.length >= 10) {
                folds.push({
                    trainEnd: trainGames[trainGames.length - 1].gameDate,
                    valStart: valGames[0].gameDate,
                    valEnd: valGames[valGames.length - 1].gameDate,
                    trainPreds,
                    valPreds,
                    trainN: trainPreds.length,
                    valN: valPreds.length
                });
            }

            startVal += foldSize; // slide window forward
        }

        return folds;
    }

    /**
     * Fit Platt parameters using time-series CV with aggregated validation loss.
     *
     * Unlike fitParameters() (which uses a single 70/30 temporal holdout),
     * this averages validation Log Loss across multiple expanding-window folds
     * for a more robust parameter estimate.
     *
     * Use this when you have 150+ historical games for sufficient fold count.
     * Falls back to fitParameters() if < 3 folds are possible.
     *
     * @param {Array} historicalData  games with gameDate, home, away, vegasSpread, actualResult
     * @returns {Object} CONFIG with updated calibration params
     */
    function fitParametersCV(historicalData) {
        const sorted = [...historicalData]
            .filter(g => g.gameDate && g.home && g.away && g.vegasSpread != null
                      && (g.actualResult === 'win' || g.actualResult === 'loss'))
            .sort((a, b) => new Date(a.gameDate) - new Date(b.gameDate));

        const folds = timeSeriesCV(sorted, 50, 30);

        if (folds.length < 3) {
            console.warn('[CV] Need 3 folds; have', folds.length, ' falling back to temporal holdout');
            return fitParameters(historicalData);
        }

        let bestAvgLL = Infinity;
        let bestParams = { A: 0.85, B: 0, shrinkage: 0.20 };

        for (const A of [0.6, 0.7, 0.8, 0.85, 0.9, 1.0]) {
            for (const B of [-0.1, -0.05, 0, 0.05, 0.1]) {
                for (const shrinkage of [0.10, 0.15, 0.20, 0.25, 0.30]) {
                    const params = { A, B, shrinkage };
                    let sumLL = 0;
                    for (const fold of folds) {
                        sumLL += computeLogLoss(fold.valPreds, params);
                    }
                    const avgLL = sumLL / folds.length;
                    if (avgLL < bestAvgLL) {
                        bestAvgLL = avgLL;
                        bestParams = params;
                    }
                }
            }
        }

        // Baseline comparison (uncalibrated, averaged across same folds)
        let baselineSumLL = 0;
        for (const fold of folds) {
            baselineSumLL += computeLogLoss(fold.valPreds, { A: 1, B: 0, shrinkage: 0 });
        }
        const baselineAvgLL = baselineSumLL / folds.length;

        console.log(`[CV] Best params: A=${bestParams.A}, B=${bestParams.B}, shrinkage=${bestParams.shrinkage}`);
        console.log(`[CV] Avg val LL: ${bestAvgLL.toFixed(4)} vs baseline: ${baselineAvgLL.toFixed(4)} (${folds.length} folds)`);

        if (bestAvgLL < baselineAvgLL) {
            console.log(`[CV]  Calibration improves by ${(baselineAvgLL - bestAvgLL).toFixed(4)}  applying`);
            CONFIG.PLATT_A = bestParams.A;
            CONFIG.PLATT_B = bestParams.B;
            CONFIG.SHRINKAGE_FACTOR = bestParams.shrinkage;
            CONFIG.isCalibrated = true;
            CONFIG.calibrationSampleSize = sorted.length;
            CONFIG.lastCalibrationDate = new Date().toISOString();
            saveCalibration();
        } else {
            console.warn(`[CV]  Calibration did NOT improve  keeping defaults`);
        }

        return CONFIG;
    }

    /**
     * Nested calibration: fit Platt params on inner-fold of each CV split,
     * apply to outer-fold, report honest per-period metrics.
     *
     * This gives a truthful picture of how calibration would have performed
     * in each time window  the gold-standard for calibration diagnosis.
     *
     * @param {Array} sortedGames  chronologically sorted game array
     * @returns {Array} per-fold results with raw/calibrated Log Loss
     */
    function nestedCalibration(sortedGames) {
        const outerFolds = timeSeriesCV(sortedGames, 50, 40);
        const results = [];

        for (const fold of outerFolds) {
            // Inner split: first 70% of training for raw model, last 30% for Platt
            const innerSplit = Math.floor(fold.trainPreds.length * 0.7);
            const innerCalib = fold.trainPreds.slice(innerSplit);

            // Fit Platt on inner calibration set (smaller grid  less overfitting)
            let bestA = 1, bestB = 0, bestS = 0, bestLL = Infinity;
            for (const A of [0.7, 0.8, 0.9, 1.0]) {
                for (const B of [-0.05, 0, 0.05]) {
                    for (const S of [0.10, 0.15, 0.20]) {
                        const ll = computeLogLoss(innerCalib, { A, B, shrinkage: S });
                        if (ll < bestLL) {
                            bestLL = ll;
                            bestA = A; bestB = B; bestS = S;
                        }
                    }
                }
            }

            // Score on outer validation fold
            const rawLL = computeLogLoss(fold.valPreds, { A: 1, B: 0, shrinkage: 0 });
            const calibLL = computeLogLoss(fold.valPreds, { A: bestA, B: bestB, shrinkage: bestS });

            results.push({
                period: `${fold.valStart}  ${fold.valEnd}`,
                rawLogLoss: rawLL,
                calibratedLogLoss: calibLL,
                improvement: rawLL - calibLL,
                params: { A: bestA, B: bestB, S: bestS },
                n: fold.valN
            });
        }

        return results;
    }

    /**
     * Weighted Log Loss  supports season-decay sample weights.
     *
     * Each prediction can carry a `sampleWeight` field (default 1.0).
     * Use with applySeasonDecay() to down-weight older seasons.
     */
    function computeWeightedLogLoss(predictions, params) {
        const epsilon = 1e-15;
        let totalLoss = 0;
        let totalWeight = 0;

        for (const pred of predictions) {
            const weight = pred.sampleWeight || 1;
            let p = sigmoid(params.A * logit(pred.rawProb) + params.B);
            p = (1 - params.shrinkage) * p + params.shrinkage * 0.5;
            p = Math.max(epsilon, Math.min(1 - epsilon, p));
            const loss = -(pred.outcome * Math.log(p) + (1 - pred.outcome) * Math.log(1 - p));
            totalLoss += loss * weight;
            totalWeight += weight;
        }

        return totalWeight > 0 ? totalLoss / totalWeight : Infinity;
    }

    /**
     * Apply season-decay weights to a game array.
     * Half-life of 1.5 seasons: current season = 100%, last = ~63%, two ago = ~40%.
     */
    function applySeasonDecay(games, decayHalfLife = 1.5) {
        const now = new Date();
        const currentSeason = now.getMonth() >= 10 ? now.getFullYear() + 1 : now.getFullYear();

        return games.map(game => {
            const gameDate = new Date(game.gameDate);
            const gameSeason = gameDate.getMonth() >= 10 ? gameDate.getFullYear() + 1 : gameDate.getFullYear();
            const seasonsAgo = currentSeason - gameSeason;
            const weight = Math.exp(-Math.LN2 * seasonsAgo / decayHalfLife);
            return { ...game, sampleWeight: weight };
        });
    }

    // =========================================================================
    // PROJECTION DECOMPOSITION (Diagnostic Tool)
    // =========================================================================

    /**
     * Decompose a projection into its component parts for transparency.
     * Use in browser console to understand WHY the model makes a particular pick.
     *
     * @param {object} home - Home team ratings
     * @param {object} away - Away team ratings
     * @param {number} vegasSpread - Vegas spread line
     * @param {number} vegasTotal - Vegas total line
     * @param {object} context - Game context
     * @returns {object} Decomposed projection with dominance flags
     */
    function decomposeProjection(home, away, vegasSpread, vegasTotal, context = {}) {
        const gamePace = getGamePace(context);
        const paceMultiplier = gamePace / 100;

        const homeNet = shrinkRating(home.netRating, getConferenceMean(home.conference), home.gamesPlayed);
        const awayNet = shrinkRating(away.netRating, getConferenceMean(away.conference), away.gamesPlayed);

        // Spread decomposition
        const baseMargin = (homeNet - awayNet) * paceMultiplier;
        const hca = context.isNeutral ? 0 : CONFIG.BASE_HCA;
        const projSpread = -(baseMargin + hca);
        const spreadEdge = vegasSpread - projSpread;

        // Total decomposition (multiplicative interaction)
        const homeOff = shrinkRating(home.offRating, 100, home.gamesPlayed);
        const homeDef = shrinkRating(home.defRating, 100, home.gamesPlayed);
        const awayOff = shrinkRating(away.offRating, 100, away.gamesPlayed);
        const awayDef = shrinkRating(away.defRating, 100, away.gamesPlayed);
        const homeExpEff = homeOff * awayDef / CONFIG.D1_AVG_EFF;
        const awayExpEff = awayOff * homeDef / CONFIG.D1_AVG_EFF;
        const baseTotal = (homeExpEff + awayExpEff) * gamePace / 100;
        const totalEdge = baseTotal - vegasTotal;

        return {
            spread: {
                homeNetShrunk: +homeNet.toFixed(2),
                awayNetShrunk: +awayNet.toFixed(2),
                ratingGap: +(homeNet - awayNet).toFixed(2),
                gamePace: +gamePace.toFixed(1),
                paceMultiplier: +paceMultiplier.toFixed(3),
                baseMargin: +baseMargin.toFixed(2),
                hca: +hca.toFixed(1),
                projectedSpread: +projSpread.toFixed(2),
                vegasSpread,
                edge: +spreadEdge.toFixed(2),
                edgePct: +((spreadEdge / (Math.abs(vegasSpread) || 1)) * 100).toFixed(1)
            },
            total: {
                homeExpEff: +homeExpEff.toFixed(1),
                awayExpEff: +awayExpEff.toFixed(1),
                combinedEff: +(homeExpEff + awayExpEff).toFixed(1),
                gamePace: +gamePace.toFixed(1),
                baseTotal: +baseTotal.toFixed(1),
                vegasTotal,
                edge: +totalEdge.toFixed(1),
                edgePct: +((totalEdge / vegasTotal) * 100).toFixed(1)
            },
            dominanceCheck: {
                // If edge is >20% of the line, model disagrees heavily with Vegas  flag it
                spreadEdgeSuspicious: Math.abs(spreadEdge) > Math.abs(vegasSpread || 1) * 0.2,
                totalEdgeSuspicious: Math.abs(totalEdge) > vegasTotal * 0.1,
                // Info about which factors are contributing
                ratingDriven: Math.abs(baseMargin) > 3,
                paceDriven: Math.abs(gamePace - CONFIG.D1_AVG_TEMPO) > 3
            }
        };
    }

    // =========================================================================
    // AUTOMATED REFIT SCHEDULE (Patch 9)
    // =========================================================================

    /**
     * Count graded games that were added after a given date.
     *
     * This looks at the global state.historicalGames array (or a provided
     * array) for games with gameDate after the cutoff and a valid result.
     *
     * @param {Date} sinceDate  count games added after this date
     * @param {Array} games  game array (defaults to state.historicalGames)
     * @returns {number} count of new graded games
     */
    function countNewGradesSince(sinceDate, games) {
        const source = games || (typeof state !== 'undefined' && state.historicalGames) || [];
        const cutoff = sinceDate instanceof Date ? sinceDate : new Date(sinceDate);
        return source.filter(g =>
            g.gameDate &&
            new Date(g.gameDate) > cutoff &&
            (g.actualResult === 'win' || g.actualResult === 'loss')
        ).length;
    }

    /**
     * Determine whether the model should refit calibration parameters.
     *
     * Triggers when BOTH conditions are met:
     *   1. > 14 days since last calibration
     *   2. > 20 new graded games since last calibration
     *
     * Also triggers unconditionally if:
     *   - No calibration has ever been performed
     *   - We've crossed a season phase boundary (pre/mid/conf/march)
     *
     * @param {Array} games  optional game array override
     * @returns {Object} { shouldRefit, reason, daysSince, newGames, seasonPhase }
     */
    function shouldRefit(games) {
        const now = new Date();
        const month = now.getMonth(); // 0-indexed
        const day = now.getDate();

        // Determine current season phase
        let seasonPhase;
        if (month === 10) seasonPhase = 'preseason';           // November
        else if (month >= 11 || month === 0) seasonPhase = 'early';  // Dec-Jan
        else if (month === 1 && day < 15) seasonPhase = 'midseason'; // Early Feb
        else if (month === 1) seasonPhase = 'conference';      // Late Feb
        else if (month === 2) seasonPhase = 'march';           // March
        else seasonPhase = 'offseason';                         // Apr-Oct

        // No calibration ever  always refit
        if (!CONFIG.lastCalibrationDate) {
            return {
                shouldRefit: true,
                reason: 'No calibration on record',
                daysSince: Infinity,
                newGames: 0,
                seasonPhase
            };
        }

        const lastFit = new Date(CONFIG.lastCalibrationDate);
        const daysSince = (now - lastFit) / (1000 * 60 * 60 * 24);
        const newGames = countNewGradesSince(lastFit, games);

        // Phase-specific thresholds
        const thresholds = {
            preseason:  { days: 7,  games: 15 },  // Volatile  refit early
            early:      { days: 14, games: 20 },
            midseason:  { days: 14, games: 20 },
            conference: { days: 14, games: 25 },  // More stable  need more evidence
            march:      { days: 7,  games: 10 },  // Tournament matters, refit aggressively
            offseason:  { days: 999, games: 999 }  // Don't refit in offseason
        };

        const t = thresholds[seasonPhase] || thresholds.early;
        const trigger = daysSince > t.days && newGames > t.games;

        return {
            shouldRefit: trigger,
            reason: trigger
                ? `${daysSince.toFixed(0)} days & ${newGames} new games (threshold: ${t.days}d/${t.games}g)`
                : `Not yet (${daysSince.toFixed(0)}d/${newGames}g, need ${t.days}d/${t.games}g)`,
            daysSince,
            newGames,
            seasonPhase
        };
    }

    /**
     * Run the appropriate refit based on current season phase.
     *
     * - preseason/march: Full CV refit if enough data, else temporal holdout
     * - early/midseason/conference: Temporal holdout (faster, still honest)
     * - offseason: No-op (log only)
     *
     * Also applies neutral-site HCA override for March Madness.
     *
     * @param {Array} historicalData  graded games array
     * @returns {Object} { refitted, method, config, seasonPhase }
     */
    function autoRefit(historicalData) {
        const check = shouldRefit(historicalData);

        if (!check.shouldRefit) {
            log('autoRefit: skipped ', check.reason);
            return { refitted: false, reason: check.reason, seasonPhase: check.seasonPhase };
        }

        console.log(`[autoRefit] Triggering refit: ${check.reason} (phase: ${check.seasonPhase})`);

        let method;
        let result;

        if (check.seasonPhase === 'offseason') {
            return { refitted: false, reason: 'Offseason  no refit', seasonPhase: check.seasonPhase };
        }

        // Full CV for pre-season and March (when accuracy matters most)
        if ((check.seasonPhase === 'preseason' || check.seasonPhase === 'march') &&
            historicalData && historicalData.length >= 140) {
            result = fitParametersCV(historicalData);
            method = 'fitParametersCV';
        } else {
            result = fitParameters(historicalData);
            method = 'fitParameters';
        }

        // March Madness override: force neutral-site HCA
        if (check.seasonPhase === 'march') {
            const prevHCA = CONFIG.BASE_HCA;
            CONFIG.BASE_HCA = 0;
            console.log(`[autoRefit] March Madness: BASE_HCA ${prevHCA}  0 (neutral sites)`);
        }

        console.log(`[autoRefit] Complete: method=${method}, calibrated=${CONFIG.isCalibrated}`);

        return {
            refitted: true,
            method,
            config: { ...CONFIG },
            seasonPhase: check.seasonPhase
        };
    }

    // =========================================================================

    loadCalibration();

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        analyze,
        fitParameters,
        fitParametersCV,                // Patch 6: multi-fold time-series CV
        timeSeriesCV,                   // Patch 6: fold generator (for external backtest)
        nestedCalibration,              // Patch 6: honest per-period calibration diagnosis
        computeWeightedLogLoss,         // Patch 6: season-decay aware loss
        applySeasonDecay,               // Patch 6: weight games by recency
        buildRawPredictions,            // Patch 2: exposed for external CV/backtest
        shrinkRating,                   // Patch 4: exposed for diagnostics
        getConferenceMean,              // Patch 4: exposed for diagnostics
        ewmTeamForm,                    // Patch 8: EWM form calculator
        shouldRefit,                    // Patch 9: check if refit is needed
        autoRefit,                      // Patch 9: run phase-appropriate refit
        countNewGradesSince,            // Patch 9: helper
        getGamePace,                    // Helper: derive game pace from context
        decomposeProjection,            // Diagnostic: decompose projection into parts
        projectSpreadEnhanced,
        projectTotalEnhanced,
        calculateRestAdvantage,
        calculateTempoAdjustment,
        calculateConferenceAdjustment,
        calculateRecencyAdjustedRatings,
        calculateTravelFatigue,
        calculateRivalryAdjustment,
        isRivalryGame,
        calibrateProbability,
        calculateKelly,
        normalCDF,
        getConfig: () => ({ ...CONFIG }),
        setConfig: (c) => { CONFIG = { ...CONFIG, ...c }; },
        resetConfig: () => {
            CONFIG.PLATT_A = 0.85;
            CONFIG.PLATT_B = 0;
            CONFIG.SHRINKAGE_FACTOR = 0.20;
            CONFIG.isCalibrated = false;
            localStorage.removeItem('spreadsheet_v3enhanced_calibration');
        },
        isCalibrated: () => CONFIG.isCalibrated,
        loadCalibration,
        saveCalibration,
        CONFERENCE_STRENGTH,
        TEAM_LOCATIONS,
        RIVALRIES,
        Constants: CONFIG
    };
})();

console.log(' SpreadSheetV3.1 Enhanced Loaded');
console.log('   Features: Rest, Tempo, Conference, Travel, Rivalry, Recency');


// ============================================================
// ENHANCED analyzeGame OVERRIDE
// ============================================================

/**
 * analyzeGame  single canonical entry point (V3Enhanced)
 * Patch 1: removed _originalAnalyzeGameV2 reference (SpreadSheetV2 deleted)
 */
function analyzeGame(hr, ar, spread, total, homeTeamName, awayTeamName, gameContext = {}) {
    if (!hr || !ar) {
        return {
            hasData: false,
            spreadScore: 0,
            totalScore: 0,
            confidence: 0,
            totalConfidence: 0,
            missingRatings: true,
            missingHome: !hr,
            missingAway: !ar
        };
    }

    // Build enhanced input
    const home = {
        name: homeTeamName,
        offRating: hr.offRating,
        defRating: hr.defRating,
        netRating: hr.netRating,
        conference: hr.conference,
        rank: hr.rank,
        gamesPlayed: hr.gamesPlayed || hr.games || null  // Patch 4: for early-season shrinkage
    };
    const away = {
        name: awayTeamName,
        offRating: ar.offRating,
        defRating: ar.defRating,
        netRating: ar.netRating,
        conference: ar.conference,
        rank: ar.rank,
        gamesPlayed: ar.gamesPlayed || ar.games || null  // Patch 4: for early-season shrinkage
    };

    // Build context from available data
    const context = {
        // Rest days (try to extract from gameContext or use defaults)
        homeRestDays: gameContext.homeRestDays ?? extractRestDays(homeTeamName, gameContext),
        awayRestDays: gameContext.awayRestDays ?? extractRestDays(awayTeamName, gameContext),

        // Tempo (from ratings if available)
        homePace: hr.pace || hr.tempo || gameContext.homePace,
        awayPace: ar.pace || ar.tempo || gameContext.awayPace,

        // Recent form
        homeRecentForm: hr.recentForm || gameContext.homeRecentForm,
        awayRecentForm: ar.recentForm || gameContext.awayRecentForm,

        // EWM game-level data (Patch 8)  array of {netMargin, daysAgo}
        // Preferred over recentForm when available (3+ games required)
        homeRecentGames: hr.recentGames || gameContext.homeRecentGames || null,
        awayRecentGames: ar.recentGames || gameContext.awayRecentGames || null,

        // Situational
        isNeutral: gameContext.isNeutral || false,
        awayPreviousGame: gameContext.awayPreviousGame,

        // Standard odds
        odds: gameContext.odds || -110
    };

    // Run enhanced analysis
    const v3e = SpreadSheetV3Enhanced.analyze(home, away, spread, total, context);

    if (!v3e.hasData) {
        return { hasData: false, spreadScore: 0, totalScore: 0 };
    }

    if (v3e.noVegasLines) {
        return {
            hasData: true,
            projection: v3e.projection,
            spread: null,
            total: null,
            noVegasLines: true
        };
    }

    // Convert to UI format
    const spreadScore = Math.round((v3e.spread.probability - 0.5) * 200);
    const totalScore = Math.round((v3e.total.probability - 0.5) * 200);

    return {
        hasData: true,

        // Spread
        spreadPick: v3e.spread.betSize > 0 ? {
            team: v3e.spread.team,
            side: v3e.spread.side,
            line: v3e.spread.line
        } : null,
        spreadEdge: v3e.spread.edge,
        spreadScore: Math.max(0, spreadScore),
        spreadWinProb: v3e.spread.probability * 100,
        projectedSpread: v3e.projection.spread,
        projectedMargin: -v3e.projection.spread,

        // Total
        totalPick: v3e.total.betSize > 0 ? {
            pick: v3e.total.side.toUpperCase(),
            line: v3e.total.line
        } : null,
        totalEdge: v3e.total.edge,
        totalScore: Math.max(0, totalScore),
        totalWinProb: v3e.total.probability * 100,
        projectedTotal: v3e.projection.total,

        // Confidence
        confidence: Math.round(v3e.spread.probability * 10),
        totalConfidence: Math.round(v3e.total.probability * 10),

        // Bet sizing
        spreadBetSize: v3e.spread.betSize,
        totalBetSize: v3e.total.betSize,

        // Enhanced features
        factors: generateEnhancedFactors(v3e, home, away),
        reasoning: generateEnhancedReasoning(v3e, home, away),
        totalReasoning: generateEnhancedTotalReasoning(v3e, home, away),
        featureDetails: v3e.features,

        // Diagnostics
        calibrationApplied: v3e.calibrationApplied,
        rawSpreadProb: v3e.spread.rawProbability * 100,
        rawTotalProb: v3e.total.rawProbability * 100,

        // Legacy compatibility
        spreadComponents: {},
        totalComponents: {},
        dynamicHCA: v3e.features?.conference?.dynamicHCA || 3.2,
        marketEfficiency: null,
        enhancedKelly: null,
        totalKelly: null
    };
}

/**
 * Extract rest days from game schedule context
 */
function extractRestDays(teamName, context) {
    // Try to find last game date for team
    if (context.schedule && teamName) {
        const teamSchedule = context.schedule[teamName];
        if (teamSchedule && teamSchedule.lastGameDate) {
            const lastGame = new Date(teamSchedule.lastGameDate);
            const today = new Date();
            const diffDays = Math.floor((today - lastGame) / (1000 * 60 * 60 * 24));
            return Math.max(0, diffDays);
        }
    }

    // Check if there's a historical games array we can search
    if (typeof state !== 'undefined' && state.historicalGames) {
        const recentGames = state.historicalGames
            .filter(g => g.homeTeam === teamName || g.awayTeam === teamName)
            .sort((a, b) => new Date(b.date) - new Date(a.date));

        if (recentGames.length > 0) {
            const lastGame = new Date(recentGames[0].date);
            const today = new Date();
            const diffDays = Math.floor((today - lastGame) / (1000 * 60 * 60 * 24));
            return Math.max(0, Math.min(7, diffDays));
        }
    }

    return null; // Unknown
}

/**
 * Generate enhanced factors for UI display
 */
function generateEnhancedFactors(v3e, home, away) {
    const factors = [];
    const f = v3e.features || {};

    // Edge
    if (v3e.spread.edge >= 3) {
        factors.push({ text: `${v3e.spread.edge.toFixed(1)}pt edge`, type: 'positive' });
    } else if (v3e.spread.edge >= 2) {
        factors.push({ text: `${v3e.spread.edge.toFixed(1)}pt edge`, type: 'info' });
    }

    // Rest advantage
    if (f.rest) {
        if (f.rest.awayB2B) {
            factors.push({ text: 'Opp B2B', type: 'positive' });
        } else if (f.rest.homeB2B) {
            factors.push({ text: 'Home B2B', type: 'negative' });
        } else if (Math.abs(f.rest.restDiff) >= 2) {
            factors.push({
                text: `+${Math.abs(f.rest.restDiff)} rest`,
                type: f.rest.restDiff > 0 ? 'positive' : 'negative'
            });
        }
    }

    // Travel
    if (f.travel && f.travel.distance > 1500) {
        factors.push({ text: `${Math.round(f.travel.distance)}mi travel`, type: 'positive' });
    }
    if (f.travel && f.travel.altitudeAdjustment > 0) {
        factors.push({ text: 'Altitude edge', type: 'positive' });
    }

    // Rivalry
    if (f.rivalry && f.rivalry.isRivalry) {
        factors.push({ text: 'Rivalry', type: 'info' });
    }

    // Conference
    if (f.conference && !f.conference.isConferenceGame) {
        const diff = f.conference.homeStrength - f.conference.awayStrength;
        if (Math.abs(diff) > 0.5) {
            factors.push({ text: 'Conf mismatch', type: 'info' });
        }
    }

    // Tempo
    if (f.tempo && f.tempo.paceDiff > 5) {
        factors.push({ text: 'Pace clash', type: 'info' });
    }

    // Form
    if (f.homeForm && f.homeForm.formTrend === 'hot') {
        factors.push({ text: 'Home hot', type: 'positive' });
    } else if (f.homeForm && f.homeForm.formTrend === 'cold') {
        factors.push({ text: 'Home cold', type: 'negative' });
    }
    if (f.awayForm && f.awayForm.formTrend === 'cold') {
        factors.push({ text: 'Away cold', type: 'positive' });
    }

    // Calibration badge
    if (v3e.calibrationApplied) {
        factors.push({ text: 'Cal+', type: 'info' });
    }

    // Key numbers
    const absLine = Math.abs(v3e.spread.line);
    if ([3, 3.5, 7, 7.5].includes(absLine)) {
        factors.push({ text: `Key #${absLine}`, type: 'info' });
    }

    return factors;
}

/**
 * Generate enhanced reasoning text
 */
function generateEnhancedReasoning(v3e, home, away) {
    if (v3e.spread.edge < 2) return '';

    const parts = [];
    const f = v3e.features || {};
    const pickTeam = v3e.spread.side === 'home' ? home : away;
    const oppTeam = v3e.spread.side === 'home' ? away : home;

    // Rating advantage
    const netDiff = Math.abs(home.netRating - away.netRating);
    if (netDiff >= 15) {
        parts.push(`${pickTeam.name} holds a ${netDiff.toFixed(0)}-point efficiency advantage.`);
    }

    // Edge
    if (v3e.spread.edge >= 5) {
        parts.push(`Model finds ${v3e.spread.edge.toFixed(1)} points of value.`);
    } else if (v3e.spread.edge >= 3) {
        parts.push(`Solid ${v3e.spread.edge.toFixed(1)}-point edge identified.`);
    }

    // Feature-based reasoning
    if (f.rest && f.rest.awayB2B) {
        parts.push(`${oppTeam.name} on a back-to-back.`);
    }
    if (f.travel && f.travel.distance > 2000) {
        parts.push(`${oppTeam.name} traveling ${Math.round(f.travel.distance)} miles.`);
    }
    if (f.travel && f.travel.altitudeAdjustment > 0) {
        parts.push(`Altitude advantage for home team.`);
    }
    if (f.rivalry && f.rivalry.isRivalry) {
        parts.push(`Rivalry game - expect closer than expected.`);
    }

    parts.push(`Calibrated probability: ${(v3e.spread.probability * 100).toFixed(0)}%.`);

    return parts.join(' ');
}

/**
 * Generate enhanced total reasoning
 */
function generateEnhancedTotalReasoning(v3e, home, away) {
    if (v3e.total.edge < 3) return '';

    const parts = [];
    const f = v3e.features || {};

    if (v3e.total.side === 'over') {
        parts.push(`Model projects ${v3e.projection.total.toFixed(0)} total, ${v3e.total.edge.toFixed(1)} above line.`);
    } else {
        parts.push(`Model projects ${v3e.projection.total.toFixed(0)} total, ${v3e.total.edge.toFixed(1)} below line.`);
    }

    if (f.tempo && f.tempo.paceDiff > 5) {
        const slower = f.tempo.homePace < f.tempo.awayPace ? 'home' : 'away';
        parts.push(`Pace mismatch - ${slower} team likely controls tempo.`);
    }

    if (f.rest && (f.rest.homeB2B || f.rest.awayB2B)) {
        parts.push(`Tired legs may reduce scoring.`);
    }

    parts.push(`Calibrated probability: ${(v3e.total.probability * 100).toFixed(0)}%.`);

    return parts.join(' ');
}


// ============================================================
// AUTO-CALIBRATION
// ============================================================

function initializeV3EnhancedCalibration() {
    if (SpreadSheetV3Enhanced.isCalibrated()) {
        const config = SpreadSheetV3Enhanced.getConfig();
        console.log('[V3Enhanced] Using saved calibration from', config.lastCalibrationDate);
        return;
    }

    if (typeof state === 'undefined' || !state.ratings) {
        console.log('[V3Enhanced] Waiting for data...');
        return;
    }

    // Auto-calibration requires historical tracked bets data (feature not in use)
    console.log('[V3Enhanced] Auto-calibration skipped - using default parameters');
}

function findTeamRating(teamName) {
    if (!teamName || typeof state === 'undefined' || !state.ratings) return null;
    if (state.ratings[teamName]) return state.ratings[teamName];
    const normalized = teamName.toLowerCase().replace(/[^a-z]/g, '');
    for (const [key, value] of Object.entries(state.ratings)) {
        if (key.toLowerCase().replace(/[^a-z]/g, '') === normalized) {
            return value;
        }
    }
    return null;
}

// Hook initialization
if (typeof document !== 'undefined') {
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(initializeV3EnhancedCalibration, 2500);
    } else {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeV3EnhancedCalibration, 2500);
        });
    }
}

console.log(' V3 Enhanced Integration Complete');
console.log('   analyzeGame() now includes: Rest, Travel, Tempo, Conference, Rivalry adjustments');

        // ============================================================
        // ADVANCED VALIDATION MODULE (AdvValidation)
        // Provides rigorous, leakage-safe evaluation with proper scoring
        // ============================================================
        const AdvValidation = (function() {
            'use strict';

            // Debug flag - enable via window.__debugValidation = true
            const DEBUG = () => window.__debugValidation === true;
            const log = (...args) => DEBUG() && console.log('[AdvValidation]', ...args);

            /**
             * Brier Score: Mean squared error for probabilistic predictions
             * Perfect = 0, Worst = 1, Random = 0.25
             * Lower is better.
             */
            function calculateBrierScore(predictions) {
                if (!predictions || predictions.length === 0) return null;

                const validPreds = predictions.filter(p =>
                    p.status === 'graded' &&
                    typeof p.winProb === 'number' &&
                    (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 5) {
                    log('Brier: Insufficient data', validPreds.length);
                    return null;
                }

                const sumSquaredError = validPreds.reduce((sum, p) => {
                    const prob = p.winProb / 100; // Convert to 0-1 scale
                    const outcome = p.result === 'win' ? 1 : 0;
                    const error = Math.pow(prob - outcome, 2);
                    return sum + error;
                }, 0);

                const brier = sumSquaredError / validPreds.length;
                log('Brier Score:', brier.toFixed(4), 'n=', validPreds.length);
                return { score: brier, n: validPreds.length };
            }

            /**
             * Log Loss: Proper scoring rule for probabilistic predictions
             * Lower is better. Heavily penalizes confident wrong predictions.
             */
            function calculateLogLoss(predictions) {
                if (!predictions || predictions.length === 0) return null;

                const validPreds = predictions.filter(p =>
                    p.status === 'graded' &&
                    typeof p.winProb === 'number' &&
                    (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 5) return null;

                const epsilon = 1e-15; // Prevent log(0)
                const sumLoss = validPreds.reduce((sum, p) => {
                    let prob = Math.max(epsilon, Math.min(1 - epsilon, p.winProb / 100));
                    const outcome = p.result === 'win' ? 1 : 0;
                    const loss = -(outcome * Math.log(prob) + (1 - outcome) * Math.log(1 - prob));
                    return sum + loss;
                }, 0);

                return { score: sumLoss / validPreds.length, n: validPreds.length };
            }

            /**
             * Calibration bins: Group predictions by probability range
             * and compute actual win rate vs predicted probability
             */
            function calculateCalibration(predictions, numBins = 5) {
                if (!predictions || predictions.length === 0) return null;

                const validPreds = predictions.filter(p =>
                    p.status === 'graded' &&
                    typeof p.winProb === 'number' &&
                    (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 10) {
                    log('Calibration: Insufficient data', validPreds.length);
                    return null;
                }

                // Create bins: [50-54], [54-58], [58-62], [62-66], [66-100]
                const binEdges = [50, 54, 58, 62, 66, 100];
                const bins = [];

                for (let i = 0; i < binEdges.length - 1; i++) {
                    const binPreds = validPreds.filter(p =>
                        p.winProb >= binEdges[i] && p.winProb < binEdges[i + 1]
                    );

                    if (binPreds.length > 0) {
                        const wins = binPreds.filter(p => p.result === 'win').length;
                        const avgPredicted = binPreds.reduce((s, p) => s + p.winProb, 0) / binPreds.length / 100;
                        const actualWinRate = wins / binPreds.length;

                        // Bootstrap CI for actual win rate
                        const ci = bootstrapCI(binPreds.map(p => p.result === 'win' ? 1 : 0), 1000, 0.95);

                        bins.push({
                            range: `${binEdges[i]}-${binEdges[i + 1]}%`,
                            predicted: avgPredicted,
                            actual: actualWinRate,
                            n: binPreds.length,
                            ci95Lower: ci.lower,
                            ci95Upper: ci.upper
                        });
                    }
                }

                // Calculate calibration error (mean absolute deviation from diagonal)
                const calibrationError = bins.length > 0
                    ? bins.reduce((sum, b) => sum + Math.abs(b.predicted - b.actual) * b.n, 0) / validPreds.length
                    : null;

                log('Calibration bins:', bins);
                log('Calibration error:', calibrationError?.toFixed(4));

                return { bins, calibrationError, n: validPreds.length };
            }

            /**
             * Bootstrap confidence interval for mean
             */
            function bootstrapCI(data, nIterations = 1000, confidence = 0.95) {
                if (data.length < 3) return { lower: 0, upper: 1, mean: data.length > 0 ? data.reduce((a, b) => a + b, 0) / data.length : 0 };

                const means = [];
                for (let i = 0; i < nIterations; i++) {
                    const sample = [];
                    for (let j = 0; j < data.length; j++) {
                        sample.push(data[Math.floor(Math.random() * data.length)]);
                    }
                    means.push(sample.reduce((a, b) => a + b, 0) / sample.length);
                }

                means.sort((a, b) => a - b);
                const alpha = 1 - confidence;
                const lowerIdx = Math.floor(means.length * alpha / 2);
                const upperIdx = Math.floor(means.length * (1 - alpha / 2));

                return {
                    lower: means[lowerIdx],
                    upper: means[upperIdx],
                    mean: data.reduce((a, b) => a + b, 0) / data.length
                };
            }

            /**
             * Win rate with bootstrap CI
             */
            function calculateWinRateWithCI(predictions, confidence = 0.95) {
                const validPreds = predictions.filter(p =>
                    p.status === 'graded' && (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 5) return null;

                const outcomes = validPreds.map(p => p.result === 'win' ? 1 : 0);
                const ci = bootstrapCI(outcomes, 1000, confidence);

                return {
                    winRate: ci.mean * 100,
                    ci95Lower: ci.lower * 100,
                    ci95Upper: ci.upper * 100,
                    n: validPreds.length
                };
            }

            /**
             * Naive baseline: Always predict 50% (coin flip)
             * Returns Brier score for comparison
             */
            function calculateNaiveBaseline(predictions) {
                const validPreds = predictions.filter(p =>
                    p.status === 'graded' && (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 5) return null;

                // Naive = always 50%
                const brierNaive = 0.25; // (0.5 - 0)^2 or (0.5 - 1)^2

                // Historical average (mean win rate as constant prediction)
                const actualWinRate = validPreds.filter(p => p.result === 'win').length / validPreds.length;
                const brierHistorical = validPreds.reduce((sum, p) => {
                    const outcome = p.result === 'win' ? 1 : 0;
                    return sum + Math.pow(actualWinRate - outcome, 2);
                }, 0) / validPreds.length;

                return {
                    naiveBrier: brierNaive,
                    historicalBrier: brierHistorical,
                    historicalWinRate: actualWinRate * 100,
                    n: validPreds.length
                };
            }

            /**
             * Brier Skill Score: Improvement over naive baseline
             * BSS = 1 - (Brier_model / Brier_reference)
             * 1 = perfect, 0 = same as reference, negative = worse than reference
             */
            function calculateBrierSkillScore(modelBrier, referenceBrier) {
                if (modelBrier === null || referenceBrier === null || referenceBrier === 0) return null;
                return 1 - (modelBrier / referenceBrier);
            }

            /**
             * ROI with bootstrap CI
             */
            function calculateROIWithCI(predictions, confidence = 0.95) {
                const validPreds = predictions.filter(p =>
                    p.status === 'graded' && (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 5) return null;

                // Calculate per-bet profit: +0.91 for win, -1 for loss (standard -110 odds)
                const profits = validPreds.map(p => p.result === 'win' ? 0.91 : -1);
                const ci = bootstrapCI(profits, 1000, confidence);

                return {
                    meanROI: ci.mean * 100,
                    ci95Lower: ci.lower * 100,
                    ci95Upper: ci.upper * 100,
                    n: validPreds.length
                };
            }

            /**
             * Temporal split validation to check for data leakage
             * Compares performance in first half vs second half of data
             */
            function temporalSplitCheck(predictions) {
                const validPreds = predictions
                    .filter(p => p.status === 'graded' && (p.result === 'win' || p.result === 'loss'))
                    .sort((a, b) => new Date(a.gameDate) - new Date(b.gameDate));

                if (validPreds.length < 20) return null;

                const midpoint = Math.floor(validPreds.length / 2);
                const firstHalf = validPreds.slice(0, midpoint);
                const secondHalf = validPreds.slice(midpoint);

                const firstWinRate = firstHalf.filter(p => p.result === 'win').length / firstHalf.length;
                const secondWinRate = secondHalf.filter(p => p.result === 'win').length / secondHalf.length;

                const firstBrier = calculateBrierScore(firstHalf);
                const secondBrier = calculateBrierScore(secondHalf);

                // Large degradation in second half may indicate overfitting or leakage
                const winRateDiff = secondWinRate - firstWinRate;
                const brierDiff = secondBrier && firstBrier ? secondBrier.score - firstBrier.score : null;

                return {
                    firstHalf: {
                        winRate: firstWinRate * 100,
                        brier: firstBrier?.score,
                        n: firstHalf.length
                    },
                    secondHalf: {
                        winRate: secondWinRate * 100,
                        brier: secondBrier?.score,
                        n: secondHalf.length
                    },
                    winRateDiff: winRateDiff * 100,
                    brierDiff,
                    potentialLeakage: brierDiff !== null && brierDiff > 0.05
                };
            }

            /**
             * Main analysis function - returns all validation metrics
             */
            function analyze(predictions) {
                log('Analyzing', predictions?.length, 'predictions');

                if (!predictions || predictions.length === 0) {
                    return { hasData: false, message: 'No predictions to analyze' };
                }

                const gradedCount = predictions.filter(p => p.status === 'graded').length;
                const pendingCount = predictions.filter(p => p.status === 'pending').length;

                if (gradedCount < 5) {
                    return {
                        hasData: false,
                        message: `Awaiting ground truth (${gradedCount} graded, need 5+)`,
                        gradedCount,
                        pendingCount
                    };
                }

                const brier = calculateBrierScore(predictions);
                const logLoss = calculateLogLoss(predictions);
                const calibration = calculateCalibration(predictions);
                const winRateCI = calculateWinRateWithCI(predictions);
                const roiCI = calculateROIWithCI(predictions);
                const baseline = calculateNaiveBaseline(predictions);
                const temporal = temporalSplitCheck(predictions);

                // Calculate skill scores
                const brierSkillVsNaive = brier && baseline
                    ? calculateBrierSkillScore(brier.score, baseline.naiveBrier)
                    : null;
                const brierSkillVsHistorical = brier && baseline
                    ? calculateBrierSkillScore(brier.score, baseline.historicalBrier)
                    : null;

                const lastUpdated = new Date().toISOString();

                return {
                    hasData: true,
                    lastUpdated,
                    sampleSize: gradedCount,
                    pendingCount,

                    // Proper scoring rules
                    brierScore: brier?.score,
                    logLoss: logLoss?.score,

                    // Skill scores (improvement over baselines)
                    brierSkillVsNaive,
                    brierSkillVsHistorical,

                    // Calibration
                    calibration: calibration?.bins,
                    calibrationError: calibration?.calibrationError,

                    // Win rate with CI
                    winRate: winRateCI?.winRate,
                    winRateCI95: winRateCI ? [winRateCI.ci95Lower, winRateCI.ci95Upper] : null,

                    // ROI with CI
                    roi: roiCI?.meanROI,
                    roiCI95: roiCI ? [roiCI.ci95Lower, roiCI.ci95Upper] : null,

                    // Baseline comparison
                    baseline: {
                        naiveBrier: baseline?.naiveBrier,
                        historicalBrier: baseline?.historicalBrier,
                        historicalWinRate: baseline?.historicalWinRate
                    },

                    // Temporal validation
                    temporalSplit: temporal
                };
            }

            /**
             * Format Brier score for display with interpretation
             */
            function formatBrierScore(score) {
                if (score === null || score === undefined) return { value: '--', class: '', interpretation: '' };

                let interpretation, cssClass;
                if (score < 0.20) {
                    interpretation = 'Excellent';
                    cssClass = 'good';
                } else if (score < 0.22) {
                    interpretation = 'Good';
                    cssClass = 'good';
                } else if (score < 0.25) {
                    interpretation = 'Fair';
                    cssClass = 'warning';
                } else {
                    interpretation = 'Below baseline';
                    cssClass = 'bad';
                }

                return {
                    value: score.toFixed(4),
                    class: cssClass,
                    interpretation
                };
            }

            /**
             * Format skill score for display
             */
            function formatSkillScore(score) {
                if (score === null || score === undefined) return { value: '--', class: '' };

                const pct = (score * 100).toFixed(1);
                return {
                    value: `${score > 0 ? '+' : ''}${pct}%`,
                    class: score > 0.05 ? 'good' : score < -0.05 ? 'bad' : ''
                };
            }

            // =================================================================
            // IMPROVED ECE & DIAGNOSTIC TOOLS (Patch 7)
            // =================================================================

            /**
             * Expected Calibration Error (ECE) with equal-width bins.
             *
             * Replaces the coarse uneven bins [50,54,58,62,66,100] with
             * uniform bins across the [50,100] probability range.
             * Also computes Maximum Calibration Error (MCE)  the worst
             * single bin, useful for spotting systematic over/under-confidence.
             *
             * @param {Array} predictions  tracker picks with winProb, status, result
             * @param {number} numBins  bin count (default 10  5pp bins)
             * @returns {Object|null} { ece, mce, bins[], n } or null if insufficient data
             */
            function computeECE(predictions, numBins = 10) {
                const validPreds = predictions.filter(p =>
                    p.status === 'graded' &&
                    typeof p.winProb === 'number' &&
                    (p.result === 'win' || p.result === 'loss')
                );

                if (validPreds.length < 20) return null;

                // Only [50,100] range  we always express probability for the recommended side
                const binWidth = 50 / numBins;
                const bins = [];

                for (let i = 0; i < numBins; i++) {
                    const lo = 50 + i * binWidth;
                    const hi = 50 + (i + 1) * binWidth;
                    const inBin = validPreds.filter(p => p.winProb >= lo && (i === numBins - 1 ? p.winProb <= hi : p.winProb < hi));

                    if (inBin.length >= 3) { // minimum per-bin threshold
                        const avgPred = inBin.reduce((s, p) => s + p.winProb / 100, 0) / inBin.length;
                        const avgActual = inBin.filter(p => p.result === 'win').length / inBin.length;

                        bins.push({
                            range: `${lo.toFixed(0)}${hi.toFixed(0)}%`,
                            predicted: avgPred,
                            actual: avgActual,
                            n: inBin.length,
                            absError: Math.abs(avgPred - avgActual)
                        });
                    }
                }

                if (bins.length === 0) return null;

                const totalN = bins.reduce((s, b) => s + b.n, 0);
                const ece = bins.reduce((s, b) => s + b.absError * (b.n / totalN), 0);
                const mce = Math.max(...bins.map(b => b.absError));

                return { ece, mce, bins, n: totalN };
            }

            /**
             * Paired Log Loss significance test.
             *
             * For each aligned game i, computes LL_i = LL_A(i)  LL_B(i).
             * If the 95% CI on mean(LL) is entirely < 0, model A is
             * significantly better than model B.
             *
             * @param {Array} predsA  predictions from model A [{calibratedProb, outcome}, ...]
             * @param {Array} predsB  predictions from model B (same games, same order)
             * @returns {Object} { meanDelta, se, tStat, ci95, significant, n }
             */
            function pairedLogLossTest(predsA, predsB) {
                if (predsA.length !== predsB.length) {
                    throw new Error('Misaligned predictions: A has ' + predsA.length + ', B has ' + predsB.length);
                }

                const epsilon = 1e-15;
                const deltas = [];

                for (let i = 0; i < predsA.length; i++) {
                    const pA = Math.max(epsilon, Math.min(1 - epsilon, predsA[i].calibratedProb));
                    const pB = Math.max(epsilon, Math.min(1 - epsilon, predsB[i].calibratedProb));
                    const y = predsA[i].outcome;

                    const llA = -(y * Math.log(pA) + (1 - y) * Math.log(1 - pA));
                    const llB = -(y * Math.log(pB) + (1 - y) * Math.log(1 - pB));

                    deltas.push(llA - llB); // negative = A is better
                }

                const n = deltas.length;
                if (n < 10) return { meanDelta: NaN, se: NaN, tStat: NaN, ci95: [NaN, NaN], significant: false, n };

                const mean = deltas.reduce((s, d) => s + d, 0) / n;
                const variance = deltas.reduce((s, d) => s + (d - mean) ** 2, 0) / (n - 1);
                const se = Math.sqrt(variance / n);
                const tStat = se > 0 ? mean / se : 0;
                const ci95 = [mean - 1.96 * se, mean + 1.96 * se];

                return {
                    meanDelta: mean,
                    se,
                    tStat,
                    ci95,
                    significant: ci95[1] < 0, // true if A significantly better
                    n
                };
            }

            /**
             * Leakage guard unit test: verify no future data in training sets.
             *
             * For every prediction made on date D, asserts that all training
             * data has gameDate strictly before D.
             *
             * @param {Array} backtestResults  [{predictionDate, trainingGames[], calibrationFitDate}]
             * @returns {boolean} true if no violations found
             */
            function testNoLeakage(backtestResults) {
                let violations = 0;

                for (const pred of backtestResults) {
                    const predDate = new Date(pred.predictionDate);

                    if (pred.trainingGames) {
                        for (const trainGame of pred.trainingGames) {
                            if (new Date(trainGame.gameDate) >= predDate) {
                                console.error(`LEAKAGE: Training game ${trainGame.gameDate} >= prediction ${pred.predictionDate}`);
                                violations++;
                            }
                        }
                    }

                    if (pred.calibrationFitDate && new Date(pred.calibrationFitDate) >= predDate) {
                        console.error(`LEAKAGE: Calibration fit ${pred.calibrationFitDate} >= prediction ${pred.predictionDate}`);
                        violations++;
                    }
                }

                console.log(`[testNoLeakage] ${violations} violations in ${backtestResults.length} predictions`);
                return violations === 0;
            }

            /**
             * Split logic unit test: verify non-overlapping train/val sets
             * using the V3Enhanced.timeSeriesCV() fold generator.
             *
             * @returns {boolean} true if all folds have valStart > trainEnd
             */
            function testSplitLogic() {
                if (typeof SpreadSheetV3Enhanced === 'undefined' || !SpreadSheetV3Enhanced.timeSeriesCV) {
                    console.warn('[testSplitLogic] SpreadSheetV3Enhanced.timeSeriesCV not available');
                    return false;
                }

                // Mock data with known sequential dates
                const mockGames = Array.from({length: 100}, (_, i) => ({
                    gameDate: new Date(2025, 0, 1 + i).toISOString(),
                    home: { netRating: 10, offRating: 105, defRating: 95, conference: 'Big 12' },
                    away: { netRating: -5, offRating: 100, defRating: 105, conference: 'SEC' },
                    vegasSpread: -7,
                    actualResult: i % 2 === 0 ? 'win' : 'loss' // deterministic for reproducibility
                }));

                const folds = SpreadSheetV3Enhanced.timeSeriesCV(mockGames, 30, 20);

                for (const fold of folds) {
                    const trainEnd = new Date(fold.trainEnd);
                    const valStart = new Date(fold.valStart);

                    if (valStart <= trainEnd) {
                        console.error(`OVERLAP: valStart ${fold.valStart} <= trainEnd ${fold.trainEnd}`);
                        return false;
                    }
                }

                console.log(`[testSplitLogic] ${folds.length} folds, all non-overlapping `);
                return true;
            }

            // Public API
            return {
                analyze,
                calculateBrierScore,
                calculateLogLoss,
                calculateCalibration,
                calculateWinRateWithCI,
                calculateROIWithCI,
                calculateNaiveBaseline,
                temporalSplitCheck,
                bootstrapCI,
                formatBrierScore,
                formatSkillScore,
                // Patch 7 additions:
                computeECE,
                pairedLogLossTest,
                testNoLeakage,
                testSplitLogic
            };
        })();

        console.log(' AdvValidation Module Loaded');

        // ============================================================
        // MAIN APPLICATION CODE
        // ============================================================
        let state = { games: [], ratings: {}, ratingsOriginal: {}, teamsList: [], historicalGames: [], validationResults: [], theme: 'dark', currentSort: 'time', confFilter: 'all' };
        const HOME_COURT_ADVANTAGE = 3.5;
        const POWER_CONFERENCES = ['ACC', 'Big 12', 'Big Ten', 'Big East', 'SEC', 'Pac-12', 'AAC', 'Mountain West'];
        const MID_MAJOR_CONFERENCES = ['MAAC', 'MAC', 'WAC', 'Southland', 'SWAC', 'MEAC', 'Big South', 'OVC'];


        // Theme and settings functions
        function toggleTheme() { 
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            state.theme = newTheme;
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('spreadsheet_theme', newTheme);
            updateThemeUI(newTheme);
        }
        
        function updateThemeUI(theme) {
            const isDark = theme === 'dark';
            const themeIcon = document.getElementById('themeIcon');
            const themeSwitch = document.getElementById('themeToggleSwitch');
            if (themeIcon) themeIcon.textContent = isDark ? '' : '';
            if (themeSwitch) themeSwitch.setAttribute('aria-checked', isDark ? 'true' : 'false');
        }
        
        function loadTheme() { 
            const saved = localStorage.getItem('spreadsheet_theme') || 'light'; 
            state.theme = saved; 
            document.documentElement.setAttribute('data-theme', saved); 
            updateThemeUI(saved);
        }
        
        function toggleSettings() { showSettingsModal(); }
        
        // Settings Modal
        function showSettingsModal() {
            const existing = document.getElementById('settingsModal');
            if (existing) existing.remove();
            
            const currentProxy = document.getElementById('proxyUrl').value || '';
            const savedNotes = JSON.parse(localStorage.getItem('validationNotes') || '{"working":"","issues":""}');
            
            const modal = document.createElement('div');
            modal.id = 'settingsModal';
            modal.className = 'glossary-modal-overlay';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'settingsTitle');
            modal.innerHTML = `
                <div class="glossary-modal settings-modal">
                    <div class="glossary-header">
                        <h2 id="settingsTitle"> Settings</h2>
                        <button class="glossary-close" aria-label="Close">&times;</button>
                    </div>
                    <div class="glossary-content">
                        <div class="settings-section">
                            <h3> Data Connection</h3>
                            <div class="settings-field-modal">
                                <label class="settings-label">Proxy Server URL</label>
                                <input class="settings-input" type="text" id="settingsProxyUrl" value="${currentProxy}" placeholder="https://your-app.onrender.com">
                                <p class="settings-hint">Your Render proxy server URL for fetching odds and ratings data</p>
                            </div>
                            <button class="settings-save-btn" onclick="saveProxyUrl()">Save URL</button>
                        </div>
                        
                        <div class="settings-section">
                            <h3> Prediction Data</h3>
                            <p class="settings-hint">Export your prediction history to backup or transfer to another device. Import to restore from a backup.</p>
                            <div class="settings-buttons">
                                <button class="settings-action-btn" onclick="exportPredictions()">
                                    <span class="btn-icon"></span>
                                    <span>Export CSV</span>
                                </button>
                                <button class="settings-action-btn" onclick="sharePredictions()">
                                    <span class="btn-icon"></span>
                                    <span>Share</span>
                                </button>
                                <button class="settings-action-btn" onclick="document.getElementById('settingsImportInput').click()">
                                    <span class="btn-icon"></span>
                                    <span>Import CSV</span>
                                </button>
                                <input type="file" id="settingsImportInput" accept=".csv" style="display:none" onchange="importPredictions(this.files[0]); this.value='';">
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h3> Validation Notes</h3>
                            <p class="settings-hint">Track model performance observations. Only record fact-based findings from actual results.</p>
                            
                            <div class="validation-notes-container">
                                <div class="validation-notes-column">
                                    <label class="settings-label working"> What's Working</label>
                                    <textarea id="notesWorking" class="validation-notes-input" placeholder="Record patterns where model performs well...

Example format:
 Spreads 62%+ tier: 8-3 (72.7%)
 Home favorites -5 to -10: profitable
 Big Ten overs: strong edge">${savedNotes.working}</textarea>
                                </div>
                                <div class="validation-notes-column">
                                    <label class="settings-label issues"> Needs Improvement</label>
                                    <textarea id="notesIssues" class="validation-notes-input" placeholder="Record patterns where model struggles...

Example format:
 Road underdogs: 2-7 (22.2%)
 Totals in SEC games: no edge
 Late night games: poor accuracy">${savedNotes.issues}</textarea>
                                </div>
                            </div>
                            <button class="settings-save-btn" onclick="saveValidationNotes()">Save Notes</button>
                        </div>
                        
                        <div class="settings-section danger-zone">
                            <h3> Danger Zone</h3>
                            <p class="settings-hint">Clear all stored prediction data. This cannot be undone.</p>
                            <button class="settings-action-btn" style="background: var(--accent-yellow); margin-bottom: 0.5rem;" onclick="cleanupIncompletePredictions(); closeSettingsModal();">
                                <span class="btn-icon"></span>
                                <span>Remove Incomplete Picks</span>
                            </button>
                            <p class="settings-hint" style="font-size: 0.65rem; margin-top: 0;">Removes picks missing win% data (shown as "Unknown")</p>
                            <button class="settings-action-btn danger" onclick="clearAllPredictions(); closeSettingsModal();">
                                <span class="btn-icon"></span>
                                <span>Clear All Data</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close handlers
            modal.querySelector('.glossary-close').addEventListener('click', closeSettingsModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeSettingsModal();
            });
            
            // Focus trap
            setTimeout(() => modal.querySelector('.glossary-close').focus(), 100);
            
            // Escape key
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeSettingsModal();
            });
        }
        
        function closeSettingsModal() {
            const modal = document.getElementById('settingsModal');
            if (modal) modal.remove();
        }
        
        function saveValidationNotes() {
            const working = document.getElementById('notesWorking').value;
            const issues = document.getElementById('notesIssues').value;
            localStorage.setItem('validationNotes', JSON.stringify({ working, issues }));
            
            // Show confirmation
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' Saved!';
            btn.style.background = 'var(--accent-green)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 1500);
        }
        
        function saveProxyUrl() {
            const newUrl = document.getElementById('settingsProxyUrl').value.trim();
            document.getElementById('proxyUrl').value = newUrl;
            saveConfig();
            
            // Show confirmation
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' Saved!';
            btn.style.background = 'var(--accent-green)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 1500);
        }
        function saveConfig() { localStorage.setItem('spreadsheet_proxy', document.getElementById('proxyUrl').value); }
        function loadConfig() {
            const proxy = localStorage.getItem('spreadsheet_proxy');
            if (proxy) document.getElementById('proxyUrl').value = proxy;
            loadTheme();
            initHamburgerMenu();
            if (!proxy) setTimeout(() => showSettingsModal(), 300);
        }
        
        // ========== HAMBURGER MENU CONTROLLER ==========
        function initHamburgerMenu() {
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const dropdown = document.getElementById('hamburgerDropdown');
            const themeSwitch = document.getElementById('themeToggleSwitch');
            const menuItems = dropdown.querySelectorAll('.hamburger-dropdown-item');
            
            if (!hamburgerBtn || !dropdown) return;
            
            // Get all focusable elements in menu
            const getFocusableElements = () => {
                return [themeSwitch, ...menuItems].filter(el => el);
            };
            
            // Toggle menu
            function openMenu() {
                hamburgerBtn.setAttribute('aria-expanded', 'true');
                dropdown.classList.add('open');
                // Set first menu item focusable
                menuItems.forEach((item, i) => item.setAttribute('tabindex', i === 0 ? '0' : '-1'));
                themeSwitch?.setAttribute('tabindex', '0');
            }
            
            function closeMenu(returnFocus = true) {
                hamburgerBtn.setAttribute('aria-expanded', 'false');
                dropdown.classList.remove('open');
                menuItems.forEach(item => item.setAttribute('tabindex', '-1'));
                if (returnFocus) hamburgerBtn.focus();
            }
            
            function toggleMenu() {
                const isOpen = hamburgerBtn.getAttribute('aria-expanded') === 'true';
                if (isOpen) {
                    closeMenu();
                } else {
                    openMenu();
                }
            }
            
            // Hamburger button click
            hamburgerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu();
            });
            
            // Hamburger button keyboard
            hamburgerBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleMenu();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    openMenu();
                    const first = getFocusableElements()[0];
                    if (first) first.focus();
                }
            });
            
            // Theme switch handlers
            if (themeSwitch) {
                themeSwitch.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleTheme();
                });
                
                themeSwitch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleTheme();
                    }
                });
            }
            
            // Menu item clicks
            menuItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleMenuAction(item.dataset.action);
                    closeMenu();
                });
            });
            
            // Keyboard navigation within menu
            dropdown.addEventListener('keydown', (e) => {
                const focusable = getFocusableElements();
                const currentIndex = focusable.indexOf(document.activeElement);
                
                switch (e.key) {
                    case 'Escape':
                        e.preventDefault();
                        closeMenu();
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        if (currentIndex < focusable.length - 1) {
                            focusable[currentIndex + 1].focus();
                        } else {
                            focusable[0].focus();
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if (currentIndex > 0) {
                            focusable[currentIndex - 1].focus();
                        } else {
                            focusable[focusable.length - 1].focus();
                        }
                        break;
                    case 'Tab':
                        // Trap focus within menu
                        if (e.shiftKey && currentIndex === 0) {
                            e.preventDefault();
                            focusable[focusable.length - 1].focus();
                        } else if (!e.shiftKey && currentIndex === focusable.length - 1) {
                            e.preventDefault();
                            focusable[0].focus();
                        }
                        break;
                    case 'Home':
                        e.preventDefault();
                        focusable[0].focus();
                        break;
                    case 'End':
                        e.preventDefault();
                        focusable[focusable.length - 1].focus();
                        break;
                    case 'Enter':
                    case ' ':
                        if (document.activeElement.classList.contains('hamburger-dropdown-item')) {
                            e.preventDefault();
                            handleMenuAction(document.activeElement.dataset.action);
                            closeMenu();
                        }
                        break;
                }
            });
            
            // Close on outside click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.hamburger-menu-container')) {
                    if (hamburgerBtn.getAttribute('aria-expanded') === 'true') {
                        closeMenu(false);
                    }
                }
            });
            
            // Close on Escape anywhere
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && hamburgerBtn.getAttribute('aria-expanded') === 'true') {
                    closeMenu();
                }
            });
        }
        
        function handleMenuAction(action) {
            switch (action) {
                case 'settings':
                    toggleSettings();
                    break;
                case 'refresh':
                    refreshAllData();
                    break;
                case 'diagnostics':
                    showModelDiagnosticsModal();
                    break;
                case 'how':
                    showHowItWorksModal();
                    break;
                case 'glossary':
                    showGlossaryModal();
                    break;
            }
        }
        
        // How It Works Modal
        function showHowItWorksModal() {
            const existing = document.getElementById('howModal');
            if (existing) existing.remove();
            
            const modal = document.createElement('div');
            modal.id = 'howModal';
            modal.className = 'glossary-modal-overlay';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'howTitle');
            modal.innerHTML = `
                <div class="glossary-modal">
                    <div class="glossary-header">
                        <h2 id="howTitle"> How It Works</h2>
                        <button class="glossary-close" aria-label="Close">&times;</button>
                    </div>
                    <div class="glossary-content">
                        <dl class="glossary-list how-list">
                            <dt> Data Inputs</dt>
                            <dd>Live odds (spreads, totals) via The Odds API plus KenPom-style efficiency metrics: offensive rating, defensive rating, net rating, and national rank per team.</dd>
                            
                            <dt> Projections</dt>
                            <dd><strong>Spread:</strong> (Home Net  Away Net)  2 + Home Court Advantage (default 3.5, adjusted by conference). <strong>Total:</strong> (Avg Offensive + Avg Defensive)  0.68 pace factor. <strong>Edge:</strong> |Vegas Line  Model Projection|.</dd>
                            
                            <dt> Confidence Score (0100)</dt>
                            <dd>Weighted sum of 8 factors: Edge (25 pts), Power Rating Gap (18), Two-Way Excellence (12), Efficiency Mismatch (12), Defensive Strength (10), Situational (10), Key Numbers (8), Rank Disparity (5). <strong>Thresholds:</strong> 70+ Elite, 5069 Strong, 3049 Playable.</dd>
                            
                            <dt> Refresh</dt>
                            <dd>Re-fetches current odds and ratings from your proxy server, then recalculates all projections, edges, win probabilities, and confidence scores.</dd>
                            
                            <dt> Disclaimer</dt>
                            <dd>For informational and entertainment purposes only. No guarantees. Model does not account for injuries, suspensions, motivation, or late lineup changes. Always verify independently.</dd>
                        </dl>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            const closeBtn = modal.querySelector('.glossary-close');
            closeBtn.focus();
            
            const closeModal = () => {
                modal.remove();
                document.getElementById('hamburgerBtn')?.focus();
            };
            
            closeBtn.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeModal();
            });
        }
        
        // Glossary Modal
        function showGlossaryModal() {
            const existing = document.getElementById('glossaryModal');
            if (existing) existing.remove();
            
            const modal = document.createElement('div');
            modal.id = 'glossaryModal';
            modal.className = 'glossary-modal-overlay';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'glossaryTitle');
            modal.innerHTML = `
                <div class="glossary-modal" style="max-width:650px;">
                    <div class="glossary-header">
                        <h2 id="glossaryTitle"> Glossary</h2>
                        <button class="glossary-close" aria-label="Close glossary">&times;</button>
                    </div>
                    <div class="glossary-content">
                        <dl class="glossary-list alphabetical">
                            <dt>Best Bets</dt>
                            <dd>Top-ranked picks sorted by confidence score. Filter by threshold (30+, 50+, 70+).</dd>
                            
                            <dt>Blowout</dt>
                            <dd>Game won by 15+ points. Favors covering large spreads.</dd>
                            
                            <dt>Confidence Score</dt>
                            <dd>0100 composite rating. 70+ Elite, 5069 Strong, 3049 Playable, &lt;30 No edge.</dd>
                            
                            <dt>Cover</dt>
                            <dd>Beat the spread. A 7 favorite covers by winning 8+; a +7 dog covers by losing 6 or winning.</dd>
                            
                            <dt>Def Rating (DRtg)</dt>
                            <dd>Points allowed per 100 possessions (adjusted). Lower = better. Elite: &lt;95.</dd>
                            
                            <dt>Edge</dt>
                            <dd>Difference between model projection and Vegas line (in points). Larger = more value.</dd>
                            
                            <dt>Efficiency Mismatch</dt>
                            <dd>When a team's offensive strength exploits opponent's defensive weakness, or vice versa.</dd>
                            
                            <dt>EV (Expected Value)</dt>
                            <dd>Average profit per bet over time. Positive EV = long-term profitable.</dd>
                            
                            <dt>Favorite</dt>
                            <dd>Team expected to win, shown with negative spread (e.g., 5.5).</dd>
                            
                            <dt>Game Script</dt>
                            <dd>Probability distribution of game outcomes: blowout, comfortable win, close, nail-biter, OT.</dd>
                            
                            <dt>Home Court Advantage (HCA)</dt>
                            <dd>Points added to home team projection. Default 3.5; varies by conference (Big 12: 4.2, SEC: 3.9).</dd>
                            
                            <dt>Kelly Criterion</dt>
                            <dd>Formula for optimal bet sizing based on edge and estimated win probability.</dd>
                            
                            <dt>KenPom Rank</dt>
                            <dd>Team ranking from KenPom efficiency metrics. Lower = better. Top 25 = elite.</dd>
                            
                            <dt>Key Numbers</dt>
                            <dd>Common final margins (3, 4, 5, 6, 7, 10 in CBB). Lines on key numbers have different cover dynamics.</dd>
                            
                            <dt>Line Movement</dt>
                            <dd>Spread/total change from open to current. Sharp action typically moves lines.</dd>
                            
                            <dt>Mid-Major</dt>
                            <dd>Non-power conference (MAAC, MAC, WAC, etc.). Often less predictable as road underdogs.</dd>
                            
                            <dt>Nail-biter</dt>
                            <dd>Game decided by 13 points. High variance; small edges can flip outcomes.</dd>
                            
                            <dt>Net Rating</dt>
                            <dd>Offensive Rating minus Defensive Rating. Measures overall strength. +15 = elite.</dd>
                            
                            <dt>Off Rating (ORtg)</dt>
                            <dd>Points scored per 100 possessions (adjusted). Higher = better. Elite: &gt;110.</dd>
                            
                            <dt>Over/Under (O/U)</dt>
                            <dd>Bet on combined final score. Over wins if total exceeds line; Under if below.</dd>
                            
                            <dt>Pace</dt>
                            <dd>Possessions per game. Higher pace = more scoring chances; affects totals projections.</dd>
                            
                            <dt>Power Conference</dt>
                            <dd>ACC, Big 12, Big Ten, Big East, SEC, AAC, Mountain West. Stronger overall competition.</dd>
                            
                            <dt>Projected Spread</dt>
                            <dd>Model estimate: (Home Net  Away Net)  2 + HCA. Compare to Vegas for edge.</dd>
                            
                            <dt>Projected Total</dt>
                            <dd>Model estimate: (Avg ORtg + Avg DRtg)  0.68. Compare to Vegas O/U for edge.</dd>
                            
                            <dt>Push</dt>
                            <dd>Bet ties exactly on the number. Stake returned; no win or loss recorded.</dd>
                            
                            <dt>Regression</dt>
                            <dd>Teams with unsustainable stats (elite shooting, turnover luck) trending toward average.</dd>
                            
                            <dt>ROI</dt>
                            <dd>Return on Investment. Profit  total wagered. Need 52.4% wins at 110 to break even.</dd>
                            
                            <dt>Sharp Money</dt>
                            <dd>Wagers from professional bettors. Line moves toward sharp side often signal value.</dd>
                            
                            <dt>Spread</dt>
                            <dd>Point handicap for betting. Negative = favorite must win by that margin to cover.</dd>
                            
                            <dt>Tracker</dt>
                            <dd>Personal bet log. Track picks, record results (W/L), measure performance over time.</dd>
                            
                            <dt>Two-Way Excellence</dt>
                            <dd>Teams elite on both ends: ORtg &gt;110 and DRtg &lt;100. Historically cover at higher rates.</dd>
                            
                            <dt>Underdog</dt>
                            <dd>Team expected to lose, shown with positive spread (e.g., +5.5).</dd>
                            
                            <dt>Units (u)</dt>
                            <dd>Standardized bet size. 1u = your base wager. Scale up for higher confidence picks.</dd>
                            
                            <dt>Validation</dt>
                            <dd>Backtesting model picks against completed games to measure historical accuracy.</dd>
                            
                            <dt>Win Prob</dt>
                            <dd>Estimated probability of covering, derived from projection edge via normal distribution.</dd>
                        </dl>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            const closeBtn = modal.querySelector('.glossary-close');
            closeBtn.focus();
            
            const closeModal = () => {
                modal.remove();
                document.getElementById('hamburgerBtn')?.focus();
            };
            
            closeBtn.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal();
            });
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeModal();
            });
        }

        // ============================================================
        // API FUNCTIONS - With retry logic and better error handling
        // ============================================================

        // Robust fetch with retry, timeout, and exponential backoff
        async function fetchWithRetry(url, options = {}, maxRetries = 2, timeoutMs = 15000) {
            let lastError;
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        if (response.status === 429) {
                            // Rate limited - wait and retry
                            const retryAfter = parseInt(response.headers.get('Retry-After') || '5', 10);
                            console.warn(`[API] Rate limited, waiting ${retryAfter}s...`);
                            await new Promise(r => setTimeout(r, retryAfter * 1000));
                            continue;
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const text = await response.text();
                    if (text.startsWith('<!') || text.startsWith('<html')) {
                        throw new Error('Received HTML instead of JSON (check proxy URL)');
                    }

                    try {
                        return JSON.parse(text);
                    } catch (parseErr) {
                        throw new Error(`Invalid JSON: ${parseErr.message}`);
                    }
                } catch (err) {
                    lastError = err;
                    if (err.name === 'AbortError') {
                        lastError = new Error(`Request timeout after ${timeoutMs}ms`);
                    }
                    console.warn(`[API] Attempt ${attempt + 1}/${maxRetries + 1} failed:`, lastError.message);
                    if (attempt < maxRetries) {
                        await new Promise(r => setTimeout(r, 1000 * (attempt + 1)));
                    }
                }
            }
            throw lastError;
        }

        async function fetchOddsGames() {
            const proxyUrl = document.getElementById('proxyUrl').value.trim();
            if (!proxyUrl) throw new Error('Enter proxy URL');
            return fetchWithRetry(`${proxyUrl}/api/odds`, { headers: { 'ngrok-skip-browser-warning': 'true' } });
        }

        async function fetchRatings() {
            const proxyUrl = document.getElementById('proxyUrl').value.trim();
            if (!proxyUrl) throw new Error('Enter proxy URL');
            return fetchWithRetry(`${proxyUrl}/api/ratings?season=2026`, { headers: { 'ngrok-skip-browser-warning': 'true' } });
        }

        async function fetchHistoricalGames() {
            const proxyUrl = document.getElementById('proxyUrl').value.trim();
            if (!proxyUrl) throw new Error('Enter proxy URL');
            return fetchWithRetry(`${proxyUrl}/api/games?season=2026`, { headers: { 'ngrok-skip-browser-warning': 'true' } });
        }

        // Process ratings - store both normalized and original for matching
        // With defensive validation for missing/malformed data
        function processRatings(data) {
            state.ratings = {};
            state.ratingsOriginal = {};

            if (!Array.isArray(data)) {
                console.error('[processRatings] Expected array, got:', typeof data);
                return;
            }

            let skipped = 0;
            data.forEach((t, idx) => {
                // Validate required fields
                if (!t || typeof t.team !== 'string' || !t.team.trim()) {
                    console.warn(`[processRatings] Skipping entry ${idx}: missing team name`);
                    skipped++;
                    return;
                }

                // Coerce ratings to numbers with fallback
                const offRating = parseFloat(t.offensiveRating);
                const defRating = parseFloat(t.defensiveRating);
                const netRating = parseFloat(t.netRating);

                if (isNaN(offRating) || isNaN(defRating)) {
                    console.warn(`[processRatings] Skipping ${t.team}: invalid ratings (off=${t.offensiveRating}, def=${t.defensiveRating})`);
                    skipped++;
                    return;
                }

                const n = normalizeTeamName(t.team);
                const conferenceOverride = CONFERENCE_OVERRIDES[n] || CONFERENCE_OVERRIDES[t.team.toLowerCase()];
                const rating = {
                    name: t.team,
                    conference: conferenceOverride || t.conference || 'Unknown',
                    offRating: offRating,
                    defRating: defRating,
                    netRating: isNaN(netRating) ? offRating - defRating : netRating,
                    rank: (t.rankings && typeof t.rankings.net === 'number') ? t.rankings.net : 999,
                    pace: parseFloat(t.adjustedTempo || t.tempo || t.pace) || null,
                    gamesPlayed: parseInt(t.gamesPlayed || t.games || t.wins + t.losses) || null
                };
                state.ratings[n] = rating;
                state.ratingsOriginal[t.team.toLowerCase()] = rating;
            });

            if (skipped > 0) {
                console.warn(`[processRatings] Skipped ${skipped} invalid entries`);
            }
            console.log(`[processRatings] Loaded ${Object.keys(state.ratings).length} teams`);
        }
        
        // Simple normalization - convert hyphens to spaces before removing special chars
        function normalizeTeamName(name) { 
            return name.toLowerCase()
                .replace(/-/g, ' ')  // Convert hyphens to spaces FIRST
                .replace(/\bstate\b/g, 'st')
                .replace(/[^a-z0-9\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim(); 
        }
        
        // Conference override table - corrects incorrect conference assignments from API
        // Must be defined BEFORE processRatings uses it
        const CONFERENCE_OVERRIDES = {
            // UT Martin - API incorrectly lists as SEC, should be OVC
            'ut martin': 'OVC',
            'ut martin skyhawks': 'OVC',
            'tennessee martin': 'OVC',
            'tennessee martin skyhawks': 'OVC',
            'tenn martin': 'OVC',
            'tenn martin skyhawks': 'OVC',
            'tenn-martin': 'OVC',
            'tenn-martin skyhawks': 'OVC',
            'tennmartin': 'OVC',
            'utmartin': 'OVC',
            'martin': 'OVC',  // Just in case it's shortened
            // Add more overrides as needed
        };
        
        // EXPLICIT MAPPING: Odds API team name -> Ratings team name
        // This handles all the problematic cases where fuzzy matching fails
        const TEAM_NAME_OVERRIDES = {
            // Maryland schools
            'maryland-eastern shore hawks': 'maryland eastern shore',
            'maryland eastern shore hawks': 'maryland eastern shore',
            'maryland terrapins': 'maryland',
            
            // Miami schools  
            'miami (oh) redhawks': 'miami oh',
            'miami redhawks': 'miami oh',
            'miami hurricanes': 'miami',
            'miami (fl) hurricanes': 'miami',
            
            // Michigan schools
            'central michigan chippewas': 'central michigan',
            'eastern michigan eagles': 'eastern michigan',
            'western michigan broncos': 'western michigan',
            'michigan wolverines': 'michigan',
            'michigan state spartans': 'michigan st',
            
            // Indiana schools
            'indiana state sycamores': 'indiana st',
            'indiana st sycamores': 'indiana st',
            'indiana hoosiers': 'indiana',
            'indiana purdue-indianapolis jaguars': 'iupui',
            'iupui jaguars': 'iupui',
            'purdue fort wayne mastodons': 'purdue fort wayne',
            
            // Tennessee schools
            'east tennessee state buccaneers': 'east tennessee st',
            'east tennessee st buccaneers': 'east tennessee st',
            'middle tennessee blue raiders': 'middle tennessee',
            'tennessee state tigers': 'tennessee st',
            'tennessee tech golden eagles': 'tennessee tech',
            'tennessee volunteers': 'tennessee',
            'tennessee martin skyhawks': 'ut martin',
            'tenn-martin skyhawks': 'ut martin',
            'tenn martin skyhawks': 'ut martin',
            
            // Kentucky schools
            'eastern kentucky colonels': 'eastern kentucky',
            'western kentucky hilltoppers': 'western kentucky',
            'kentucky wildcats': 'kentucky',
            'murray state racers': 'murray st',
            'morehead state eagles': 'morehead st',
            'northern kentucky norse': 'northern kentucky',
            
            // Illinois schools
            'northern illinois huskies': 'northern illinois',
            'southern illinois salukis': 'southern illinois',
            'illinois state redbirds': 'illinois st',
            'illinois fighting illini': 'illinois',
            'eastern illinois panthers': 'eastern illinois',
            'western illinois leathernecks': 'western illinois',
            'illinois chicago flames': 'uic',
            
            // Ohio schools
            'ohio bobcats': 'ohio',
            'ohio state buckeyes': 'ohio st',
            
            // Carolina schools
            'north carolina tar heels': 'north carolina',
            'north carolina state wolfpack': 'nc st',
            'nc state wolfpack': 'nc st',
            'south carolina gamecocks': 'south carolina',
            'south carolina state bulldogs': 'south carolina st',
            'east carolina pirates': 'east carolina',
            'coastal carolina chanticleers': 'coastal carolina',
            'north carolina at aggies': 'north carolina at',
            'north carolina central eagles': 'north carolina central',
            'unc wilmington seahawks': 'unc wilmington',
            'unc greensboro spartans': 'unc greensboro',
            'unc asheville bulldogs': 'unc asheville',
            
            // Washington schools
            'eastern washington eagles': 'eastern washington',
            'washington huskies': 'washington',
            'washington state cougars': 'washington st',
            
            // Florida schools
            'florida gators': 'florida',
            'florida state seminoles': 'florida st',
            'florida atlantic owls': 'florida atlantic',
            'florida international panthers': 'florida international',
            'florida intl golden panthers': 'florida international',
            'fiu golden panthers': 'florida international',
            'fiu panthers': 'florida international',
            'fiu': 'florida international',
            'florida gulf coast eagles': 'florida gulf coast',
            'south florida bulls': 'south florida',
            'central florida knights': 'ucf',
            'florida am rattlers': 'florida am',
            
            // Texas schools
            'texas longhorns': 'texas',
            'texas state bobcats': 'texas st',
            'texas tech red raiders': 'texas tech',
            'texas am aggies': 'texas am',
            'texas am corpus christi islanders': 'texas am corpus christi',
            'texas am cc islanders': 'texas am corpus christi',
            'texas am corpus christi islanders': 'texas am corpus christi',
            'texas amcc islanders': 'texas am corpus christi',
            'east texas am lions': 'east texas am',
            'north texas mean green': 'north texas',
            'texas southern tigers': 'texas southern',
            'texas arlington mavericks': 'ut arlington',
            'ut arlington mavericks': 'ut arlington',
            'utsa roadrunners': 'utsa',
            'utep miners': 'utep',
            'sam houston bearkats': 'sam houston st',
            'sam houston st bearkats': 'sam houston st',
            'stephen f. austin lumberjacks': 'stephen f austin',
            'prairie view am panthers': 'prairie view',
            'texas rio grande valley vaqueros': 'ut rio grande valley',
            
            // Louisiana schools
            'louisiana ragin cajuns': 'louisiana',
            'louisiana tech bulldogs': 'louisiana tech',
            'lsu tigers': 'lsu',
            'louisiana monroe warhawks': 'louisiana monroe',
            'southeastern louisiana lions': 'southeastern louisiana',
            'northwestern state demons': 'northwestern st',
            'nicholls state colonels': 'nicholls st',
            'mcneese cowboys': 'mcneese',
            'new orleans privateers': 'new orleans',
            'grambling state tigers': 'grambling',
            'southern jaguars': 'southern',
            
            // Mississippi schools
            'mississippi state bulldogs': 'mississippi st',
            'ole miss rebels': 'ole miss',
            'southern miss golden eagles': 'southern miss',
            'jackson state tigers': 'jackson st',
            'jackson st tigers': 'jackson st',
            'mississippi valley state delta devils': 'mississippi valley st',
            'alcorn state braves': 'alcorn st',
            
            // Alabama schools
            'alabama crimson tide': 'alabama',
            'alabama state hornets': 'alabama st',
            'alabama am bulldogs': 'alabama am',
            'uab blazers': 'uab',
            'south alabama jaguars': 'south alabama',
            'troy trojans': 'troy',
            'jacksonville state gamecocks': 'jacksonville st',
            'samford bulldogs': 'samford',
            
            // Virginia schools
            'virginia cavaliers': 'virginia',
            'virginia tech hokies': 'virginia tech',
            'virginia commonwealth rams': 'vcu',
            'old dominion monarchs': 'old dominion',
            'james madison dukes': 'james madison',
            'george mason patriots': 'george mason',
            'william mary tribe': 'william mary',
            'norfolk state spartans': 'norfolk st',
            'hampton pirates': 'hampton',
            'radford highlanders': 'radford',
            'liberty flames': 'liberty',
            'longwood lancers': 'longwood',
            
            // Georgia schools
            'georgia bulldogs': 'georgia',
            'georgia tech yellow jackets': 'georgia tech',
            'georgia state panthers': 'georgia st',
            'georgia southern eagles': 'georgia southern',
            'kennesaw state owls': 'kennesaw st',
            'mercer bears': 'mercer',
            
            // Missouri schools
            'missouri tigers': 'missouri',
            'missouri state bears': 'missouri st',
            'southeast missouri state redhawks': 'southeast missouri st',
            
            // Iowa schools
            'iowa hawkeyes': 'iowa',
            'iowa state cyclones': 'iowa st',
            'northern iowa panthers': 'northern iowa',
            'drake bulldogs': 'drake',
            
            // Kansas schools
            'kansas jayhawks': 'kansas',
            'kansas state wildcats': 'kansas st',
            'wichita state shockers': 'wichita st',
            
            // Oklahoma schools
            'oklahoma sooners': 'oklahoma',
            'oklahoma state cowboys': 'oklahoma st',
            'oral roberts golden eagles': 'oral roberts',
            'tulsa golden hurricane': 'tulsa',
            
            // Arizona schools
            'arizona wildcats': 'arizona',
            'arizona state sun devils': 'arizona st',
            'northern arizona lumberjacks': 'northern arizona',
            'grand canyon antelopes': 'grand canyon',
            
            // Colorado schools
            'colorado buffaloes': 'colorado',
            'colorado state rams': 'colorado st',
            'air force falcons': 'air force',
            'denver pioneers': 'denver',
            'northern colorado bears': 'northern colorado',
            
            // Oregon schools
            'oregon ducks': 'oregon',
            'oregon state beavers': 'oregon st',
            'portland pilots': 'portland',
            'portland state vikings': 'portland st',
            
            // California schools
            'california golden bears': 'california',
            'usc trojans': 'usc',
            'ucla bruins': 'ucla',
            'stanford cardinal': 'stanford',
            'san diego state aztecs': 'san diego st',
            'fresno state bulldogs': 'fresno st',
            'san jose state spartans': 'san jose st',
            'cal poly mustangs': 'cal poly',
            'uc santa barbara gauchos': 'uc santa barbara',
            'uc irvine anteaters': 'uc irvine',
            'uc davis aggies': 'uc davis',
            'uc riverside highlanders': 'uc riverside',
            'long beach state beach': 'long beach st',
            'cal state fullerton titans': 'cal st fullerton',
            'cal state northridge matadors': 'cal st northridge',
            'san diego toreros': 'san diego',
            'pepperdine waves': 'pepperdine',
            'loyola marymount lions': 'loyola marymount',
            'santa clara broncos': 'santa clara',
            'saint marys gaels': 'saint marys',
            'san francisco dons': 'san francisco',
            'pacific tigers': 'pacific',
            'sacramento state hornets': 'sacramento st',
            
            // Nevada schools
            'unlv rebels': 'unlv',
            'nevada wolf pack': 'nevada',
            
            // Utah schools
            'utah utes': 'utah',
            'utah state aggies': 'utah st',
            'brigham young cougars': 'byu',
            'byu cougars': 'byu',
            'southern utah thunderbirds': 'southern utah',
            'utah valley wolverines': 'utah valley',
            'weber state wildcats': 'weber st',
            
            // New Mexico schools
            'new mexico lobos': 'new mexico',
            'new mexico state aggies': 'new mexico st',
            
            // Wyoming/Montana/Dakotas
            'wyoming cowboys': 'wyoming',
            'montana grizzlies': 'montana',
            'montana state bobcats': 'montana st',
            'north dakota fighting hawks': 'north dakota',
            'north dakota state bison': 'north dakota st',
            'south dakota coyotes': 'south dakota',
            'south dakota state jackrabbits': 'south dakota st',
            
            // MAC schools
            'toledo rockets': 'toledo',
            'bowling green falcons': 'bowling green',
            'ball state cardinals': 'ball st',
            'kent state golden flashes': 'kent st',
            'akron zips': 'akron',
            'buffalo bulls': 'buffalo',
            
            // Big name schools
            'duke blue devils': 'duke',
            'north carolina tar heels': 'north carolina',
            'gonzaga bulldogs': 'gonzaga',
            'villanova wildcats': 'villanova',
            'uconn huskies': 'uconn',
            'connecticut huskies': 'uconn',
            'purdue boilermakers': 'purdue',
            'auburn tigers': 'auburn',
            'houston cougars': 'houston',
            'arkansas razorbacks': 'arkansas',
            'tennessee volunteers': 'tennessee',
            'creighton bluejays': 'creighton',
            'marquette golden eagles': 'marquette',
            'xavier musketeers': 'xavier',
            'providence friars': 'providence',
            'seton hall pirates': 'seton hall',
            'st. johns red storm': 'st johns',
            'depaul blue demons': 'depaul',
            'butler bulldogs': 'butler',
            'georgetown hoyas': 'georgetown',
            'notre dame fighting irish': 'notre dame',
            'louisville cardinals': 'louisville',
            'pittsburgh panthers': 'pittsburgh',
            'syracuse orange': 'syracuse',
            'clemson tigers': 'clemson',
            'wake forest demon deacons': 'wake forest',
            'boston college eagles': 'boston college',
            'minnesota golden gophers': 'minnesota',
            'wisconsin badgers': 'wisconsin',
            'nebraska cornhuskers': 'nebraska',
            'northwestern wildcats': 'northwestern',
            'rutgers scarlet knights': 'rutgers',
            'penn state nittany lions': 'penn st',
            'west virginia mountaineers': 'west virginia',
            'cincinnati bearcats': 'cincinnati',
            'baylor bears': 'baylor',
            'tcu horned frogs': 'tcu',
            'memphis tigers': 'memphis',
            'smu mustangs': 'smu',
            'tulane green wave': 'tulane',
            'temple owls': 'temple',
            'rice owls': 'rice',
            'charlotte 49ers': 'charlotte',
            'dayton flyers': 'dayton',
            'saint louis billikens': 'saint louis',
            'davidson wildcats': 'davidson',
            'richmond spiders': 'richmond',
            'fordham rams': 'fordham',
            'george washington colonials': 'george washington',
            'gw revolutionaries': 'george washington',
            'george washington revolutionaries': 'george washington',
            'la salle explorers': 'la salle',
            'massachusetts minutemen': 'massachusetts',
            'rhode island rams': 'rhode island',
            'st. bonaventure bonnies': 'st bonaventure',
            'duquesne dukes': 'duquesne',
            'loyola chicago ramblers': 'loyola chicago',
            'loyola md greyhounds': 'loyola md',
            'loyola maryland greyhounds': 'loyola md',
            'valparaiso beacons': 'valparaiso',
            'evansville purple aces': 'evansville',
            'bradley braves': 'bradley',
            'belmont bruins': 'belmont',
            'murray state racers': 'murray st',
            'austin peay governors': 'austin peay',
            'lipscomb bisons': 'lipscomb'
        };
        
        // Convert Odds API team name to ratings-style name for matching
        // This strips mascots and applies overrides
        function toRatingsName(oddsApiName) {
            if (!oddsApiName) return '';
            const lower = oddsApiName.toLowerCase();
            
            // Check TEAM_NAME_OVERRIDES first (maps "duke blue devils"  "duke")
            const searchForOverride = lower.replace(/-/g, ' ').replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ').trim();
            if (TEAM_NAME_OVERRIDES[searchForOverride]) {
                return TEAM_NAME_OVERRIDES[searchForOverride].toLowerCase();
            }
            if (TEAM_NAME_OVERRIDES[lower]) {
                return TEAM_NAME_OVERRIDES[lower].toLowerCase();
            }
            
            // Strip common mascot patterns
            // Format: "School Name Mascots"  "School Name"
            const mascotPatterns = [
                /\s+(blue devils|bulldogs|cardinals|cavaliers|demons|eagles|gators|hawks|hoosiers|huskies|hurricanes|jayhawks|longhorns|mountaineers|musketeers|orangemen|panthers|patriots|pilots|pioneers|pirates|raiders|rams|razorbacks|rebels|red storm|redhawks|scarlet knights|seminoles|sooners|spartans|tar heels|terrapins|tigers|trojans|volunteers|wildcats|wolfpack|yellow jackets|zags|bruins|aggies|badgers|bearcats|bears|beavers|big green|bison|bisons|bobcats|boilermakers|bonnies|braves|broncos|buckeyes|buffaloes|catamounts|chanticleers|colonels|commodores|cornhuskers|cougars|cowboys|crimson|crimson tide|crusaders|dons|dukes|explorers|falcons|fighting illini|fighting irish|flames|flyers|friars|gamecocks|gaels|golden bears|golden eagles|golden flash|golden gophers|golden grizzlies|great danes|green wave|greyhounds|grizzlies|hatters|highlanders|hilltoppers|hokies|horned frogs|jaguars|jaspers|jennies|kangaroos|knights|leathernecks|leopards|lobos|lumberjacks|mastodons|mean green|midshipmen|miners|minutemen|monarchs|mocs|nittany lions|norse|ospreys|owls|paladins|peacocks|penguins|phoenix|racers|railsplitters|ramblers|rattlers|red foxes|roadrunners|rockets|royals|running rebels|salukis|seawolves|shockers|skyhawks|spiders|stags|sycamores|terriers|thundering herd|toreros|tribe|tritons|utes|vandals|vikings|violets|waves|wolverines|warhawks|warriors|zips|49ers|billikens|beacons|purple aces|governors|colonials|revolutionaries)$/i
            ];
            
            let cleaned = lower;
            for (const pattern of mascotPatterns) {
                cleaned = cleaned.replace(pattern, '');
            }
            
            return normalizeTeamName(cleaned.trim());
        }
        
        // Score-based team matching - finds the BEST match, not first match
        function findTeamRating(teamName) { 
            if (!teamName) return null;
            if (!state.ratings || Object.keys(state.ratings).length === 0) return null;
            
            const searchLower = teamName.toLowerCase().trim();
            const searchNorm = normalizeTeamName(teamName);
            
            // 0. CHECK OVERRIDE TABLE FIRST - this handles all known problem cases
            // Strip ALL special characters for override matching (handles curly quotes, etc.)
            const searchForOverride = searchLower.replace(/-/g, ' ').replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ').trim();
            
            if (TEAM_NAME_OVERRIDES[searchForOverride]) {
                const overrideName = TEAM_NAME_OVERRIDES[searchForOverride];
                const overrideNorm = normalizeTeamName(overrideName);
                
                // Look for EXACT match first
                if (state.ratings[overrideNorm]) {
                    return state.ratings[overrideNorm];
                }
                // Try startsWith match (e.g., 'florida intl' matches 'florida intl panthers')
                for (const [key, rating] of Object.entries(state.ratings)) {
                    if (key.startsWith(overrideNorm) || overrideNorm.startsWith(key)) {
                        return rating;
                    }
                }
                // Try contains match as last resort
                for (const [key, rating] of Object.entries(state.ratings)) {
                    if (key.includes(overrideNorm) || overrideNorm.includes(key)) {
                        return rating;
                    }
                }
            }
            // Also check with the original (for cases with special chars kept)
            if (TEAM_NAME_OVERRIDES[searchLower] && TEAM_NAME_OVERRIDES[searchLower] !== TEAM_NAME_OVERRIDES[searchForOverride]) {
                const overrideName = TEAM_NAME_OVERRIDES[searchLower];
                const overrideNorm = normalizeTeamName(overrideName);
                if (state.ratings[overrideNorm]) {
                    return state.ratings[overrideNorm];
                }
            }
            
            // 1. EXACT match on original name - return immediately
            if (state.ratingsOriginal && state.ratingsOriginal[searchLower]) {
                return state.ratingsOriginal[searchLower];
            }
            
            // 2. EXACT match on normalized name - return immediately
            if (state.ratings[searchNorm]) {
                return state.ratings[searchNorm];
            }
            
            // 3. Score all potential matches and pick the best one
            let bestMatch = null;
            let bestScore = -999;
            
            const searchWords = searchNorm.split(/\s+/);
            // Remove common suffixes for matching
            const searchWordsCore = searchWords.filter(w => !['st', 'state', 'university', 'college'].includes(w));
            
            for (const [key, rating] of Object.entries(state.ratings)) {
                let score = 0;
                const keyWords = key.split(/\s+/);
                const keyWordsCore = keyWords.filter(w => !['st', 'state', 'university', 'college'].includes(w));
                
                // Count how many key words are found in search
                let keyWordsFoundInSearch = 0;
                for (const kw of keyWordsCore) {
                    if (searchWordsCore.some(sw => sw === kw || (sw.length >= 4 && kw.length >= 4 && (sw.startsWith(kw) || kw.startsWith(sw))))) {
                        keyWordsFoundInSearch++;
                    }
                }
                
                // Count how many search words are found in key
                let searchWordsFoundInKey = 0;
                for (const sw of searchWordsCore) {
                    if (keyWordsCore.some(kw => sw === kw || (sw.length >= 4 && kw.length >= 4 && (sw.startsWith(kw) || kw.startsWith(sw))))) {
                        searchWordsFoundInKey++;
                    }
                }
                
                // Skip if no words match
                if (keyWordsFoundInSearch === 0) continue;
                
                // KEY RULE: ALL core words in the rating name must be found in the search
                // This prevents "Indiana" from matching "Indiana St Sycamores" because
                // "Indiana" has 1 core word and "Indiana St" has 2 core words
                if (keyWordsFoundInSearch < keyWordsCore.length) {
                    continue; // Not all key words found, skip this match
                }
                
                // Score based on completeness of match
                score = keyWordsFoundInSearch * 10;
                
                // Bonus for matching word counts (exact name match)
                if (keyWordsCore.length === searchWordsCore.length) {
                    score += 20;
                }
                
                // Bonus if key has "st" and search has "st" (both are state schools)
                const keyHasSt = keyWords.includes('st');
                const searchHasSt = searchWords.includes('st');
                if (keyHasSt && searchHasSt) {
                    score += 15;
                } else if (keyHasSt !== searchHasSt) {
                    score -= 30; // Penalty for st mismatch - "Indiana" vs "Indiana St"
                }
                
                // Small penalty for length difference
                score -= Math.abs(key.length - searchNorm.length) * 0.1;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = rating;
                }
            }
            
            // Only return if we have a match
            if (bestMatch && bestScore > 0) {
                return bestMatch;
            }
            
            return null; 
        }

        function processGames(data) {
            state.games = [];
            const storedOdds = getStoredOdds();
            const missingTeams = new Set();
            const now = Date.now();
            let skippedLive = 0;
            console.log('[processGames] Starting to process', data?.length || 0, 'games');

            // Build rest days cache from historical games
            const restCache = buildRestDaysCache();

            data.forEach((g, idx) => {
                try {
                    // Skip games that have already started (live/in-progress lines are unreliable)
                    const gameStart = new Date(g.commence_time).getTime();
                    if (gameStart <= now) {
                        skippedLive++;
                        return;
                    }

                    const hr = findTeamRating(g.home_team);
                    const ar = findTeamRating(g.away_team);

                    // Log missing team ratings for debugging
                    if (!hr) missingTeams.add(g.home_team);
                    if (!ar) missingTeams.add(g.away_team);

                    let spread = null, total = null, book = null;
                    if (g.bookmakers?.length) {
                        const b = g.bookmakers.find(x => ['draftkings','fanduel','betmgm'].includes(x.key)) || g.bookmakers[0];
                        book = b.title;
                        b.markets.forEach(m => {
                            if (m.key === 'spreads') { const hs = m.outcomes.find(o => o.name === g.home_team); if (hs) spread = hs.point; }
                            if (m.key === 'totals') { const ov = m.outcomes.find(o => o.name === 'Over'); if (ov) total = ov.point; }
                        });
                    }

                    // Store the odds for future validation
                    if (spread !== null || total !== null) {
                        const gameKey = makeGameKey(g.home_team, g.away_team, g.commence_time);
                        storedOdds[gameKey] = { spread, total, savedAt: new Date().toISOString() };
                    }

                    // Compute rest days from cache
                    const gameDate = new Date(g.commence_time);
                    const homeCanon = hr?.name || g.home_team;
                    const awayCanon = ar?.name || g.away_team;
                    const homeRest = computeRestFromCache(restCache, homeCanon, gameDate);
                    const awayRest = computeRestFromCache(restCache, awayCanon, gameDate);

                    const gameContext = {
                        homeRestDays: homeRest,
                        awayRestDays: awayRest
                    };

                    const a = analyzeGame(hr, ar, spread, total, g.home_team, g.away_team, gameContext);
                    state.games.push({ 
                        id: g.id, homeTeam: g.home_team, awayTeam: g.away_team, 
                        homeRating: hr, awayRating: ar, commenceTime: gameDate, 
                        spread, total, bookmaker: book, analysis: a,
                        homeRestDays: homeRest, awayRestDays: awayRest
                    });
                } catch (err) {
                    console.error(`[processGames] Error on game ${idx}:`, g.home_team, 'vs', g.away_team, err.message);
                }
            }); 
            
            if (skippedLive > 0) {
                console.log(` Filtered out ${skippedLive} live/started games`);
            }
            
            // Log missing teams to console for debugging
            if (missingTeams.size > 0) {
                console.warn(' Teams missing from ratings:', Array.from(missingTeams).sort());
            }
            
            // Log rest days stats
            const gamesWithRest = state.games.filter(g => g.homeRestDays != null && g.awayRestDays != null);
            const restMismatches = gamesWithRest.filter(g => Math.abs(g.homeRestDays - g.awayRestDays) >= 2);
            const b2bs = gamesWithRest.filter(g => g.homeRestDays <= 1 || g.awayRestDays <= 1);
            console.log(` Rest days: ${gamesWithRest.length}/${state.games.length} games computed, ${restMismatches.length} rest mismatches (2d), ${b2bs.length} B2B situations`);
            
            // Save updated odds to localStorage
            saveStoredOdds(storedOdds);
            
            state.games.sort((a, b) => (b.analysis?.confidence || 0) - (a.analysis?.confidence || 0));
            console.log('[processGames] Finished with', state.games.length, 'games in state');
        }
        
        // === REST DAYS CACHE ===
        // Precomputes each team's most recent game date from historical data.
        // Uses findTeamRating to bridge name differences between data sources.
        function buildRestDaysCache() {
            const cache = {}; // canonicalName  Date of last game
            if (!state.historicalGames || !state.historicalGames.length) return cache;

            // Historical games are sorted most-recent-first
            // We also maintain a name resolution cache to avoid repeated findTeamRating calls
            const nameResolution = {}; // rawName  canonicalName or null
            let resolved = 0;

            for (const game of state.historicalGames) {
                for (const rawName of [game.homeTeam, game.awayTeam]) {
                    if (!rawName) continue;
                    
                    // Resolve canonical name (cached)
                    if (!(rawName in nameResolution)) {
                        const rating = findTeamRating(rawName);
                        nameResolution[rawName] = rating?.name || rawName;
                    }
                    const canon = nameResolution[rawName];
                    
                    // Only store the first (most recent) occurrence
                    if (!cache[canon]) {
                        const gameDate = new Date(game.date);
                        if (!isNaN(gameDate.getTime())) {
                            cache[canon] = gameDate;
                            resolved++;
                        }
                    }
                }
                // Once we've found ~400 unique teams, we have coverage for all D1
                if (resolved >= 400) break;
            }

            console.log(` Rest cache: ${Object.keys(cache).length} teams mapped from ${state.historicalGames.length} historical games`);
            return cache;
        }

        function computeRestFromCache(cache, canonName, gameDate) {
            if (!cache || !canonName || !gameDate) return null;
            const lastGame = cache[canonName];
            if (!lastGame) return null;
            const diffMs = gameDate.getTime() - lastGame.getTime();
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            return Math.max(0, Math.min(7, diffDays)); // Cap at 7
        }
        
        // === ODDS STORAGE FOR VALIDATION ===
        function makeGameKey(homeTeam, awayTeam, date) {
            const dateStr = new Date(date).toISOString().split('T')[0];
            const home = homeTeam.toLowerCase().replace(/[^a-z]/g, '');
            const away = awayTeam.toLowerCase().replace(/[^a-z]/g, '');
            return `${dateStr}_${away}_${home}`;
        }
        
        function getStoredOdds() {
            try {
                const stored = localStorage.getItem('spreadsheet_historical_odds');
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                return {};
            }
        }
        
        function saveStoredOdds(odds) {
            try {
                // Clean up old entries (older than 60 days)
                const cutoff = new Date();
                cutoff.setDate(cutoff.getDate() - 60);
                const cutoffStr = cutoff.toISOString();
                
                const cleaned = {};
                for (const [key, value] of Object.entries(odds)) {
                    if (value.savedAt && value.savedAt > cutoffStr) {
                        cleaned[key] = value;
                    }
                }
                
                localStorage.setItem('spreadsheet_historical_odds', JSON.stringify(cleaned));
            } catch (e) {
                console.warn('Could not save odds to localStorage');
            }
        }
        
        function lookupStoredOdds(homeTeam, awayTeam, date) {
            const storedOdds = getStoredOdds();
            const gameKey = makeGameKey(homeTeam, awayTeam, date);
            return storedOdds[gameKey] || null;
        }

        function processHistoricalGames(data) { 
            // Get today's date string (YYYY-MM-DD) for comparison
            const todayStr = new Date().toISOString().split('T')[0];
            
            state.historicalGames = data
                .filter(g => {
                    // Must have final scores
                    if (g.homePoints == null || g.awayPoints == null) return false;
                    if (g.status !== 'final') return false;
                    // Must be before today (exclude today's games) - use string comparison
                    const gameDateStr = new Date(g.startDate).toISOString().split('T')[0];
                    return gameDateStr < todayStr;
                })
                .map(g => ({ 
                    id: g.id, 
                    homeTeam: g.homeTeam, 
                    awayTeam: g.awayTeam, 
                    homeScore: g.homePoints, 
                    awayScore: g.awayPoints, 
                    date: g.startDate 
                }))
                .sort((a, b) => new Date(b.date) - new Date(a.date)); // Most recent first
            
            console.log(`Historical games loaded: ${state.historicalGames.length} (excluding ${todayStr})`);
            
            // Auto-run validation with most recent games
            if (state.historicalGames.length && Object.keys(state.ratings).length) {
                runValidation(25);
            }
        }

        // ============================================================
        // V1 FUNCTIONS REMOVED - Now using SpreadSheetV2
        // The following v1 functions have been replaced:
        // - generateNaturalReasoning  generateReasoning (in analyzeGame)
        // - generateTotalReasoning  generateTotalReasoning (in analyzeGame)
        // - calculateScore100  SpreadSheetV3Enhanced.analyze
        // - analyzeGame (old wrapper)  analyzeGame (new, at top of script)
        // ============================================================

        // ==================== ADVANCED ANALYTICS FUNCTIONS ====================
        
        /**
         * Kelly Criterion Calculator
         * Calculates optimal bet size based on edge and win probability
         */
        function calculateKelly(winProb, odds = -110) {
            const p = winProb / 100;
            const q = 1 - p;
            const decimalOdds = odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
            const b = decimalOdds - 1;
            const fullKelly = (b * p - q) / b;
            const quarterKelly = fullKelly * 0.25;
            const halfKelly = fullKelly * 0.5;
            const cappedKelly = Math.max(0, Math.min(0.05, quarterKelly));
            return {
                fullKelly: (fullKelly * 100).toFixed(2),
                quarterKelly: (quarterKelly * 100).toFixed(2),
                halfKelly: (halfKelly * 100).toFixed(2),
                recommended: (cappedKelly * 100).toFixed(2),
                isPositive: fullKelly > 0,
                edge: ((p * (1 + b) - 1) * 100).toFixed(2)
            };
        }

        /**
         * Expected Value Calculator
         */
        function calculateEV(winProb, odds = -110) {
            const p = winProb / 100;
            const q = 1 - p;
            const winAmount = odds > 0 ? odds : (100 / Math.abs(odds)) * 100;
            const loseAmount = 100;
            const ev = (p * winAmount) - (q * loseAmount);
            return {
                ev: ev.toFixed(2),
                isPositive: ev > 0,
                breakeven: ((loseAmount / (winAmount + loseAmount)) * 100).toFixed(1)
            };
        }

        // estimateWinProb REMOVED (Patch 5)
        // This was an ad-hoc formula (edge*3 + confBonus) that bypassed
        // the normal-CDF  Platt calibration pipeline. If any code path
        // was feeding this into the tracker's winProb field, validation
        // metrics were scoring the wrong model.
        // All probability estimation now routes through:
        //   analyze()  normalCDF(edge/)  calibrateProbability()

        /**
         * Pace Mismatch Detection
         */
        function analyzePaceMismatch(hr, ar) {
            // Estimate tempo from offensive/defensive ratings
            const homeTempo = 68 + (hr.offRating - 100) * 0.15;
            const awayTempo = 68 + (ar.offRating - 100) * 0.15;
            const tempoDiff = Math.abs(homeTempo - awayTempo);
            const avgTempo = (homeTempo + awayTempo) / 2;
            const fastTeam = homeTempo > awayTempo ? 'home' : 'away';
            const slowTeam = homeTempo > awayTempo ? 'away' : 'home';
            
            let verdict = 'Normal pace matchup';
            let extreme = false;
            let impact = 'neutral';
            
            if (tempoDiff >= 6) {
                extreme = true;
                if (avgTempo < 68) {
                    verdict = `Pace-Down Spot: ${slowTeam === 'home' ? hr.name : ar.name} controls tempo`;
                    impact = 'under';
                } else {
                    verdict = `Pace-Up Spot: ${fastTeam === 'home' ? hr.name : ar.name} pushes pace`;
                    impact = 'over';
                }
            } else if (tempoDiff >= 4) {
                verdict = 'Moderate tempo mismatch';
            }
            
            return { homeTempo, awayTempo, tempoDiff, avgTempo, verdict, extreme, impact };
        }

        /**
         * Regression Detection
         */
        function detectRegression(rating) {
            const factors = [];
            let score = 0;
            
            // Check for potential regression based on rating extremes
            if (rating.offRating > 115 && rating.rank > 30) {
                score -= 1;
                factors.push({ description: `High offensive rating (${rating.offRating.toFixed(1)}) but rank ${rating.rank} suggests regression`, direction: 'down' });
            }
            if (rating.defRating < 95 && rating.rank > 30) {
                score -= 1;
                factors.push({ description: `Elite defense (${rating.defRating.toFixed(1)}) may be unsustainable`, direction: 'down' });
            }
            if (rating.netRating < 0 && rating.rank < 150) {
                score += 1;
                factors.push({ description: `Negative net rating (${rating.netRating.toFixed(1)}) but decent rank suggests improvement`, direction: 'up' });
            }
            
            return { score, factors, direction: score > 0 ? 'up' : score < 0 ? 'down' : 'neutral' };
        }

        /**
         * Sharp Money Indicator (simulated)
         */
        function analyzeLineMovement(spread, projectedSpread, pickSide) {
            // Simulate line movement based on projection vs actual
            const diff = Math.abs(spread - projectedSpread);
            const movement = (Math.random() - 0.5) * Math.min(diff, 3);
            const absMovement = Math.abs(movement);
            
            let aligned = false;
            let description = '';
            
            if (pickSide === 'home') {
                aligned = movement < 0;
                description = movement < 0 ? `Line moved ${absMovement.toFixed(1)} toward home` : 
                              movement > 0 ? `Line moved ${absMovement.toFixed(1)} toward away` : 'No movement';
            } else {
                aligned = movement > 0;
                description = movement > 0 ? `Line moved ${absMovement.toFixed(1)} toward away` : 
                              movement < 0 ? `Line moved ${absMovement.toFixed(1)} toward home` : 'No movement';
            }
            
            const status = absMovement >= 1 ? (aligned ? 'aligned' : 'against') : 'neutral';
            const sharpIndicator = absMovement >= 1.5 && aligned ? 'Strong sharp signal' : 
                                   absMovement >= 1.5 && !aligned ? 'Possible trap' :
                                   absMovement >= 0.5 && aligned ? 'Mild sharp signal' : 'Neutral';
            
            return { movement: movement.toFixed(1), absMovement, aligned, status, description, sharpIndicator };
        }

        /**
         * Correlation Analysis
         */
        function analyzeCorrelation(spreadPick, totalPick, projectedSpread) {
            if (!spreadPick || !totalPick) {
                return { correlated: false, level: 'none', description: 'Single pick - no correlation' };
            }
            
            const isFavorite = (spreadPick.side === 'home' && projectedSpread < 0) || 
                               (spreadPick.side === 'away' && projectedSpread > 0);
            
            let correlated = false;
            let level = 'low';
            let description = '';
            
            if (isFavorite && totalPick.pick === 'OVER') {
                correlated = true;
                level = 'high';
                description = 'Favorite + Over: Both likely win together in blowout.';
            } else if (!isFavorite && totalPick.pick === 'UNDER') {
                correlated = true;
                level = 'medium';
                description = 'Underdog + Under: Both win in low-scoring close game.';
            } else {
                description = 'Low correlation between picks.';
            }
            
            return { correlated, level, description };
        }

        /**
         * Game Script Probabilities
         */
        function generateGameScript(ratingGap, homeAdvantage = true) {
            const baseAdv = homeAdvantage ? 3.5 : 0;
            const totalAdv = ratingGap + baseAdv;
            
            // Estimate scenario probabilities
            const blowout = Math.max(5, Math.min(35, 15 + totalAdv * 0.8));
            const comfortable = Math.max(10, Math.min(30, 25 + totalAdv * 0.3));
            const close = Math.max(15, Math.min(35, 30 - totalAdv * 0.2));
            const nailbiter = Math.max(10, Math.min(25, 20 - totalAdv * 0.3));
            const overtime = Math.max(3, Math.min(12, 10 - Math.abs(totalAdv) * 0.3));
            
            const scenarios = [
                { label: 'Blowout (15+ pts)', prob: Math.round(blowout), color: 'var(--navy)' },
                { label: 'Comfortable (8-14)', prob: Math.round(comfortable), color: 'var(--accent-blue)' },
                { label: 'Close (4-7 pts)', prob: Math.round(close), color: 'var(--accent-yellow)' },
                { label: 'Nail-biter (1-3)', prob: Math.round(nailbiter), color: 'var(--accent-red)' },
                { label: 'Overtime', prob: Math.round(overtime), color: 'var(--text-muted)' }
            ];
            
            // Normalize to 100%
            const total = scenarios.reduce((sum, s) => sum + s.prob, 0);
            scenarios.forEach(s => s.prob = Math.round(s.prob / total * 100));
            
            return scenarios;
        }

        /**
         * Recommended Unit Size
         */
        function getRecommendedUnits(confidence, kelly) {
            const baseUnits = confidence >= 8 ? 2.0 : confidence >= 6 ? 1.5 : confidence >= 4 ? 1.0 : 0.5;
            let units = baseUnits;
            
            if (parseFloat(kelly.recommended) > 3) units += 0.5;
            else if (parseFloat(kelly.recommended) < 1) units -= 0.5;
            
            return {
                recommended: Math.max(0.5, Math.min(3, units)),
                conservative: Math.max(0.5, units - 0.5),
                aggressive: Math.min(3, units + 0.5)
            };
        }

        /**
         * Full Advanced Analytics for a Game
         * Updated to use SpreadSheetV2 output format
         */
        function calculateAdvancedAnalytics(game) {
            const a = game.analysis;
            if (!a || !a.hasData) return null;
            
            // Use v2 win probabilities directly (stored as 0-1 in spreadWinProb/totalWinProb)
            const winProb = a.spreadWinProb || 50;
            const totalWinProb = a.totalWinProb || 50;
            
            // Calculate Kelly using existing helper (expects 0-100 scale)
            const spreadKelly = calculateKelly(winProb);
            const spreadEV = calculateEV(winProb);
            const totalKelly = calculateKelly(totalWinProb);
            const totalEV = calculateEV(totalWinProb);
            
            // Presentation-only analytics (does NOT affect picks)
            const paceAnalysis = analyzePaceMismatch(game.homeRating, game.awayRating);
            const homeRegression = detectRegression(game.homeRating);
            const awayRegression = detectRegression(game.awayRating);
            
            // Calculate ratingGap for gameScript (not stored in v2 output)
            const ratingGap = game.homeRating.netRating - game.awayRating.netRating;
            
            const lineMovement = analyzeLineMovement(game.spread, a.projectedSpread, a.spreadPick?.side);
            const correlation = analyzeCorrelation(a.spreadPick, a.totalPick, a.projectedSpread);
            const gameScript = generateGameScript(ratingGap, a.spreadPick?.side === 'home');
            const units = getRecommendedUnits(a.confidence, spreadKelly);
            
            return {
                spread: { kelly: spreadKelly, ev: spreadEV, winProb },
                total: { kelly: totalKelly, ev: totalEV, winProb: totalWinProb },
                paceAnalysis,
                homeRegression,
                awayRegression,
                lineMovement,
                correlation,
                gameScript,
                units
            };
        }

        /**
         * Render Analytics Tab
         */
        function renderAnalytics() {
            const c = document.getElementById('analyticsContent');
            if (!state.games.length) {
                c.innerHTML = `<div class="empty-state"><div class="empty-icon"></div><div class="empty-title">Load games to view analytics</div></div>`;
                return;
            }
            
            const gamesWithAnalytics = state.games.filter(g => g.analysis?.hasData && (g.analysis.spreadPick || g.analysis.totalPick));
            
            // Aggregate stats
            const totalPositiveEV = gamesWithAnalytics.filter(g => {
                const analytics = calculateAdvancedAnalytics(g);
                return analytics && parseFloat(analytics.spread.ev.ev) > 0;
            }).length;
            
            const extremePace = gamesWithAnalytics.filter(g => {
                const analytics = calculateAdvancedAnalytics(g);
                return analytics && analytics.paceAnalysis.extreme;
            }).length;
            
            c.innerHTML = `
                <div class="analytics-tab-grid">
                    <div class="analytics-summary-card">
                        <h3> Today's Summary</h3>
                        <div class="tracker-stats">
                            <div class="tracker-stat-card"><div class="tracker-stat-value green">${totalPositiveEV}</div><div class="tracker-stat-label">+EV Plays</div></div>
                            <div class="tracker-stat-card"><div class="tracker-stat-value">${gamesWithAnalytics.length}</div><div class="tracker-stat-label">Total Edges</div></div>
                            <div class="tracker-stat-card"><div class="tracker-stat-value yellow">${extremePace}</div><div class="tracker-stat-label">Pace Mismatches</div></div>
                        </div>
                    </div>
                    
                    ${gamesWithAnalytics.slice(0, 10).map(g => {
                        const a = g.analysis;
                        const analytics = calculateAdvancedAnalytics(g);
                        if (!analytics) return '';
                        
                        return `
                            <div class="analytics-summary-card">
                                <h3>${g.awayTeam.split(' ').pop()} @ ${g.homeTeam.split(' ').pop()}</h3>
                                <div class="factor-tags" style="margin-bottom:1rem;">
                                    <span class="factor-tag positive">${a.confidence}/10</span>
                                    ${analytics.correlation.level === 'high' ? '<span class="correlation-badge high"> Correlated</span>' : ''}
                                    ${analytics.paceAnalysis.extreme ? '<span class="factor-tag neutral"> Pace Mismatch</span>' : ''}
                                </div>
                                
                                <div class="analytics-grid">
                                    ${a.spreadPick ? `
                                        <div class="analytics-card">
                                            <h4> Expected Value</h4>
                                            <div class="ev-display">
                                                <div class="ev-value ${parseFloat(analytics.spread.ev.ev) > 0 ? 'positive' : 'negative'}">
                                                    ${parseFloat(analytics.spread.ev.ev) > 0 ? '+' : ''}$${analytics.spread.ev.ev}
                                                </div>
                                                <div class="ev-label">per $100 wagered</div>
                                            </div>
                                        </div>
                                        <div class="analytics-card">
                                            <h4> Kelly Criterion</h4>
                                            <div class="kelly-display">
                                                <div class="kelly-value">${analytics.spread.kelly.recommended}%</div>
                                                <div class="kelly-breakdown">
                                                    <span>Est. Win Prob: <strong>${analytics.spread.winProb.toFixed(0)}%</strong></span>
                                                    <span>Edge: <strong>${analytics.spread.kelly.edge}%</strong></span>
                                                </div>
                                            </div>
                                        </div>
                                    ` : ''}
                                    
                                    <div class="analytics-card">
                                        <h4> Pace Analysis</h4>
                                        <div class="pace-mismatch">
                                            <div class="pace-verdict ${analytics.paceAnalysis.extreme ? 'extreme' : ''}">
                                                ${analytics.paceAnalysis.verdict}
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="analytics-card">
                                        <h4> Line Movement</h4>
                                        <div class="sharp-indicator ${analytics.lineMovement.status}">
                                            <span class="sharp-icon">${analytics.lineMovement.status === 'aligned' ? '' : analytics.lineMovement.status === 'against' ? '' : ''}</span>
                                            <div class="sharp-details">
                                                <div class="sharp-status">${analytics.lineMovement.sharpIndicator}</div>
                                                <div class="sharp-move">${analytics.lineMovement.description}</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                ${a.spreadPick ? `
                                    <div class="bet-sizing">
                                        <div class="bet-sizing-header">
                                            <span class="bet-sizing-title"> Recommended Units</span>
                                            <span class="unit-size">${analytics.units.recommended}u</span>
                                        </div>
                                        <div class="unit-breakdown">
                                            <div class="unit-option"><div class="unit-option-value">${analytics.units.conservative}u</div><div class="unit-option-label">Conservative</div></div>
                                            <div class="unit-option recommended"><div class="unit-option-value">${analytics.units.recommended}u</div><div class="unit-option-label">Recommended</div></div>
                                            <div class="unit-option"><div class="unit-option-value">${analytics.units.aggressive}u</div><div class="unit-option-label">Aggressive</div></div>
                                        </div>
                                    </div>
                                ` : ''}
                                
                                <div class="analytics-section">
                                    <div class="analytics-section-title"> Game Script Probabilities</div>
                                    <div class="game-script">
                                        ${analytics.gameScript.map(s => `
                                            <div class="script-scenario">
                                                <span class="script-prob">${s.prob}%</span>
                                                <div class="script-bar"><div class="script-bar-fill" style="width:${s.prob}%;background:${s.color}"></div></div>
                                                <span class="script-label">${s.label}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                                
                                ${(analytics.homeRegression.factors.length || analytics.awayRegression.factors.length) ? `
                                    <div class="analytics-section">
                                        <div class="analytics-section-title"> Regression Watch</div>
                                        ${analytics.homeRegression.factors.map(f => `
                                            <div class="regression-indicator">
                                                <span class="regression-arrow">${f.direction === 'up' ? '' : ''}</span>
                                                <span class="regression-text"><strong>${g.homeTeam.split(' ').pop()}:</strong> ${f.description}</span>
                                            </div>
                                        `).join('')}
                                        ${analytics.awayRegression.factors.map(f => `
                                            <div class="regression-indicator">
                                                <span class="regression-arrow">${f.direction === 'up' ? '' : ''}</span>
                                                <span class="regression-text"><strong>${g.awayTeam.split(' ').pop()}:</strong> ${f.description}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // ==================== END ADVANCED ANALYTICS ====================

        // Team Search state
        let teamSearchFilter = null;
        let selectedDropdownIndex = -1;

        function handleTeamSearch(query) {
            const dropdown = document.getElementById('teamSearchDropdown');
            const container = document.querySelector('.games-team-search-container');
            
            if (!query || query.length < 2) {
                dropdown.classList.remove('show');
                container?.classList.remove('has-value');
                teamSearchFilter = null;
                selectedDropdownIndex = -1;
                renderGames();
                return;
            }
            
            container?.classList.add('has-value');
            
            // Get available teams from current games
            const availableTeams = new Set();
            state.games.forEach(g => {
                if (g.homeTeam) availableTeams.add(g.homeTeam);
                if (g.awayTeam) availableTeams.add(g.awayTeam);
            });
            
            // Filter teams matching query
            const queryLower = query.toLowerCase();
            const matches = [...availableTeams]
                .filter(team => team.toLowerCase().includes(queryLower))
                .sort((a, b) => {
                    // Prioritize teams that START with the query
                    const aStarts = a.toLowerCase().startsWith(queryLower);
                    const bStarts = b.toLowerCase().startsWith(queryLower);
                    if (aStarts && !bStarts) return -1;
                    if (!aStarts && bStarts) return 1;
                    return a.localeCompare(b);
                })
                .slice(0, 8);
            
            if (matches.length === 0) {
                dropdown.innerHTML = '<div class="team-search-item" style="color: var(--text-muted); cursor: default;">No teams found</div>';
                dropdown.classList.add('show');
                return;
            }
            
            dropdown.innerHTML = matches.map((team, idx) => {
                const game = state.games.find(g => g.homeTeam === team || g.awayTeam === team);
                const conf = game?.homeTeam === team ? game.homeRating?.conference : game?.awayRating?.conference;
                return `<div class="team-search-item ${idx === selectedDropdownIndex ? 'selected' : ''}" 
                            onclick="selectTeam('${team.replace(/'/g, "\\'")}')">
                    <span class="team-search-name">${team}</span>
                    ${conf ? `<span class="team-search-conf">${conf}</span>` : ''}
                </div>`;
            }).join('');
            
            dropdown.classList.add('show');
        }

        function selectTeam(teamName) {
            const input = document.getElementById('teamSearch');
            const dropdown = document.getElementById('teamSearchDropdown');
            
            input.value = teamName;
            teamSearchFilter = teamName;
            dropdown.classList.remove('show');
            selectedDropdownIndex = -1;
            renderGames();
        }

        function clearTeamSearch() {
            const input = document.getElementById('teamSearch');
            const container = document.querySelector('.games-team-search-container');
            
            input.value = '';
            teamSearchFilter = null;
            container?.classList.remove('has-value');
            document.getElementById('teamSearchDropdown').classList.remove('show');
            selectedDropdownIndex = -1;
            renderGames();
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.games-team-search-container')) {
                document.getElementById('teamSearchDropdown')?.classList.remove('show');
            }
        });

        // Keyboard navigation for dropdown
        document.addEventListener('keydown', function(e) {
            const dropdown = document.getElementById('teamSearchDropdown');
            if (!dropdown?.classList.contains('show')) return;
            
            const items = dropdown.querySelectorAll('.team-search-item:not([style*="cursor: default"])');
            if (!items.length) return;
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedDropdownIndex = Math.min(selectedDropdownIndex + 1, items.length - 1);
                updateDropdownSelection(items);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedDropdownIndex = Math.max(selectedDropdownIndex - 1, 0);
                updateDropdownSelection(items);
            } else if (e.key === 'Enter' && selectedDropdownIndex >= 0) {
                e.preventDefault();
                items[selectedDropdownIndex]?.click();
            } else if (e.key === 'Escape') {
                dropdown.classList.remove('show');
                selectedDropdownIndex = -1;
            }
        });

        function updateDropdownSelection(items) {
            items.forEach((item, idx) => {
                item.classList.toggle('selected', idx === selectedDropdownIndex);
            });
        }

        // Best Bets Team Search
        let bbTeamSearchFilter = null;
        let bbSelectedDropdownIndex = -1;

        function handleBBTeamSearch(query) {
            const dropdown = document.getElementById('bbTeamSearchDropdown');
            const container = document.querySelector('.bb-team-search-container');

            if (!query || query.length < 2) {
                dropdown.classList.remove('show');
                bbTeamSearchFilter = null;
                bbSelectedDropdownIndex = -1;
                renderBestBets();
                return;
            }

            // Get available teams from current games
            const availableTeams = new Set();
            (state.games || []).forEach(g => {
                if (g.homeTeam) availableTeams.add(g.homeTeam);
                if (g.awayTeam) availableTeams.add(g.awayTeam);
            });

            // Filter teams matching query
            const queryLower = query.toLowerCase();
            const matches = [...availableTeams]
                .filter(team => team.toLowerCase().includes(queryLower))
                .sort((a, b) => {
                    const aStarts = a.toLowerCase().startsWith(queryLower);
                    const bStarts = b.toLowerCase().startsWith(queryLower);
                    if (aStarts && !bStarts) return -1;
                    if (!aStarts && bStarts) return 1;
                    return a.localeCompare(b);
                })
                .slice(0, 8);

            if (matches.length === 0) {
                dropdown.innerHTML = '<div class="bb-team-search-item" style="cursor: default; color: var(--text-muted);">No teams found</div>';
            } else {
                dropdown.innerHTML = matches.map(team =>
                    `<div class="bb-team-search-item" onclick="selectBBTeam('${team.replace(/'/g, "\\'")}')">${team}</div>`
                ).join('');
            }

            dropdown.classList.add('show');
            bbSelectedDropdownIndex = -1;
        }

        function selectBBTeam(team) {
            const input = document.getElementById('bbTeamSearch');
            input.value = team;
            bbTeamSearchFilter = team;
            document.getElementById('bbTeamSearchDropdown').classList.remove('show');
            bbSelectedDropdownIndex = -1;
            renderBestBets();
        }

        function clearBBTeamSearch() {
            const input = document.getElementById('bbTeamSearch');
            input.value = '';
            bbTeamSearchFilter = null;
            document.getElementById('bbTeamSearchDropdown').classList.remove('show');
            bbSelectedDropdownIndex = -1;
            renderBestBets();
        }

        // Close BB dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.bb-team-search-container')) {
                document.getElementById('bbTeamSearchDropdown')?.classList.remove('show');
            }
        });

        function applyFilters() {
            state.confFilter = document.getElementById('confFilter').value;
            renderGames();
        }

        /**
         * Update the picks summary widget with today's picks breakdown and historical win rates
         */

        function renderGames(sort = state.currentSort) { 
            try {
                // Reset analyst insight tracking for uniqueness
                resetInsightTracking();
                
                state.currentSort = sort;
                const c = document.getElementById('gamesList'); 
                if (!c) {
                    console.error('gamesList element not found');
                    return;
                }
                let g = [...state.games]; 
                
            // Apply conference filter
            if (state.confFilter !== 'all') {
                if (state.confFilter === 'other') {
                    g = g.filter(x => {
                        const homeConf = x.homeRating?.conference;
                        const awayConf = x.awayRating?.conference;
                        return !POWER_CONFERENCES.includes(homeConf) || !POWER_CONFERENCES.includes(awayConf);
                    });
                } else {
                    g = g.filter(x => {
                        const homeConf = x.homeRating?.conference;
                        const awayConf = x.awayRating?.conference;
                        return homeConf === state.confFilter || awayConf === state.confFilter;
                    });
                }
            }
            
            // Apply team search filter
            if (teamSearchFilter) {
                g = g.filter(x => x.homeTeam === teamSearchFilter || x.awayTeam === teamSearchFilter);
            }

            // Apply probability filter - show only games with picks at or above minProb
            const minProb = gamesFilters?.minProb || 54;
            if (minProb > 50) {
                g = g.filter(x => {
                    const a = x.analysis;
                    if (!a) return false;
                    const spreadWinProb = a.spreadWinProb || 50;
                    const totalWinProb = a.totalWinProb || 50;
                    const hasSpreadPick = a.spreadPick && a.spreadEdge >= 2 && spreadWinProb >= minProb;
                    const hasTotalPick = a.totalPick && a.totalEdge >= 3 && totalWinProb >= minProb;
                    return hasSpreadPick || hasTotalPick;
                });
            }

            // Apply sort
            if (sort === 'spread') {
                // Sort by spread win probability (highest to lowest)
                g.sort((a, b) => {
                    const aWinProb = a.analysis?.spreadWinProb || 50;
                    const bWinProb = b.analysis?.spreadWinProb || 50;
                    const aHasPick = a.analysis?.spreadPick && a.analysis?.spreadEdge >= 2 && aWinProb >= 54;
                    const bHasPick = b.analysis?.spreadPick && b.analysis?.spreadEdge >= 2 && bWinProb >= 54;
                    if (aHasPick && !bHasPick) return -1;
                    if (!aHasPick && bHasPick) return 1;
                    return bWinProb - aWinProb;
                });
            } else if (sort === 'total') {
                // Sort by total win probability (highest to lowest)
                g.sort((a, b) => {
                    const aWinProb = a.analysis?.totalWinProb || 50;
                    const bWinProb = b.analysis?.totalWinProb || 50;
                    const aHasPick = a.analysis?.totalPick && a.analysis?.totalEdge >= 3 && aWinProb >= 54;
                    const bHasPick = b.analysis?.totalPick && b.analysis?.totalEdge >= 3 && bWinProb >= 54;
                    if (aHasPick && !bHasPick) return -1;
                    if (!aHasPick && bHasPick) return 1;
                    return bWinProb - aWinProb;
                });
            } else if (sort === 'time') {
                g.sort((a, b) => a.commenceTime - b.commenceTime);
            }
            
            if (!g.length) { c.innerHTML = `<div class="empty-state"><div class="empty-icon"></div><div class="empty-title">${state.games.length ? 'No games match filters' : 'No games loaded'}</div><p class="empty-text">${state.games.length ? 'Try adjusting your filters' : 'Click Refresh to load games'}</p></div>`; return; } 
            
            try {
                c.innerHTML = g.map(renderGameCard).join(''); 
                // Stagger card entrance animations
                c.querySelectorAll('.game-card-new').forEach((card, i) => {
                    card.style.animationDelay = `${i * 0.04}s`;
                });
                // Insert time group headers when sorted by time
                if (sort === 'time' && g.length > 1) {
                    insertTimeGroupHeaders(c);
                }
            } catch (e) {
                console.error('Error rendering games:', e);
                c.innerHTML = `<div class="empty-state"><div class="empty-icon"></div><div class="empty-title">Error rendering games</div><p class="empty-text">${e.message}</p></div>`;
            }
            // Update tab badges and summary
            updateTabBadges(g);
            renderGamesSummaryBar(g);
            restoreTrackedButtonStates();
            } catch (outerErr) {
                console.error('Error in renderGames:', outerErr);
                const c = document.getElementById('gamesList');
                if (c) c.innerHTML = `<div class="empty-state"><div class="empty-icon"></div><div class="empty-title">Error</div><p class="empty-text">${outerErr.message}</p></div>`;
            }
        }

        function sortGames(sort, btn) {
            // Update active state on sort buttons (now using bb-type-tab class in header)
            document.querySelectorAll('.games-header-controls .bb-type-tabs .bb-type-tab').forEach(b => {
                b.classList.remove('active');
            });
            btn.classList.add('active');
            renderGames(sort);
        }

        function getConfidenceRingStyle(confidence) {
            const degrees = (confidence / 10) * 360;
            let color = 'var(--text-muted)';
            if (confidence >= 9) color = 'var(--conf-elite)';
            else if (confidence >= 7) color = 'var(--conf-high)';
            else if (confidence >= 5) color = 'var(--conf-medium)';
            return `background: conic-gradient(${color} ${degrees}deg, var(--bg-input) ${degrees}deg);`;
        }
        
        function getScoreClass(score) {
            if (score >= 70) return 'elite';
            if (score >= 50) return 'high';
            if (score >= 30) return 'medium';
            return 'low';
        }
        
        function getScoreIcon(score) {
            if (score >= 70) return '';
            if (score >= 50) return '';
            if (score >= 30) return '';
            return '';
        }
        
        // ============================================================
        // V3.1 CALIBRATED TIER THRESHOLDS
        // ============================================================
        // With Platt scaling + shrinkage, probabilities are compressed.
        // These thresholds are calibrated to match the new probability range.
        //
        // OLD (Uncalibrated)  NEW (Calibrated V3.1)
        //   78%+ Best Bet     62%+ Best Bet
        //   62%+ Elite        58%+ Elite
        //   57%+ High         55%+ High
        //   52.4%+ Medium     52.4%+ Medium (unchanged - breakeven)
        // ============================================================

        const TIER_THRESHOLDS = {
            BEST_BET: 62,
            ELITE: 58,
            HIGH: 55,
            MEDIUM: 52.4
        };

        // Get class based on win probability (52.4% is breakeven for -110 odds)
        function getWinProbClass(winProb) {
            if (winProb >= TIER_THRESHOLDS.BEST_BET) return 'bestbet';
            if (winProb >= TIER_THRESHOLDS.ELITE) return 'elite';
            if (winProb >= TIER_THRESHOLDS.HIGH) return 'high';
            if (winProb >= TIER_THRESHOLDS.MEDIUM) return 'medium';
            return 'low';
        }

        function getWinProbIcon(winProb) {
            if (winProb >= TIER_THRESHOLDS.BEST_BET) return '';
            if (winProb >= TIER_THRESHOLDS.ELITE) return '';
            if (winProb >= TIER_THRESHOLDS.HIGH) return '';
            if (winProb >= TIER_THRESHOLDS.MEDIUM) return '';
            return '';
        }

        function getTierLabel(tierClass) {
            switch(tierClass) {
                case 'bestbet': return 'Best Bet';
                case 'elite': return 'Elite';
                case 'high': return 'High';
                case 'medium': return 'Medium';
                default: return '';
            }
        }

        // Get Best Bet rating (1-5 basketballs with half support) for 62%+ picks
        // STRICT SCALE: 5 balls reserved for absolute locks (75%+)
        //
        // Rating Scale:
        //   1 ball   = 62-63%  (Good Best Bet)
        //   1.5 balls = 63-64%
        //   2 balls  = 64-66%  (Strong Best Bet)
        //   2.5 balls = 66-68%
        //   3 balls  = 68-70%  (Very Strong)
        //   3.5 balls = 70-72%
        //   4 balls  = 72-74%  (Elite)
        //   4.5 balls = 74-75%
        //   5 balls  = 75%+    (LOCK - Absolute highest confidence)
        //
        function getEliteRating(winProb) {
            if (winProb < TIER_THRESHOLDS.BEST_BET) return 0; // Not a Best Bet - no rating

            // Strict scale - 5 balls only for 75%+ (very rare with calibration)
            if (winProb < 63) return 1;
            if (winProb < 64) return 1.5;
            if (winProb < 66) return 2;
            if (winProb < 68) return 2.5;
            if (winProb < 70) return 3;
            if (winProb < 72) return 3.5;
            if (winProb < 74) return 4;
            if (winProb < 75) return 4.5;
            return 5; // 75%+ gets 5 basketballs - ABSOLUTE LOCK
        }
        
        // Basketball SVG as inline element (with white trend arrow like logo)
        function basketballSVG(size, filled = true) {
            const opacity = filled ? '1' : '0.2';
            const filter = filled ? '' : 'filter: grayscale(1);';
            return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 100 100" style="display:inline-block; vertical-align:middle; opacity: ${opacity}; ${filter}"><circle cx="50" cy="50" r="46" fill="#ff8c42" stroke="#1e3a5f" stroke-width="4"/><path d="M 50 4 Q 18 50 50 96" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/><path d="M 50 4 Q 82 50 50 96" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/><path d="M 6 40 Q 50 55 94 40" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/><path d="M 6 60 Q 50 45 94 60" fill="none" stroke="#1e3a5f" stroke-width="3" stroke-linecap="round"/><path d="M 25 68 L 42 48 L 58 58 L 78 32" fill="none" stroke="white" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/><polygon points="78,32 66,36 70,46" fill="white"/></svg>`; 
        }
        
        // Generate basketball rating HTML for Best Bet picks (large version)
        function renderEliteRating(winProb) {
            const rating = getEliteRating(winProb);
            if (rating === 0) return '';
            
            const fullBalls = Math.floor(rating);
            const hasHalf = rating % 1 !== 0;
            
            let balls = '';
            for (let i = 1; i <= 5; i++) {
                if (i <= fullBalls) {
                    balls += basketballSVG(24, true);
                } else if (i === fullBalls + 1 && hasHalf) {
                    // Half ball - use clip-path
                    balls += basketballSVG(24, true).replace('style="', 'style="clip-path:inset(0 50% 0 0);margin-right:-12px;');
                } else {
                    balls += basketballSVG(24, false);
                }
            }
            
            return `<div class="elite-rating" title="${rating}/5 Best Bet Rating">
                <span class="elite-rating-balls">${balls}</span>
            </div>`;
        }
        
        // Generate compact basketball rating for grid view
        function renderEliteRatingMini(winProb) {
            const rating = getEliteRating(winProb);
            if (rating === 0) return '';
            
            const fullBalls = Math.floor(rating);
            const hasHalf = rating % 1 !== 0;
            
            let balls = '';
            for (let i = 1; i <= 5; i++) {
                if (i <= fullBalls) {
                    balls += basketballSVG(12, true);
                } else if (i === fullBalls + 1 && hasHalf) {
                    balls += basketballSVG(12, true).replace('style="', 'style="clip-path:inset(0 50% 0 0);margin-right:-6px;');
                } else {
                    balls += basketballSVG(12, false);
                }
            }
            
            return `<div class="elite-rating-mini" title="${rating}/5">${balls}</div>`;
        }
        
        // Generate bullet points for why a spread bet should win
        function generateSpreadBullets(g, a, winProb) {
            const bullets = [];
            const pickTeam = a.spreadPick.side === 'home' ? g.homeRating : g.awayRating;
            const oppTeam = a.spreadPick.side === 'home' ? g.awayRating : g.homeRating;
            const pickName = a.spreadPick.team;
            
            if (pickTeam && oppTeam) {
                const netDiff = Math.abs(pickTeam.netRating - oppTeam.netRating);
                
                // Efficiency edge
                if (netDiff >= 10) {
                    bullets.push(`${netDiff.toFixed(0)}-point efficiency advantage`);
                } else if (netDiff >= 5) {
                    bullets.push(`${netDiff.toFixed(0)}-point efficiency edge`);
                }
                
                // Offensive/defensive strengths
                if (pickTeam.offRating > 112 && oppTeam.defRating > 102) {
                    bullets.push(`Elite offense vs weak defense`);
                } else if (pickTeam.defRating < 96) {
                    bullets.push(`Elite defensive unit`);
                } else if (pickTeam.offRating > 110) {
                    bullets.push(`Top-tier offense`);
                }
                
                // Rank advantage
                if (pickTeam.rank && oppTeam.rank && (oppTeam.rank - pickTeam.rank) >= 50) {
                    bullets.push(`#${pickTeam.rank} vs #${oppTeam.rank} KenPom`);
                }
            }
            
            // Edge vs Vegas
            if (a.spreadEdge >= 5) {
                bullets.push(`${a.spreadEdge.toFixed(1)}-point value vs Vegas`);
            } else if (a.spreadEdge >= 3) {
                bullets.push(`${a.spreadEdge.toFixed(1)}-point edge found`);
            }
            
            // Win probability
            bullets.push(`${winProb.toFixed(0)}% win probability`);
            
            return bullets.slice(0, 4); // Max 4 bullets
        }
        
        // Generate bullet points for why a total bet should win
        function generateTotalBullets(g, a, winProb) {
            const bullets = [];
            const isOver = a.totalPick.pick === 'OVER';
            
            if (g.homeRating && g.awayRating) {
                if (isOver) {
                    // Over reasons
                    if (g.homeRating.offRating > 110 || g.awayRating.offRating > 110) {
                        bullets.push(`High-powered offense(s) in matchup`);
                    }
                    if (g.homeRating.defRating > 105 && g.awayRating.defRating > 105) {
                        bullets.push(`Both teams struggle defensively`);
                    }
                    if (a.projectedTotal > a.totalPick.line) {
                        bullets.push(`Model projects ${a.projectedTotal.toFixed(0)} total`);
                    }
                } else {
                    // Under reasons
                    if (g.homeRating.defRating < 98 || g.awayRating.defRating < 98) {
                        bullets.push(`Elite defense slows the pace`);
                    }
                    if (g.homeRating.offRating < 105 && g.awayRating.offRating < 105) {
                        bullets.push(`Both teams limited offensively`);
                    }
                    if (a.projectedTotal < a.totalPick.line) {
                        bullets.push(`Model projects ${a.projectedTotal.toFixed(0)} total`);
                    }
                }
            }
            
            // Edge vs Vegas
            if (a.totalEdge >= 5) {
                bullets.push(`${a.totalEdge.toFixed(1)}-point value vs Vegas`);
            } else if (a.totalEdge >= 3) {
                bullets.push(`${a.totalEdge.toFixed(1)}-point edge found`);
            }
            
            // Win probability
            bullets.push(`${winProb.toFixed(0)}% win probability`);
            
            return bullets.slice(0, 4); // Max 4 bullets
        }
        
        // Simple Win% badge HTML
        function getWinProbBadgeHTML(winProb, size = 'normal') {
            const probClass = getWinProbClass(winProb);
            const sizeClass = size === 'large' ? 'win-prob-badge-lg' : '';
            return `<div class="win-prob-badge ${probClass} ${sizeClass}"><span class="win-prob-pct">${winProb.toFixed(0)}%</span><span class="win-prob-label-sm">Win</span></div>`;
        }
        
        function getConfidenceRingHTML(score, size = 32) {
            const scoreClass = score >= 70 ? 'elite' : score >= 50 ? 'high' : score >= 30 ? 'medium' : 'low';
            const confColor = score >= 70 ? 'var(--conf-elite)' : score >= 50 ? 'var(--conf-high)' : score >= 30 ? 'var(--conf-medium)' : 'var(--conf-low)';
            const ringStyle = `background: conic-gradient(${confColor} ${score * 3.6}deg, var(--bg-input) ${score * 3.6}deg);`;
            return `<div class="confidence-ring-mini ${scoreClass}" style="width:${size}px;height:${size}px;${ringStyle}"><span class="conf-value">${score}</span></div>`;
        }

        function renderGameCard(g) {
            try {
                const a = g.analysis;
                if (!a) {
                    return `<div class="game-card-new"><div class="bb-empty-state" style="padding:1rem;"><span>No analysis available for ${g.homeTeam || 'unknown'} vs ${g.awayTeam || 'unknown'}</span></div></div>`;
                }

                const time = g.commenceTime ? g.commenceTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) : '';
                const date = g.commenceTime ? g.commenceTime.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }) : '';

                // Handle games with missing ratings
                if (a.missingRatings) {
                    const missingTeams = [];
                    if (a.missingAway) missingTeams.push(g.awayTeam);
                    if (a.missingHome) missingTeams.push(g.homeTeam);

                    return `<div class="game-card-new">
                        <div class="game-card-new-header">
                            <div class="game-matchup-info">
                                <div class="game-matchup-teams">${g.awayTeam} @ ${g.homeTeam}</div>
                                <div class="game-matchup-meta">
                                    <span>${date}  ${time}</span>
                                    <span style="color:var(--accent-yellow);"> Missing data: ${missingTeams.join(', ')}</span>
                                </div>
                            </div>
                        </div>
                    </div>`;
                }

                // Calculate advanced analytics
                const analytics = calculateAdvancedAnalytics(g);

                // Use win probability as primary metric
                const spreadWinProb = a.spreadWinProb || 50;
                const totalWinProb = a.totalWinProb || 50;

                // Check if we have actionable picks (use filter minProb or default 54)
                const minProb = gamesFilters?.minProb || 54;
                const hasSpreadPick = a.spreadPick && a.spreadEdge >= 2 && spreadWinProb >= minProb;
                const hasTotalPick = a.totalPick && a.totalEdge >= 3 && totalWinProb >= minProb;

                // Get tier classes
                const spreadClass = hasSpreadPick ? getWinProbClass(spreadWinProb) : '';
                const totalClass = hasTotalPick ? getWinProbClass(totalWinProb) : '';

                // Conference badge
                const conf = g.homeRating?.conference || g.awayRating?.conference || '';
                const confBadge = conf ? `<span class="game-conf-badge">${conf}</span>` : '';

                // Rest days badge
                let restBadge = '';
                if (g.homeRestDays != null && g.awayRestDays != null) {
                    const restDiff = g.homeRestDays - g.awayRestDays;
                    const homeB2B = g.homeRestDays <= 1;
                    const awayB2B = g.awayRestDays <= 1;
                    if (homeB2B || awayB2B) {
                        const who = awayB2B ? 'Away' : 'Home';
                        restBadge = `<span style="font-size:0.6rem;padding:1px 5px;border-radius:4px;background:var(--accent-red-dim);color:var(--accent-red);font-weight:600;" title="${g.awayTeam}: ${g.awayRestDays}d rest | ${g.homeTeam}: ${g.homeRestDays}d rest"> ${who} B2B</span>`;
                    } else if (Math.abs(restDiff) >= 2) {
                        const favored = restDiff > 0 ? 'Home' : 'Away';
                        restBadge = `<span style="font-size:0.6rem;padding:1px 5px;border-radius:4px;background:var(--accent-green-dim);color:var(--accent-green);font-weight:600;" title="${g.awayTeam}: ${g.awayRestDays}d rest | ${g.homeTeam}: ${g.homeRestDays}d rest"> ${favored} +${Math.abs(restDiff)}d</span>`;
                    }
                }

                // Vegas lines display
                const spreadDisplay = g.spread !== null ? (g.spread > 0 ? `+${g.spread}` : g.spread) : 'N/A';
                const totalDisplay = g.total || 'N/A';

                // Generate drill down HTML
                const spD = g.spread !== null ? (g.spread > 0 ? `+${g.spread}` : g.spread) : 'N/A';
                const drillDownHTML = generateDrillDownHTML(g, a, analytics, hasSpreadPick, hasTotalPick, spD, a.spreadScore || 0, a.totalScore || 0);

                // Determine card tier based on best pick
                const bestProb = Math.max(hasSpreadPick ? spreadWinProb : 0, hasTotalPick ? totalWinProb : 0);
                const cardTier = bestProb > 0 ? 'tier-' + getWinProbClass(bestProb) : 'tier-low';

                return `<div class="game-card-new ${cardTier}">
                    <div class="game-card-new-header">
                        <!-- Matchup Info -->
                        <div class="game-matchup-info">
                            <div class="game-matchup-teams">${g.awayTeam} @ ${g.homeTeam} ${confBadge}</div>
                            <div class="game-matchup-meta">
                                <span>${date}  ${time}</span>
                                <span>#${g.awayRating?.rank || '?'} vs #${g.homeRating?.rank || '?'} ${restBadge}</span>
                            </div>
                        </div>

                        <!-- Picks Container -->
                        <div class="game-picks-container">
                            <!-- Spread Pick -->
                            <div class="game-pick-box ${hasSpreadPick ? 'has-pick ' + spreadClass : 'no-pick'}">
                                <div class="game-pick-label">SPREAD</div>
                                ${hasSpreadPick ? `
                                    <div class="game-pick-value">${a.spreadPick.team.split(' ').pop()} ${a.spreadPick.line > 0 ? '+' : ''}${a.spreadPick.line}</div>
                                    <div class="game-pick-prob-row">
                                        <span class="game-pick-winprob ${spreadClass}">${spreadWinProb.toFixed(0)}%</span>
                                        <span class="game-pick-tier ${spreadClass}">${getTierLabel(spreadClass)}</span>
                                    </div>
                                    ${spreadClass === 'bestbet' ? `<div class="game-pick-rating">${renderEliteRatingMini(spreadWinProb)}</div>` : ''}
                                    <button class="bb-track-btn game-track-btn" id="track-${g.id}-spread" onclick="event.stopPropagation();trackPick('${g.id}','spread',this)"> Track</button>
                                ` : `
                                    <div class="game-pick-value">Line: ${spreadDisplay}</div>
                                `}
                            </div>

                            <!-- Total Pick -->
                            <div class="game-pick-box ${hasTotalPick ? 'has-pick ' + totalClass : 'no-pick'}">
                                <div class="game-pick-label">TOTAL</div>
                                ${hasTotalPick ? `
                                    <div class="game-pick-value">${a.totalPick.pick} ${a.totalPick.line}</div>
                                    <div class="game-pick-prob-row">
                                        <span class="game-pick-winprob ${totalClass}">${totalWinProb.toFixed(0)}%</span>
                                        <span class="game-pick-tier ${totalClass}">${getTierLabel(totalClass)}</span>
                                    </div>
                                    ${totalClass === 'bestbet' ? `<div class="game-pick-rating">${renderEliteRatingMini(totalWinProb)}</div>` : ''}
                                    <button class="bb-track-btn game-track-btn" id="track-${g.id}-total" onclick="event.stopPropagation();trackPick('${g.id}','total',this)"> Track</button>
                                ` : `
                                    <div class="game-pick-value">O/U: ${totalDisplay}</div>
                                `}
                            </div>
                        </div>

                        <!-- Vegas Lines -->
                        <div class="game-vegas-lines">
                            <div class="game-vegas-line">
                                <span class="game-vegas-label">Spread:</span>
                                <span class="game-vegas-value">${spreadDisplay}</span>
                            </div>
                            <div class="game-vegas-line">
                                <span class="game-vegas-label">O/U:</span>
                                <span class="game-vegas-value">${totalDisplay}</span>
                            </div>
                        </div>
                    </div>

                    <!-- Analysis Toggle -->
                    <div class="analytics-toggle" onclick="toggleDrillDown('${g.id}')">
                        <span id="drill-arrow-${g.id}"></span> View Analysis
                    </div>
                    <div class="drill-down-content" id="drill-${g.id}">${drillDownHTML}</div>
                </div>`;
            } catch (err) {
                console.error('Error rendering game card:', err, g);
                return `<div class="game-card-new"><div class="bb-empty-state" style="padding:1rem;">Error: ${err.message}</div></div>`;
            }
        }
        
        /**
         * Generate the full analysis drill-down HTML - STREAMLINED VERSION
         * Now shows analysis for ALL games, even without edge
         */
        
        // Track used insight patterns to ensure uniqueness
        let usedInsightHashes = new Set();
        
        /**
         * Generate a unique analyst-style insight sentence for a game
         * Returns a 14-24 word sentence with concrete betting angle
         */
        function generateAnalystInsight(g, a, analytics) {
            const home = g.homeTeam || 'Home';
            const away = g.awayTeam || 'Away';
            const spread = g.spread;
            const total = g.total;
            const hr = g.homeRating || {};
            const ar = g.awayRating || {};
            const projSpread = a?.projectedSpread || 0;
            const projTotal = a?.projectedTotal || 0;
            const spreadEdge = a?.spreadEdge || 0;
            const totalEdge = a?.totalEdge || 0;
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;
            const homeRank = hr.rank || 100;
            const awayRank = ar.rank || 100;
            const homeConf = hr.conference || '';
            const awayConf = ar.conference || '';
            const homeTempo = hr.tempo || 68;
            const awayTempo = ar.tempo || 68;
            
            // Calculate various angles
            const netDiff = Math.abs(homeNet - awayNet);
            const rankDiff = Math.abs(homeRank - awayRank);
            const tempoDiff = Math.abs(homeTempo - awayTempo);
            const offMismatch = Math.abs(homeOff - awayOff);
            const defMismatch = Math.abs(homeDef - awayDef);
            const spreadDiff = spread !== null ? Math.abs(projSpread - spread) : 0;
            const totalDiff = total !== null ? Math.abs(projTotal - total) : 0;
            const isCrossConf = homeConf !== awayConf && homeConf && awayConf;
            const isHighTotal = total > 150;
            const isLowTotal = total < 130;
            const bigFavorite = spread !== null && Math.abs(spread) >= 10;
            const closeGame = spread !== null && Math.abs(spread) <= 3;
            
            // Build pool of potential insights based on game characteristics
            const insights = [];
            
            // Efficiency mismatch angles
            if (homeOff > 115 && awayDef > 105) {
                insights.push(`${home}'s elite offense averaging ${homeOff.toFixed(1)} points per 100 possessions faces a porous ${away} defense that could struggle to contain them.`);
            }
            if (awayOff > 115 && homeDef > 105) {
                insights.push(`${away} brings a top-tier attack at ${awayOff.toFixed(1)} offensive efficiency into a matchup where ${home}'s defense has shown vulnerability.`);
            }
            if (homeDef < 95 && awayOff < 105) {
                insights.push(`${home}'s suffocating defense ranks among the nation's best and could create problems for ${away}'s pedestrian ${awayOff.toFixed(1)} offensive efficiency.`);
            }
            if (awayDef < 95 && homeOff < 105) {
                insights.push(`${away}'s lockdown defense at ${awayDef.toFixed(1)} per 100 suggests the total market may be inflated given ${home}'s modest offensive output.`);
            }
            
            // Tempo angles
            if (tempoDiff > 5) {
                const fastTeam = homeTempo > awayTempo ? home : away;
                const slowTeam = homeTempo > awayTempo ? away : home;
                insights.push(`Tempo clash here as ${fastTeam} prefers an uptempo style while ${slowTeam} grinds possessions, which typically favors the slower team's spread.`);
            }
            if (homeTempo > 72 && awayTempo > 72) {
                insights.push(`Both teams rank in the top tier for pace, suggesting this game could see extra possessions and push toward the over on the ${total} total.`);
            }
            if (homeTempo < 65 && awayTempo < 65) {
                insights.push(`Two methodical half-court teams suggests a grind-it-out affair that leans toward the under on a ${total} number that may be too high.`);
            }
            
            // Line/Price angles
            if (spreadDiff >= 3 && spread !== null) {
                const side = projSpread < spread ? home : away;
                insights.push(`Market has this at ${spread > 0 ? '+' + spread : spread} but efficiency metrics suggest the ${side} side offers ${spreadDiff.toFixed(1)} points of potential value.`);
            }
            if (totalDiff >= 4 && total !== null) {
                const direction = projTotal > total ? 'over' : 'under';
                insights.push(`Projected total of ${projTotal.toFixed(0)} sits ${totalDiff.toFixed(1)} points ${direction === 'over' ? 'above' : 'below'} the posted ${total}, creating possible ${direction} value.`);
            }
            if (bigFavorite && rankDiff < 30) {
                insights.push(`Despite the ${Math.abs(spread).toFixed(1)}-point spread, KenPom rankings are closer than expected at ${Math.min(homeRank, awayRank)} vs ${Math.max(homeRank, awayRank)}, worth monitoring.`);
            }
            if (closeGame && rankDiff > 40) {
                insights.push(`Tight ${Math.abs(spread).toFixed(1)}-point spread belies a significant talent gap per efficiency rankings, suggesting sharps may have information on the underdog.`);
            }
            
            // Conference/matchup angles
            if (isCrossConf) {
                insights.push(`Non-conference clash between ${homeConf} and ${awayConf} programs adds uncertainty as teams adjust to unfamiliar styles and scouting limitations.`);
            }
            if (homeConf === 'Big Ten' || awayConf === 'Big Ten') {
                insights.push(`Big Ten defensive principles typically suppress pace and points, a factor worth weighing against this ${total} total.`);
            }
            if (homeConf === 'Big 12' || awayConf === 'Big 12') {
                insights.push(`Big 12 depth and physicality often leads to tighter margins than spreads suggest late in games when fatigue sets in.`);
            }
            
            // Ranking-based angles
            if (homeRank <= 25 && awayRank <= 25) {
                insights.push(`Top-25 showdown tends to produce cautious, half-court basketball as neither team wants to give up easy transition buckets in a marquee spot.`);
            }
            if (homeRank <= 10 && awayRank > 100) {
                insights.push(`Elite vs mid-major matchup where ${home}'s depth advantage typically shows in the second half once rotations tighten up.`);
            }
            if (awayRank <= 10 && homeRank > 100) {
                insights.push(`Road favorite ${away} faces classic trap game dynamics where lower-ranked ${home} has nothing to lose in front of their home crowd.`);
            }
            
            // Net rating angles
            if (netDiff > 15) {
                const betterTeam = homeNet > awayNet ? home : away;
                insights.push(`Net rating differential of ${netDiff.toFixed(1)} points per 100 possessions heavily favors ${betterTeam} in what profiles as a mismatch.`);
            }
            if (homeNet > 0 && awayNet > 0 && netDiff < 5) {
                insights.push(`Two positive net rating teams separated by just ${netDiff.toFixed(1)} points suggests market efficiency and limited edges on either side.`);
            }
            if (homeNet < -5 && awayNet < -5) {
                insights.push(`Both teams carry negative net ratings, indicating a lower-quality matchup where variance and shooting luck may dominate outcomes.`);
            }
            
            // Specific spread/total angles
            if (spread !== null && Math.abs(spread) >= 15) {
                insights.push(`Large ${Math.abs(spread).toFixed(1)}-point spread historically sees favorites ease off late, which garbage time points often benefit the underdog cover.`);
            }
            if (spread !== null && spread === 0) {
                insights.push(`Pick'em line indicates Vegas sees this as a true coin flip, where home court advantage of 3-4 points becomes the primary lean factor.`);
            }
            if (isHighTotal) {
                insights.push(`Posted total of ${total} sits in the upper range for college hoops, typically requiring both offenses to exceed their season efficiency averages.`);
            }
            if (isLowTotal) {
                insights.push(`Sub-130 total indicates Vegas expects a defensive struggle, but watch for over value if either team abandons their usual pace.`);
            }
            
            // Win probability angles
            if (a?.spreadWinProb > 60) {
                insights.push(`Model assigns ${a.spreadWinProb.toFixed(0)}% cover probability to the spread pick, suggesting this line may not fully account for efficiency edges.`);
            }
            if (a?.spreadWinProb && a.spreadWinProb < 45 && a.spreadWinProb > 35) {
                insights.push(`Near-coinflip ${a.spreadWinProb.toFixed(0)}% win probability suggests the current line is well-calibrated with limited exploitable value.`);
            }
            
            // Defensive dominance angles
            if (homeDef < 92) {
                insights.push(`${home}'s elite ${homeDef.toFixed(1)} defensive efficiency ranks among the nation's stingiest, often suppressing totals below market expectations.`);
            }
            if (awayDef < 92) {
                insights.push(`Visiting ${away} brings a top-10 caliber defense at ${awayDef.toFixed(1)} efficiency, which tends to travel well and limit opponent scoring.`);
            }
            
            // Offensive firepower angles
            if (homeOff > 118) {
                insights.push(`${home} operates one of the country's most explosive offenses at ${homeOff.toFixed(1)} efficiency, a pace that stresses opponent defensive schemes.`);
            }
            if (awayOff > 118) {
                insights.push(`${away}'s ${awayOff.toFixed(1)} offensive rating ranks elite nationally, making them a live underdog if this stays close into crunch time.`);
            }
            
            // Fallback insights if pool is empty
            if (insights.length === 0) {
                insights.push(`Standard conference matchup with both teams operating near their season averages, suggesting the line is appropriately set barring late news.`);
                insights.push(`Efficiency metrics align closely with posted lines here, indicating market has priced in the key factors for this particular matchup.`);
                insights.push(`Neither team shows a significant statistical advantage in this spot, making game flow and shooting variance likely outcome drivers.`);
            }
            
            // Select insight that hasn't been used, using hash to track
            for (let i = 0; i < insights.length; i++) {
                // Create a simple hash of the insight
                const hash = insights[i].substring(0, 50);
                if (!usedInsightHashes.has(hash)) {
                    usedInsightHashes.add(hash);
                    return insights[i];
                }
            }
            
            // If all were used, create a truly unique one based on exact numbers
            const uniqueFallback = `${away} at ${home} profiles as a ${spread !== null ? Math.abs(spread).toFixed(1) + '-point' : 'competitive'} affair with combined efficiency ratings suggesting a ${projTotal.toFixed(0)}-point projected total.`;
            return uniqueFallback;
        }
        
        // Reset insight tracking when games refresh
        function resetInsightTracking() {
            usedInsightHashes = new Set();
        }
        
        function generateDrillDownHTML(g, a, analytics, hasSpreadPick, hasTotalPick, spD, spreadScore, totalScore) {
            try {
                if (!g || !a) {
                    return '<div class="analysis-panel"><p style="padding:1rem;color:var(--text-muted);font-size:0.7rem;text-align:center;">Analysis unavailable.</p></div>';
                }
                const hr = g.homeRating || {};
                const ar = g.awayRating || {};

                // Generate the new 3-panel layout for Games tab (shows both spread and total)
                return generateGameAnalysisPanel(g, a, hr, ar, hasSpreadPick, hasTotalPick, spD);
            } catch (err) {
                console.error('Error in generateDrillDownHTML:', err, g);
                return '<div class="analysis-panel"><p style="padding:1rem;color:var(--text-muted);font-size:0.7rem;text-align:center;">Error loading analysis.</p></div>';
            }
        }

        // New 3-panel analysis layout for Games tab
        function generateGameAnalysisPanel(g, a, hr, ar, hasSpreadPick, hasTotalPick, spD) {
            const spreadWinProb = a.spreadWinProb || 50;
            const totalWinProb = a.totalWinProb || 50;
            const spreadEdge = a.spreadEdge || 0;
            const totalEdge = a.totalEdge || 0;
            const projSpread = a.projectedSpread || 0;
            const projTotal = a.projectedTotal || 140;
            const vegasSpread = parseFloat(spD) || g.spread || 0;
            const vegasTotal = g.total || 140;
            const direction = a.totalPick?.pick || 'OVER';
            const isOver = direction === 'OVER';

            // Team stats
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;

            // Determine best pick
            const spreadIsBest = hasSpreadPick && (!hasTotalPick || spreadWinProb >= totalWinProb);
            const totalIsBest = hasTotalPick && (!hasSpreadPick || totalWinProb > spreadWinProb);
            const bestWinProb = Math.max(hasSpreadPick ? spreadWinProb : 0, hasTotalPick ? totalWinProb : 0);

            // Format helpers
            const fmtS = v => v > 0 ? `+${v.toFixed(1)}` : v.toFixed(1);
            const trunc = (s, n) => s.length > n ? s.substring(0, n-1) + '.' : s;

            // Generate insight text
            const insightText = generateModelInsight(g, a, hr, ar, hasSpreadPick, hasTotalPick);

            // Generate key factors
            const factors = generateKeyFactors(g, a, hr, ar, hasSpreadPick, hasTotalPick);

            return `
            <div class="analysis-panel">
                <!-- LEFT: Matchup Insights -->
                <div class="analysis-section-panel">
                    <div class="analysis-section-title">
                        <span class="title-icon"></span> Matchup Insights
                    </div>
                    <div class="matchup-insights">
                        <div class="metric-team-labels">
                            <span class="metric-team-label">${trunc(g.awayTeam, 12)}</span>
                            <span class="metric-team-label">${trunc(g.homeTeam, 12)}</span>
                        </div>

                        <!-- Adj. Efficiency (Net Rating) -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayNet > homeNet ? 'better' : ''}">${awayNet > 0 ? '+' : ''}${awayNet.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">ADJ. EFFICIENCY</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, Math.abs(awayNet) * 2)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, Math.abs(homeNet) * 2)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeNet > awayNet ? 'better' : ''}">${homeNet > 0 ? '+' : ''}${homeNet.toFixed(1)}</span>
                        </div>

                        <!-- Offensive Rating -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayOff > homeOff ? 'better' : ''}">${awayOff.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">OFFENSIVE RTG</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, (awayOff - 90) * 2.5)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, (homeOff - 90) * 2.5)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeOff > awayOff ? 'better' : ''}">${homeOff.toFixed(1)}</span>
                        </div>

                        <!-- Defensive Rating (lower is better) -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayDef < homeDef ? 'better' : ''}">${awayDef.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">DEFENSIVE RTG</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, (115 - awayDef) * 2.5)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, (115 - homeDef) * 2.5)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeDef < awayDef ? 'better' : ''}">${homeDef.toFixed(1)}</span>
                        </div>
                    </div>
                </div>

                <!-- CENTER: Model Prediction -->
                <div class="analysis-section-panel model-prediction-panel">
                    <div class="analysis-section-title" style="justify-content: space-between;">
                        <span><span class="title-icon"></span> Model Prediction</span>
                        <span class="model-badge">CBB MODEL V4.1</span>
                    </div>

                    <!-- Confidence Circle -->
                    <div class="confidence-circle-container">
                        <div class="confidence-circle-bg" style="background: conic-gradient(var(--conf-elite) ${bestWinProb * 3.6}deg, var(--bg-secondary) ${bestWinProb * 3.6}deg);">
                            <div class="confidence-circle-inner">
                                <span class="confidence-circle-value">${bestWinProb.toFixed(0)}%</span>
                                <span class="confidence-circle-label">MODEL<br>CONFIDENCE</span>
                            </div>
                        </div>
                    </div>

                    <!-- Predictions Grid -->
                    <div class="predictions-grid">
                        <div class="prediction-box ${spreadIsBest ? 'best-pick' : ''}" style="${!hasSpreadPick ? 'opacity:0.5;' : ''}">
                            <div class="prediction-label">Spread Prediction</div>
                            <div class="prediction-value spread">${a.spreadPick ? `${a.spreadPick.team.split(' ').pop()} ${fmtS(a.spreadPick.line)}` : 'PASS'}</div>
                            <div class="prediction-edge">Edge: <span class="edge-value">${hasSpreadPick ? '+' + spreadEdge.toFixed(1) : 'N/A'}</span></div>
                        </div>
                        <div class="prediction-box ${totalIsBest ? 'best-pick' : ''}" style="${!hasTotalPick ? 'opacity:0.5;' : ''}">
                            <div class="prediction-label">Total Prediction</div>
                            <div class="prediction-value ${isOver ? 'over' : 'under'}">${hasTotalPick ? direction + ' ' + vegasTotal : 'PASS'}</div>
                            <div class="prediction-edge">Edge: <span class="edge-value">${hasTotalPick ? '+' + totalEdge.toFixed(1) : 'N/A'}</span></div>
                        </div>
                    </div>

                    <!-- Model Insight -->
                    <div class="model-insight">
                        <span class="model-insight-icon"></span>
                        <span class="model-insight-text">${insightText}</span>
                    </div>
                </div>

                <!-- RIGHT: Key Factors -->
                <div class="analysis-section-panel key-factors-panel">
                    <div class="analysis-section-title">
                        <span class="title-icon"></span> Key Factors
                    </div>

                    ${factors.map(f => `
                        <div class="factor-item-row ${f.type}">
                            <span class="factor-icon">${f.icon}</span>
                            <span class="factor-text">${f.text}</span>
                            <span class="factor-value">${f.value}</span>
                        </div>
                    `).join('')}

                    <!-- Mini Stats -->
                    <div class="stat-mini-grid">
                        <div class="stat-mini-card">
                            <div class="stat-mini-value ${spreadEdge >= 2 ? 'positive' : ''}">${fmtS(spreadEdge)}</div>
                            <div class="stat-mini-label">Spread Edge</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value ${totalEdge >= 3 ? 'positive' : ''}">${totalEdge >= 0 ? '+' : ''}${totalEdge.toFixed(1)}</div>
                            <div class="stat-mini-label">Total Edge</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value">${fmtS(projSpread)}</div>
                            <div class="stat-mini-label">Proj Spread</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value ${Math.abs(homeNet - awayNet) >= 10 ? 'positive' : ''}">${Math.abs(homeNet - awayNet).toFixed(1)}</div>
                            <div class="stat-mini-label">Net Gap</div>
                        </div>
                    </div>
                </div>
            </div>`;
        }

        // Generate model insight text
        function generateModelInsight(g, a, hr, ar, hasSpreadPick, hasTotalPick) {
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;
            const netDiff = Math.abs(homeNet - awayNet);

            const parts = [];

            if (hasSpreadPick && a.spreadPick) {
                const betterTeam = homeNet > awayNet ? g.homeTeam : g.awayTeam;
                if (netDiff >= 8) {
                    parts.push(`The model favors <strong>${betterTeam}'s efficiency advantage</strong>`);
                } else {
                    parts.push(`Model projects value on <strong>${a.spreadPick.team}</strong>`);
                }
            }

            if (hasTotalPick) {
                const direction = a.totalPick?.pick || 'OVER';
                if (direction === 'UNDER') {
                    parts.push(`the <strong>Under</strong> holds value based on defensive metrics`);
                } else {
                    parts.push(`the <strong>Over</strong> offers value based on offensive efficiency`);
                }
            }

            if (parts.length === 0) {
                parts.push(`Model analysis shows marginal edges in this matchup`);
            }

            return parts.slice(0, 2).join(', and ') + '.';
        }

        // Generate key factors for right panel
        function generateKeyFactors(g, a, hr, ar, hasSpreadPick, hasTotalPick) {
            const factors = [];
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;
            const netDiff = Math.abs(homeNet - awayNet);

            // Net rating gap
            if (netDiff >= 10) {
                factors.push({ icon: '', text: 'Net Rating Gap', value: `${netDiff.toFixed(0)}pt`, type: 'positive' });
            } else if (netDiff >= 5) {
                factors.push({ icon: '', text: 'Net Rating Gap', value: `${netDiff.toFixed(0)}pt`, type: 'neutral' });
            }

            // Elite offense
            if (homeOff > 112 || awayOff > 112) {
                const team = homeOff > awayOff ? g.homeTeam.split(' ').pop() : g.awayTeam.split(' ').pop();
                factors.push({ icon: '', text: `${team} Elite Offense`, value: `${Math.max(homeOff, awayOff).toFixed(0)}`, type: 'positive' });
            }

            // Elite defense
            if (homeDef < 96 || awayDef < 96) {
                const team = homeDef < awayDef ? g.homeTeam.split(' ').pop() : g.awayTeam.split(' ').pop();
                factors.push({ icon: '', text: `${team} Elite Defense`, value: `${Math.min(homeDef, awayDef).toFixed(0)}`, type: 'positive' });
            }

            // Weak defense (opposite)
            if (homeDef > 105 || awayDef > 105) {
                const team = homeDef > awayDef ? g.homeTeam.split(' ').pop() : g.awayTeam.split(' ').pop();
                factors.push({ icon: '', text: `${team} Weak Defense`, value: `${Math.max(homeDef, awayDef).toFixed(0)}`, type: 'negative' });
            }

            // Home court
            factors.push({ icon: '', text: 'Home Court Adj.', value: '+3.5', type: 'neutral' });

            // Rest days advantage
            if (g.homeRestDays != null && g.awayRestDays != null) {
                const restDiff = g.homeRestDays - g.awayRestDays;
                const homeB2B = g.homeRestDays <= 1;
                const awayB2B = g.awayRestDays <= 1;
                if (homeB2B || awayB2B) {
                    const who = awayB2B ? g.awayTeam.split(' ').pop() : g.homeTeam.split(' ').pop();
                    const pts = Math.abs(CONFIG.FEATURE_WEIGHTS.backToBack).toFixed(1);
                    factors.push({ icon: '', text: `${who} B2B`, value: `${pts}pt`, type: awayB2B ? 'positive' : 'negative' });
                } else if (Math.abs(restDiff) >= 2) {
                    const who = restDiff > 0 ? 'Home' : 'Away';
                    const pts = (Math.abs(restDiff) * CONFIG.FEATURE_WEIGHTS.restDays).toFixed(1);
                    factors.push({ icon: '', text: `${who} +${Math.abs(restDiff)}d Rest`, value: `+${pts}pt`, type: restDiff > 0 ? 'positive' : 'negative' });
                } else {
                    factors.push({ icon: '', text: 'Rest', value: `${g.awayRestDays}d / ${g.homeRestDays}d`, type: 'neutral' });
                }
            }

            return factors.slice(0, 6);
        }

        function generateV2AnalystTake() { return ''; }
        
        /**
         * Calculate enhanced confidence factoring in all analytics
         */
        function calculateEnhancedConfidence(analysis, analytics) {
            if (!analysis || !analytics) return analysis?.confidence || 0;
            
            let conf = analysis.confidence;
            
            // Boost for positive EV
            if (parseFloat(analytics.spread.ev.ev) > 5) conf += 1;
            else if (parseFloat(analytics.spread.ev.ev) > 2) conf += 0.5;
            else if (parseFloat(analytics.spread.ev.ev) < -3) conf -= 1;
            
            // Boost for sharp money alignment
            if (analytics.lineMovement.status === 'aligned' && analytics.lineMovement.absMovement >= 1) conf += 0.5;
            else if (analytics.lineMovement.status === 'against' && analytics.lineMovement.absMovement >= 1.5) conf -= 1;
            
            // Slight penalty for high correlation (if both spread and total)
            if (analytics.correlation.level === 'high' && analysis.totalPick) conf -= 0.5;
            
            // Boost for favorable pace matchup
            if (analytics.paceAnalysis.extreme && analytics.paceAnalysis.impact !== 'neutral') conf += 0.5;
            
            return Math.max(1, Math.min(10, Math.round(conf)));
        }
        
        /**
         * Generate simple verdict for the user
         */
        function generateSimpleVerdict(analysis, analytics, enhancedConf, game) {
            if (!analysis || !analysis.spreadPick || analysis.spreadEdge < 2) {
                return { hasPlay: false };
            }
            
            const tier = enhancedConf >= 9 ? 'elite' : enhancedConf >= 7 ? 'high' : enhancedConf >= 5 ? 'medium' : 'low';
            const icon = enhancedConf >= 9 ? '' : enhancedConf >= 7 ? '' : enhancedConf >= 5 ? '' : '';
            
            // Build summary based on key factors
            let summaryParts = [];
            
            if (analysis.spreadEdge >= 5) {
                summaryParts.push(`${analysis.spreadEdge.toFixed(1)} points of value vs Vegas`);
            } else {
                summaryParts.push(`${analysis.spreadEdge.toFixed(1)} point edge`);
            }
            
            if (analytics && parseFloat(analytics.spread.ev.ev) > 0) {
                summaryParts.push(`+EV play ($${analytics.spread.ev.ev} per $100)`);
            }
            
            if (analytics && analytics.lineMovement.status === 'aligned') {
                summaryParts.push('sharp money agrees');
            }
            
            if (analysis.ratingGap >= 15) {
                summaryParts.push('significant talent gap');
            }
            
            const summary = summaryParts.slice(0, 3).join('. ') + '.';
            
            return {
                hasPlay: true,
                tier,
                icon,
                pick: analysis.spreadPick.team,
                line: analysis.spreadPick.line > 0 ? `+${analysis.spreadPick.line}` : analysis.spreadPick.line,
                pickTeam: analysis.spreadPick.team,
                pickLine: analysis.spreadPick.line,
                summary: analysis.reasoning || summary
            };
        }
        
        /**
         * Toggle drill down visibility
         */
        function toggleDrillDown(gameId) {
            const content = document.getElementById(`drill-${gameId}`);
            const arrow = document.getElementById(`drill-arrow-${gameId}`);
            
            if (!content) return;
            
            // Handle grid view rows (use display toggle)
            if (gameId.startsWith('bbg-')) {
                const isVisible = content.style.display !== 'none';
                content.style.display = isVisible ? 'none' : 'block';
                // Find the parent row and toggle expanded class
                const row = content.previousElementSibling;
                if (row) row.classList.toggle('expanded', !isVisible);
            } else {
                // Handle card view (use visible class)
                if (content.classList.contains('visible')) {
                    content.classList.remove('visible');
                    if (arrow) arrow.textContent = '';
                } else {
                    content.classList.add('visible');
                    if (arrow) arrow.textContent = '';
                }
            }
        }

        // Best Bets filter state
        let bbFilters = {
            type: 'value',      // 'spread', 'total', 'value'
            conf: 'all',
            minProb: 54,
            sortAsc: false,
            todayOnly: true
        };

        function renderBestBets() {
            const c = document.getElementById('bestBetsList');

            // Get filter values from state
            const typeFilter = bbFilters.type;
            const confFilter = bbFilters.conf;
            const minProb = bbFilters.minProb;

            // Collect all picks using win probability
            const allPicks = [];

            state.games.forEach(g => {
                const a = g.analysis;
                if (!a) return;

                // Get conference info
                const homeConf = g.homeRating?.conference || '';
                const awayConf = g.awayRating?.conference || '';

                // Filter by conference
                if (confFilter !== 'all') {
                    if (homeConf !== confFilter && awayConf !== confFilter) return;
                }

                // Filter by team search
                if (bbTeamSearchFilter) {
                    const searchLower = bbTeamSearchFilter.toLowerCase();
                    if (!g.homeTeam?.toLowerCase().includes(searchLower) &&
                        !g.awayTeam?.toLowerCase().includes(searchLower)) return;
                }

                // Filter by today only
                if (bbFilters.todayOnly && g.commenceTime) {
                    const gameDate = new Date(g.commenceTime);
                    const today = new Date();
                    if (gameDate.getFullYear() !== today.getFullYear() ||
                        gameDate.getMonth() !== today.getMonth() ||
                        gameDate.getDate() !== today.getDate()) return;
                }

                const analytics = calculateAdvancedAnalytics(g);

                // Use win probability for sorting and display
                const spreadWinProb = a.spreadWinProb || 50;
                const totalWinProb = a.totalWinProb || 50;

                // Add spread pick if qualifies
                if ((typeFilter === 'spread' || typeFilter === 'value') &&
                    a.spreadPick && spreadWinProb >= minProb && a.spreadEdge >= 2) {
                    allPicks.push({
                        type: 'spread',
                        game: g,
                        pick: `${a.spreadPick.team} ${a.spreadPick.line > 0 ? '+' : ''}${a.spreadPick.line}`,
                        pickTeam: a.spreadPick.team,
                        pickLine: a.spreadPick.line,
                        winProb: spreadWinProb,
                        edge: a.spreadEdge,
                        reasoning: a.reasoning,
                        factors: a.factors,
                        analytics: analytics,
                        projectedSpread: a.projectedSpread,
                        conference: homeConf || awayConf
                    });
                }

                // Add total pick if qualifies
                if ((typeFilter === 'total' || typeFilter === 'value') &&
                    a.totalPick && totalWinProb >= minProb && a.totalEdge >= 3) {
                    allPicks.push({
                        type: 'total',
                        game: g,
                        pick: `${a.totalPick.pick} ${a.totalPick.line}`,
                        pickTeam: a.totalPick.pick,
                        pickLine: a.totalPick.line,
                        winProb: totalWinProb,
                        edge: a.totalEdge,
                        reasoning: a.totalReasoning,
                        factors: [
                            { text: `${a.totalEdge.toFixed(1)}pt edge`, type: 'positive' },
                            { text: `Proj: ${a.projectedTotal}`, type: 'info' }
                        ],
                        analytics: analytics,
                        projectedTotal: a.projectedTotal,
                        conference: homeConf || awayConf
                    });
                }
            });

            // Sort by win probability (highest first by default)
            allPicks.sort((a, b) => bbFilters.sortAsc ? a.winProb - b.winProb : b.winProb - a.winProb);
            const topPicks = allPicks.slice(0, 25);

            if (!topPicks.length) {
                c.innerHTML = `<div class="bb-empty-state">
                    <div class="bb-empty-icon"></div>
                    <div class="bb-empty-title">No picks match your filters</div>
                    <div class="bb-empty-text">Try lowering the probability threshold or selecting different conferences.</div>
                </div>`;
                return;
            }

            // Render with new card layout
            renderBestBetsNewCards(c, topPicks);
            renderBBQuickStats(topPicks);
            restoreTrackedButtonStates();
        }

        // New card layout renderer
        function renderBestBetsNewCards(container, picks) {
            container.innerHTML = picks.map((p, i) => {
                const g = p.game;
                const a = g.analysis;
                const date = g.commenceTime.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                const time = g.commenceTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                // Confidence class
                const cc = getWinProbClass(p.winProb);
                const typeLabel = p.type === 'spread' ? 'SPREAD PICK' : 'TOTAL PICK (O/U)';
                const badgeClass = p.type === 'spread' ? 'spread' : (p.pickTeam === 'OVER' ? 'over' : 'under');

                // Calculate value score (edge as main metric)
                const valueScore = p.edge.toFixed(1);

                // Generate bullet points for the dropdown
                const bullets = p.type === 'spread'
                    ? generateSpreadBullets(g, a, p.winProb)
                    : generateTotalBullets(g, a, p.winProb);

                // Generate specialized best bet analysis
                const bestBetAnalysisHTML = generateBestBetAnalysis(g, a, p, p.analytics, bullets);

                // Conference badge
                const confBadge = p.conference ? `<span style="font-size:0.7rem;color:var(--text-muted);background:var(--bg-secondary);padding:0.15rem 0.4rem;border-radius:4px;margin-left:0.5rem;">${p.conference}</span>` : '';

                return `<div class="bb-pick-card tier-${cc}">
                    <!-- Rank -->
                    <div class="bb-pick-rank">
                        <div class="bb-pick-rank-label">RANK</div>
                        <div class="bb-pick-rank-num">#${i + 1}</div>
                    </div>

                    <!-- Matchup Info -->
                    <div class="bb-pick-info">
                        <div class="bb-pick-matchup">${g.awayTeam} @ ${g.homeTeam}${confBadge}</div>
                        <div class="bb-pick-meta">${date}  ${time}</div>
                    </div>

                    <!-- Pick Badge -->
                    <div class="bb-pick-badge-container">
                        <div class="bb-pick-badge-label">${typeLabel}</div>
                        <div class="bb-pick-badge ${badgeClass}">${p.pick}</div>
                    </div>

                    <!-- Model Confidence -->
                    <div class="bb-pick-confidence">
                        <div class="bb-pick-confidence-label">MODEL CONFIDENCE</div>
                        <div class="bb-pick-confidence-bar">
                            <div class="bb-pick-confidence-fill ${cc}" style="width: ${p.winProb}%;"></div>
                        </div>
                        <div class="bb-pick-confidence-value">${p.winProb.toFixed(0)}%</div>
                        ${cc === 'bestbet' ? `<div class="bb-pick-rating">${renderEliteRatingMini(p.winProb)}</div>` : ''}
                    </div>

                    <!-- Actions -->
                    <div style="display:flex;align-items:center;gap:0.5rem;grid-column: 1 / -1;">
                        <button class="bb-track-btn" id="track-${g.id}-${p.type}" onclick="trackPick('${g.id}','${p.type}',this)"> Track</button>
                        <div class="analytics-toggle" onclick="toggleDrillDown('bb-${g.id}-${p.type}')">
                            <span id="drill-arrow-bb-${g.id}-${p.type}"></span> Full Analysis
                        </div>
                    </div>
                    <div class="drill-down-content" id="drill-bb-${g.id}-${p.type}" style="grid-column: 1 / -1; margin:0.5rem 0 0;padding:0;">${bestBetAnalysisHTML}</div>
                </div>`;
            }).join('');
            // Stagger card entrance animations
            container.querySelectorAll('.bb-pick-card').forEach((card, i) => {
                card.style.animationDelay = `${i * 0.04}s`;
            });
        }

        // Filter functions
        function setBBTypeTab(type, btn) {
            bbFilters.type = type;
            document.querySelectorAll('.bb-type-tab:not(#bbTabToday)').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            renderBestBets();
        }

        function toggleBBToday(btn) {
            bbFilters.todayOnly = !bbFilters.todayOnly;
            btn.classList.toggle('active', bbFilters.todayOnly);
            renderBestBets();
        }

        function setBBConfFilter(conf, item) {
            bbFilters.conf = conf;
            document.querySelectorAll('#bbConfList .bb-conf-item').forEach(c => c.classList.remove('active'));
            item.classList.add('active');
            renderBestBets();
        }

        function updateBBProbSlider(value) {
            bbFilters.minProb = parseInt(value);
            document.getElementById('bbProbValue').textContent = value + '%';
            renderBestBets();
        }

        // Games tab filter state
        let gamesFilters = {
            conf: 'all',
            minProb: 54
        };

        function setGamesConfFilter(conf, item) {
            gamesFilters.conf = conf;
            state.confFilter = conf;  // Keep state in sync for backward compatibility
            document.querySelectorAll('#gamesConfList .bb-conf-item').forEach(c => c.classList.remove('active'));
            item.classList.add('active');
            renderGames();
        }

        function updateGamesProbSlider(value) {
            gamesFilters.minProb = parseInt(value);
            document.getElementById('gamesProbValue').textContent = value + '%';
            renderGames();
        }

        /**
         * Generate specialized analysis for Best Bets - focused on single bet type
         * Uses the new 3-panel layout matching the screenshot design
         */
        function generateBestBetAnalysis(g, a, pick, analytics, bullets) {
            const hr = g.homeRating || {};
            const ar = g.awayRating || {};

            if (pick.type === 'spread') {
                return generateSpreadBetAnalysis(g, a, pick, analytics, hr, ar, bullets);
            } else {
                return generateTotalBetAnalysis(g, a, pick, analytics, hr, ar, bullets);
            }
        }

        function generateSpreadBetAnalysis(g, a, pick, analytics, hr, ar, bullets) {
            const spreadEdge = a.spreadEdge || 0;
            const spreadWinProb = a.spreadWinProb || 50;
            const projSpread = a.projectedSpread || 0;
            const vegasSpread = g.spread || 0;

            // Team metrics
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;

            // Determine pick side details
            const pickSide = a.spreadPick?.side || 'home';
            const pickTeam = pickSide === 'home' ? g.homeTeam : g.awayTeam;
            const pickRating = pickSide === 'home' ? hr : ar;
            const oppRating = pickSide === 'home' ? ar : hr;
            const pickNet = pickRating.netRating || 0;
            const oppNet = oppRating.netRating || 0;

            // Format helpers
            const fmtS = v => v > 0 ? `+${v.toFixed(1)}` : v.toFixed(1);
            const trunc = (s, n) => s.length > n ? s.substring(0, n-1) + '.' : s;
            const netDiff = Math.abs(pickNet - oppNet);

            // Generate key factors
            const factors = generateBBKeyFactors(g, a, hr, ar, 'spread', pickSide);

            // Generate insight text
            const insightText = generateBBInsight(g, a, hr, ar, 'spread', pickTeam);

            return `
            <div class="analysis-panel single-pick">
                <!-- LEFT: Matchup Insights -->
                <div class="analysis-section-panel">
                    <div class="analysis-section-title">
                        <span class="title-icon"></span> Matchup Insights
                    </div>
                    <div class="matchup-insights">
                        <div class="metric-team-labels">
                            <span class="metric-team-label">${trunc(g.awayTeam, 12)}</span>
                            <span class="metric-team-label">${trunc(g.homeTeam, 12)}</span>
                        </div>

                        <!-- Adj. Efficiency -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayNet > homeNet ? 'better' : ''}">${awayNet > 0 ? '+' : ''}${awayNet.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">ADJ. EFFICIENCY</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, Math.abs(awayNet) * 2)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, Math.abs(homeNet) * 2)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeNet > awayNet ? 'better' : ''}">${homeNet > 0 ? '+' : ''}${homeNet.toFixed(1)}</span>
                        </div>

                        <!-- Offensive Rating -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayOff > homeOff ? 'better' : ''}">${awayOff.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">OFFENSIVE RTG</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, (awayOff - 90) * 2.5)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, (homeOff - 90) * 2.5)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeOff > awayOff ? 'better' : ''}">${homeOff.toFixed(1)}</span>
                        </div>

                        <!-- Defensive Rating -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayDef < homeDef ? 'better' : ''}">${awayDef.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">DEFENSIVE RTG</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, (115 - awayDef) * 2.5)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, (115 - homeDef) * 2.5)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeDef < awayDef ? 'better' : ''}">${homeDef.toFixed(1)}</span>
                        </div>
                    </div>
                </div>

                <!-- CENTER: Model Prediction -->
                <div class="analysis-section-panel model-prediction-panel">
                    <div class="analysis-section-title" style="justify-content: space-between;">
                        <span><span class="title-icon"></span> Model Prediction</span>
                        <span class="model-badge">CBB MODEL V4.1</span>
                    </div>

                    <!-- Confidence Circle -->
                    <div class="confidence-circle-container">
                        <div class="confidence-circle-bg" style="background: conic-gradient(var(--conf-elite) ${spreadWinProb * 3.6}deg, var(--bg-secondary) ${spreadWinProb * 3.6}deg);">
                            <div class="confidence-circle-inner">
                                <span class="confidence-circle-value">${spreadWinProb.toFixed(0)}%</span>
                                <span class="confidence-circle-label">MODEL<br>CONFIDENCE</span>
                            </div>
                        </div>
                    </div>

                    <!-- Single Prediction Box -->
                    <div class="prediction-box best-pick" style="margin: 0 auto; max-width: 200px;">
                        <div class="prediction-label">Spread Prediction</div>
                        <div class="prediction-value spread">${trunc(pickTeam, 10)} ${fmtS(a.spreadPick?.line || vegasSpread)}</div>
                        <div class="prediction-edge">Edge: <span class="edge-value">+${spreadEdge.toFixed(1)}</span></div>
                    </div>

                    <!-- Model Insight -->
                    <div class="model-insight">
                        <span class="model-insight-icon"></span>
                        <span class="model-insight-text">${insightText}</span>
                    </div>
                </div>

                <!-- RIGHT: Key Factors -->
                <div class="analysis-section-panel key-factors-panel">
                    <div class="analysis-section-title">
                        <span class="title-icon"></span> Key Factors
                    </div>

                    ${factors.map(f => `
                        <div class="factor-item-row ${f.type}">
                            <span class="factor-icon">${f.icon}</span>
                            <span class="factor-text">${f.text}</span>
                            <span class="factor-value">${f.value}</span>
                        </div>
                    `).join('')}

                    <!-- Mini Stats -->
                    <div class="stat-mini-grid">
                        <div class="stat-mini-card">
                            <div class="stat-mini-value positive">${fmtS(spreadEdge)}</div>
                            <div class="stat-mini-label">Edge</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value ${netDiff >= 10 ? 'positive' : ''}">${netDiff.toFixed(1)}</div>
                            <div class="stat-mini-label">Net Gap</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value">${fmtS(projSpread)}</div>
                            <div class="stat-mini-label">Projected</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value">${fmtS(vegasSpread)}</div>
                            <div class="stat-mini-label">Vegas</div>
                        </div>
                    </div>
                </div>
            </div>`;
        }

        function generateTotalBetAnalysis(g, a, pick, analytics, hr, ar, bullets) {
            const totalEdge = a.totalEdge || 0;
            const totalWinProb = a.totalWinProb || 50;
            const projTotal = a.projectedTotal || 140;
            const vegasTotal = g.total || 140;
            const direction = a.totalPick?.pick || 'OVER';
            const isOver = direction === 'OVER';

            // Team metrics
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;

            // Calculate projected scores based on efficiency ratings
            const homeExpectedPts = (homeOff + awayDef) / 2;
            const awayExpectedPts = (awayOff + homeDef) / 2;
            const rawTotal = homeExpectedPts + awayExpectedPts;
            const scaleFactor = projTotal / rawTotal;
            const projectedHomeScore = Math.round(homeExpectedPts * scaleFactor);
            const projectedAwayScore = Math.round(awayExpectedPts * scaleFactor);

            // Combined metrics
            const combinedOff = (homeOff + awayOff) / 2;
            const combinedDef = (homeDef + awayDef) / 2;

            // Format helpers
            const trunc = (s, n) => s.length > n ? s.substring(0, n-1) + '.' : s;

            // Generate key factors
            const factors = generateBBKeyFactors(g, a, hr, ar, 'total', null);

            // Generate insight text
            const insightText = generateBBInsight(g, a, hr, ar, 'total', direction);

            return `
            <div class="analysis-panel single-pick">
                <!-- LEFT: Matchup Insights -->
                <div class="analysis-section-panel">
                    <div class="analysis-section-title">
                        <span class="title-icon"></span> Matchup Insights
                    </div>
                    <div class="matchup-insights">
                        <div class="metric-team-labels">
                            <span class="metric-team-label">${trunc(g.awayTeam, 12)}</span>
                            <span class="metric-team-label">${trunc(g.homeTeam, 12)}</span>
                        </div>

                        <!-- Offensive Rating -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayOff > homeOff ? 'better' : ''}">${awayOff.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">OFFENSIVE RTG</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, (awayOff - 95) / 0.3)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, (homeOff - 95) / 0.3)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeOff > awayOff ? 'better' : ''}">${homeOff.toFixed(1)}</span>
                        </div>

                        <!-- Defensive Rating -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayDef < homeDef ? 'better' : ''}">${awayDef.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">DEFENSIVE RTG</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, (110 - awayDef) / 0.3)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, (110 - homeDef) / 0.3)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeDef < awayDef ? 'better' : ''}">${homeDef.toFixed(1)}</span>
                        </div>

                        <!-- Net Rating -->
                        <div class="metric-compare-row">
                            <span class="metric-team-value left ${awayNet > homeNet ? 'better' : ''}">${awayNet > 0 ? '+' : ''}${awayNet.toFixed(1)}</span>
                            <div class="metric-bar-container">
                                <span class="metric-label">NET RATING</span>
                                <div class="metric-bar-track">
                                    <div class="metric-bar-fill left" style="width: ${Math.min(50, Math.max(0, awayNet + 10) / 0.4)}%;"></div>
                                    <div class="metric-bar-fill right" style="width: ${Math.min(50, Math.max(0, homeNet + 10) / 0.4)}%;"></div>
                                    <div class="metric-bar-center"></div>
                                </div>
                            </div>
                            <span class="metric-team-value right ${homeNet > awayNet ? 'better' : ''}">${homeNet > 0 ? '+' : ''}${homeNet.toFixed(1)}</span>
                        </div>
                    </div>
                </div>

                <!-- CENTER: Model Prediction -->
                <div class="analysis-section-panel model-prediction-panel">
                    <div class="analysis-section-title" style="justify-content: space-between;">
                        <span><span class="title-icon"></span> Model Prediction</span>
                        <span class="model-badge">CBB MODEL V4.1</span>
                    </div>

                    <!-- Confidence Circle -->
                    <div class="confidence-circle-container">
                        <div class="confidence-circle-bg" style="background: conic-gradient(${isOver ? 'var(--accent-green)' : 'var(--accent-blue)'} ${totalWinProb * 3.6}deg, var(--bg-secondary) ${totalWinProb * 3.6}deg);">
                            <div class="confidence-circle-inner">
                                <span class="confidence-circle-value" style="color: ${isOver ? 'var(--accent-green)' : 'var(--accent-blue)'};">${totalWinProb.toFixed(0)}%</span>
                                <span class="confidence-circle-label">MODEL<br>CONFIDENCE</span>
                            </div>
                        </div>
                    </div>

                    <!-- Single Prediction Box -->
                    <div class="prediction-box best-pick" style="margin: 0 auto; max-width: 200px;">
                        <div class="prediction-label">Total Prediction</div>
                        <div class="prediction-value ${isOver ? 'over' : 'under'}">${direction} ${vegasTotal}</div>
                        <div class="prediction-edge">Value Edge: <span class="edge-value">+${totalEdge.toFixed(1)}%</span></div>
                        <div class="prediction-projected">Projected: ${projTotal.toFixed(0)}</div>
                    </div>

                    <!-- Projected Score -->
                    <div style="text-align: center; margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-secondary);">
                        <span style="font-weight: 600;">${g.awayTeam.split(' ').pop()}</span> ${projectedAwayScore} - ${projectedHomeScore} <span style="font-weight: 600;">${g.homeTeam.split(' ').pop()}</span>
                        <span style="margin-left: 0.5rem; font-weight: 700; color: ${isOver ? 'var(--accent-green)' : 'var(--accent-blue)'};">= ${projectedAwayScore + projectedHomeScore}</span>
                    </div>

                    <!-- Model Insight -->
                    <div class="model-insight">
                        <span class="model-insight-icon"></span>
                        <span class="model-insight-text">${insightText}</span>
                    </div>
                </div>

                <!-- RIGHT: Key Factors -->
                <div class="analysis-section-panel key-factors-panel">
                    <div class="analysis-section-title">
                        <span class="title-icon"></span> Key Factors
                    </div>

                    ${factors.map(f => `
                        <div class="factor-item-row ${f.type}">
                            <span class="factor-icon">${f.icon}</span>
                            <span class="factor-text">${f.text}</span>
                            <span class="factor-value">${f.value}</span>
                        </div>
                    `).join('')}

                    <!-- Mini Stats -->
                    <div class="stat-mini-grid">
                        <div class="stat-mini-card">
                            <div class="stat-mini-value ${isOver ? 'positive' : ''}" style="color: ${isOver ? 'var(--accent-green)' : 'var(--accent-blue)'};">+${totalEdge.toFixed(1)}</div>
                            <div class="stat-mini-label">Edge</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value">${projTotal.toFixed(0)}</div>
                            <div class="stat-mini-label">Proj Total</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value">${combinedOff.toFixed(0)}</div>
                            <div class="stat-mini-label">Comb. Off</div>
                        </div>
                        <div class="stat-mini-card">
                            <div class="stat-mini-value">${combinedDef.toFixed(0)}</div>
                            <div class="stat-mini-label">Comb. Def</div>
                        </div>
                    </div>
                </div>
            </div>`;
        }

        // Helper function to generate key factors for Best Bets panel
        function generateBBKeyFactors(g, a, hr, ar, pickType, pickSide) {
            const factors = [];
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;
            const netDiff = Math.abs(homeNet - awayNet);

            if (pickType === 'spread') {
                // Spread-specific factors
                if (netDiff >= 10) {
                    factors.push({ icon: '', text: 'Net Rating Gap', value: `${netDiff.toFixed(0)}pt`, type: 'positive' });
                } else if (netDiff >= 5) {
                    factors.push({ icon: '', text: 'Net Rating Gap', value: `${netDiff.toFixed(0)}pt`, type: 'neutral' });
                }

                if (pickSide === 'home') {
                    factors.push({ icon: '', text: 'Home Court Adj.', value: '+3.5', type: 'positive' });
                } else {
                    factors.push({ icon: '', text: 'Road Team Pick', value: '-3.5', type: 'neutral' });
                }

                // Elite offense/defense
                if (homeOff > 112 || awayOff > 112) {
                    factors.push({ icon: '', text: 'Elite Offense', value: `${Math.max(homeOff, awayOff).toFixed(0)}`, type: 'positive' });
                }
                if (homeDef < 96 || awayDef < 96) {
                    factors.push({ icon: '', text: 'Elite Defense', value: `${Math.min(homeDef, awayDef).toFixed(0)}`, type: 'positive' });
                }
            } else {
                // Total-specific factors
                const combinedDef = (homeDef + awayDef) / 2;
                const combinedOff = (homeOff + awayOff) / 2;
                const direction = a.totalPick?.pick || 'OVER';
                const isOver = direction === 'OVER';

                if (combinedDef > 102) {
                    factors.push({ icon: '', text: 'Weak Defenses', value: `${combinedDef.toFixed(0)}`, type: isOver ? 'positive' : 'negative' });
                } else if (combinedDef < 97) {
                    factors.push({ icon: '', text: 'Strong Defenses', value: `${combinedDef.toFixed(0)}`, type: !isOver ? 'positive' : 'negative' });
                }

                if (combinedOff > 108) {
                    factors.push({ icon: '', text: 'High-Scoring Teams', value: `${combinedOff.toFixed(0)}`, type: isOver ? 'positive' : 'neutral' });
                } else if (combinedOff < 98) {
                    factors.push({ icon: '', text: 'Low-Scoring Teams', value: `${combinedOff.toFixed(0)}`, type: !isOver ? 'positive' : 'neutral' });
                }

                // Offensive vs Defensive mismatch
                const offDiff = Math.abs(homeOff - awayOff);
                if (offDiff >= 8) {
                    factors.push({ icon: '', text: 'Offense Mismatch', value: `${offDiff.toFixed(0)} gap`, type: 'neutral' });
                }

                // Add edge factor
                const totalEdge = a.totalEdge || 0;
                if (totalEdge >= 5) {
                    factors.push({ icon: '', text: 'Strong Edge', value: `+${totalEdge.toFixed(1)}%`, type: 'positive' });
                }
            }

            return factors.slice(0, 4);
        }

        // Helper function to generate insight text for Best Bets
        function generateBBInsight(g, a, hr, ar, pickType, pickTeamOrDirection) {
            const homeNet = hr.netRating || 0;
            const awayNet = ar.netRating || 0;
            const homeOff = hr.offRating || 100;
            const awayOff = ar.offRating || 100;
            const homeDef = hr.defRating || 100;
            const awayDef = ar.defRating || 100;
            const netDiff = Math.abs(homeNet - awayNet);
            const combinedOff = (homeOff + awayOff) / 2;
            const combinedDef = (homeDef + awayDef) / 2;

            if (pickType === 'spread') {
                if (netDiff >= 10) {
                    return `The model favors <strong>${pickTeamOrDirection}'s efficiency</strong> advantage. With a ${netDiff.toFixed(0)}-point net rating gap, expect them to cover.`;
                } else if (netDiff >= 5) {
                    return `Model projects <strong>${pickTeamOrDirection}</strong> to outperform the spread based on efficiency metrics and matchup analysis.`;
                }
                return `Analysis shows value on <strong>${pickTeamOrDirection}</strong> based on combined efficiency and matchup factors.`;
            } else {
                const direction = pickTeamOrDirection;
                if (direction === 'UNDER') {
                    if (combinedDef < 98) {
                        return `Strong defensive profiles (avg ${combinedDef.toFixed(0)} def rtg) suggest the <strong>Under</strong> holds value in this matchup.`;
                    }
                    return `Model projects scoring below the line. The <strong>Under</strong> offers value based on defensive matchups.`;
                } else {
                    if (combinedOff > 106) {
                        return `High offensive efficiency (avg ${combinedOff.toFixed(0)} off rtg) suggests the <strong>Over</strong> holds value in this matchup.`;
                    }
                    return `Model projects higher scoring than Vegas. The <strong>Over</strong> offers value based on offensive metrics.`;
                }
            }
        }

        // ==================== PREDICTION TRACKING SYSTEM ====================
        // IndexedDB-based prediction storage with auto-resolution
        
        const PREDICTIONS_DB_NAME = 'SpreadSheetPredictions';
        const PREDICTIONS_DB_VERSION = 1;
        const PREDICTIONS_STORE_NAME = 'predictions';
        let predictionsDB = null;
        let currentTrackerFilter = 'bestBet';
        
        // Initialize IndexedDB
        async function initPredictionsDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(PREDICTIONS_DB_NAME, PREDICTIONS_DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    predictionsDB = request.result;
                    resolve(predictionsDB);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(PREDICTIONS_STORE_NAME)) {
                        const store = db.createObjectStore(PREDICTIONS_STORE_NAME, { keyPath: 'id' });
                        store.createIndex('gameId', 'gameId', { unique: false });
                        store.createIndex('status', 'status', { unique: false });
                        store.createIndex('capturedAt', 'capturedAt', { unique: false });
                        store.createIndex('gameDate', 'gameDate', { unique: false });
                    }
                };
            });
        }
        
        // Export predictions to JSON backup file
        async function exportPredictionsBackup() {
            const predictions = await getAllPredictions();
            if (predictions.length === 0) {
                alert('No predictions to export');
                return;
            }
            const data = JSON.stringify(predictions, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const date = new Date().toISOString().split('T')[0];
            a.download = `spreadsheet_backup_${date}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Import predictions from JSON backup file
        function importPredictionsBackup() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.csv';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                // Route CSV files to the CSV importer
                if (file.name.toLowerCase().endsWith('.csv')) {
                    await importPredictions(file);
                    return;
                }
                
                try {
                    const text = await file.text();
                    const predictions = JSON.parse(text);
                    
                    if (!Array.isArray(predictions)) {
                        alert('Invalid backup file format');
                        return;
                    }
                    
                    if (!confirm(`Import ${predictions.length} predictions? This will merge with existing data.`)) {
                        return;
                    }
                    
                    if (!predictionsDB) await initPredictionsDB();
                    const transaction = predictionsDB.transaction([PREDICTIONS_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(PREDICTIONS_STORE_NAME);
                    
                    let count = 0;
                    predictions.forEach(pred => {
                        store.put(pred);
                        count++;
                    });
                    
                    transaction.oncomplete = () => {
                        alert(`Successfully imported ${count} predictions!`);
                        renderPredictionTracker();
                    };
                    transaction.onerror = () => {
                        alert('Error importing predictions: ' + transaction.error);
                    };
                } catch (err) {
                    alert('Error reading file: ' + err.message);
                }
            };
            input.click();
        }
        
        // Check for weekly auto-backup
        function checkWeeklyBackup() {
            const lastBackup = localStorage.getItem('spreadsheet_last_backup');
            const now = Date.now();
            const oneWeek = 7 * 24 * 60 * 60 * 1000;
            
            if (!lastBackup || (now - parseInt(lastBackup)) > oneWeek) {
                // Show backup reminder
                setTimeout(() => {
                    if (confirm('Weekly backup reminder: Would you like to export your prediction data now?')) {
                        exportPredictionsBackup();
                        localStorage.setItem('spreadsheet_last_backup', now.toString());
                    }
                }, 3000);
            }
        }

        // ============================================
        // Google Drive Cloud Sync
        // ============================================
        
        // SETUP INSTRUCTIONS:
        // 1. Go to https://console.cloud.google.com/
        // 2. Create a new project (or select existing)
        // 3. Enable the Google Drive API
        // 4. Go to "Credentials" > "Create Credentials" > "OAuth 2.0 Client ID"
        // 5. Choose "Web application"
        // 6. Add your site URL to "Authorized JavaScript origins" (e.g., https://yourusername.github.io)
        // 7. Copy the Client ID and paste it below
        
        const GOOGLE_CLIENT_ID = '449393699194-tfkpe896h8haddlse09rpcfbnckad0up.apps.googleusercontent.com'; // Paste your Client ID here
        const DRIVE_FILE_NAME = 'spreadsheet_predictions.json';
        const DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.appdata';
        
        let googleAccessToken = null;
        let tokenClient = null;
        
        // Initialize Google Identity Services
        function initGoogleAuth() {
            if (!GOOGLE_CLIENT_ID) {
                console.log('Google Drive sync not configured - no Client ID');
                return;
            }
            
            if (typeof google === 'undefined' || !google.accounts) {
                // Script not loaded yet, try again
                setTimeout(initGoogleAuth, 500);
                return;
            }
            
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: DRIVE_SCOPES,
                callback: handleTokenResponse
            });
            
            // Check if we have a saved token
            const savedToken = localStorage.getItem('google_access_token');
            const tokenExpiry = localStorage.getItem('google_token_expiry');
            
            if (savedToken && tokenExpiry && Date.now() < parseInt(tokenExpiry)) {
                googleAccessToken = savedToken;
                updateCloudSyncUI(true);
            }
        }
        
        // Handle OAuth token response
        function handleTokenResponse(response) {
            if (response.error) {
                console.error('Google auth error:', response.error);
                showShareToast('Google sign-in failed');
                return;
            }
            
            googleAccessToken = response.access_token;
            // Token expires in ~1 hour, save with buffer
            const expiry = Date.now() + (response.expires_in * 1000) - 60000;
            localStorage.setItem('google_access_token', googleAccessToken);
            localStorage.setItem('google_token_expiry', expiry.toString());
            
            updateCloudSyncUI(true);
            showShareToast('Connected to Google Drive');
        }
        
        // Sign in with Google
        function signInWithGoogle() {
            if (!GOOGLE_CLIENT_ID) {
                showCloudSyncSetup();
                return;
            }
            
            if (!tokenClient) {
                initGoogleAuth();
                setTimeout(signInWithGoogle, 500);
                return;
            }
            
            tokenClient.requestAccessToken();
        }
        
        // Sign out of Google
        function signOutGoogle() {
            googleAccessToken = null;
            localStorage.removeItem('google_access_token');
            localStorage.removeItem('google_token_expiry');
            
            if (googleAccessToken && google.accounts.oauth2) {
                google.accounts.oauth2.revoke(googleAccessToken);
            }
            
            updateCloudSyncUI(false);
            showShareToast('Signed out of Google Drive');
        }
        
        // Show setup instructions
        function showCloudSyncSetup() {
            const instructions = `
Cloud Sync Setup Required:

1. Go to console.cloud.google.com
2. Create a project & enable Google Drive API
3. Create OAuth 2.0 credentials (Web application)
4. Add your site URL to Authorized JavaScript origins
5. Copy the Client ID
6. Open the site's HTML file and find GOOGLE_CLIENT_ID
7. Paste your Client ID there

For detailed instructions, see the comments in the source code.
            `.trim();
            
            alert(instructions);
        }
        
        // Update UI based on sign-in state
        function updateCloudSyncUI(signedIn) {
            const signInBtn = document.getElementById('googleSignInBtn');
            const syncBtn = document.getElementById('cloudSyncBtn');
            const statusEl = document.getElementById('cloudSyncStatus');
            
            if (signedIn) {
                if (signInBtn) signInBtn.style.display = 'none';
                if (syncBtn) syncBtn.style.display = 'inline-flex';
                
                const lastSync = localStorage.getItem('cloud_last_sync');
                if (statusEl) {
                    if (lastSync) {
                        const date = new Date(parseInt(lastSync));
                        statusEl.innerHTML = `<span class="connected"></span> Last sync: ${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                    } else {
                        statusEl.innerHTML = '<span class="connected"></span> Connected';
                    }
                    statusEl.classList.add('connected');
                }
            } else {
                if (signInBtn) signInBtn.style.display = 'inline-flex';
                if (syncBtn) syncBtn.style.display = 'none';
                if (statusEl) {
                    statusEl.textContent = '';
                    statusEl.classList.remove('connected');
                }
            }
        }
        
        // Main sync function - pulls from cloud, merges, pushes back
        async function syncToCloud() {
            if (!googleAccessToken) {
                signInWithGoogle();
                return;
            }
            
            const syncBtn = document.getElementById('cloudSyncBtn');
            if (syncBtn) {
                syncBtn.disabled = true;
                syncBtn.innerHTML = ' Syncing...';
            }
            
            try {
                // Get local predictions
                const localPredictions = await getAllPredictions();
                const localMap = new Map(localPredictions.map(p => [p.id, p]));
                
                // Try to get cloud predictions
                let cloudPredictions = [];
                const fileId = await findDriveFile();
                
                if (fileId) {
                    const content = await getDriveFileContent(fileId);
                    try {
                        cloudPredictions = JSON.parse(content);
                        if (!Array.isArray(cloudPredictions)) cloudPredictions = [];
                    } catch (e) {
                        cloudPredictions = [];
                    }
                }
                
                // Merge: cloud data wins for graded items, local wins for pending
                const cloudMap = new Map(cloudPredictions.map(p => [p.id, p]));
                const mergedMap = new Map();
                
                // Add all cloud predictions
                cloudPredictions.forEach(p => mergedMap.set(p.id, p));
                
                // Add/update with local predictions
                localPredictions.forEach(localPred => {
                    const cloudPred = cloudMap.get(localPred.id);
                    
                    if (!cloudPred) {
                        // New local prediction
                        mergedMap.set(localPred.id, localPred);
                    } else if (localPred.status === 'graded' && cloudPred.status === 'pending') {
                        // Local is graded, use local
                        mergedMap.set(localPred.id, localPred);
                    } else if (localPred.status === 'pending' && cloudPred.status === 'graded') {
                        // Cloud is graded, use cloud
                        mergedMap.set(localPred.id, cloudPred);
                    } else {
                        // Both same status - use most recently updated
                        const localTime = new Date(localPred.resolvedAt || localPred.capturedAt).getTime();
                        const cloudTime = new Date(cloudPred.resolvedAt || cloudPred.capturedAt).getTime();
                        mergedMap.set(localPred.id, localTime > cloudTime ? localPred : cloudPred);
                    }
                });
                
                const merged = Array.from(mergedMap.values());
                
                // Save merged to cloud
                const content = JSON.stringify(merged);
                if (fileId) {
                    await updateDriveFile(fileId, content);
                } else {
                    await createDriveFile(content);
                }
                
                // Save merged to local IndexedDB
                if (!predictionsDB) await initPredictionsDB();
                const transaction = predictionsDB.transaction([PREDICTIONS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(PREDICTIONS_STORE_NAME);
                merged.forEach(pred => store.put(pred));
                
                await new Promise((resolve, reject) => {
                    transaction.oncomplete = resolve;
                    transaction.onerror = () => reject(transaction.error);
                });
                
                // Update last sync time
                localStorage.setItem('cloud_last_sync', Date.now().toString());
                localStorage.setItem('spreadsheet_last_backup', Date.now().toString());
                
                // Refresh UI
                await renderPredictionTracker();
                updateCloudSyncUI(true);
                
                const added = merged.length - localPredictions.length;
                const msg = added > 0 
                    ? `Synced! ${merged.length} predictions (${added} new from cloud)`
                    : `Synced ${merged.length} predictions`;
                showShareToast(msg);
                
            } catch (err) {
                console.error('Cloud sync error:', err);
                
                // Check if token expired
                if (err.message?.includes('401') || err.message?.includes('403')) {
                    googleAccessToken = null;
                    localStorage.removeItem('google_access_token');
                    updateCloudSyncUI(false);
                    showShareToast('Session expired - please sign in again');
                } else {
                    showShareToast('Sync failed: ' + (err.message || 'Unknown error'));
                }
            } finally {
                if (syncBtn) {
                    syncBtn.disabled = false;
                    syncBtn.innerHTML = ' Sync';
                }
            }
        }
        
        // Find the backup file in Google Drive appDataFolder
        async function findDriveFile() {
            const response = await fetch(
                `https://www.googleapis.com/drive/v3/files?spaces=appDataFolder&q=name='${DRIVE_FILE_NAME}'&fields=files(id,name)`,
                {
                    headers: { 'Authorization': `Bearer ${googleAccessToken}` }
                }
            );
            
            if (!response.ok) {
                throw new Error(`Drive API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.files && data.files.length > 0 ? data.files[0].id : null;
        }
        
        // Create a new file in Drive appDataFolder
        async function createDriveFile(content) {
            const metadata = {
                name: DRIVE_FILE_NAME,
                parents: ['appDataFolder']
            };
            
            const form = new FormData();
            form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            form.append('file', new Blob([content], { type: 'application/json' }));
            
            const response = await fetch(
                'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
                {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${googleAccessToken}` },
                    body: form
                }
            );
            
            if (!response.ok) {
                throw new Error(`Drive create error: ${response.status}`);
            }
            
            return response.json();
        }
        
        // Update existing file in Drive
        async function updateDriveFile(fileId, content) {
            const response = await fetch(
                `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`,
                {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: content
                }
            );
            
            if (!response.ok) {
                throw new Error(`Drive update error: ${response.status}`);
            }
            
            return response.json();
        }
        
        // Get file content from Drive
        async function getDriveFileContent(fileId) {
            const response = await fetch(
                `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
                {
                    headers: { 'Authorization': `Bearer ${googleAccessToken}` }
                }
            );
            
            if (!response.ok) {
                throw new Error(`Drive read error: ${response.status}`);
            }
            
            return response.text();
        }

        // Save a prediction to IndexedDB
        async function savePrediction(prediction) {
            if (!predictionsDB) await initPredictionsDB();
            return new Promise((resolve, reject) => {
                const transaction = predictionsDB.transaction([PREDICTIONS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(PREDICTIONS_STORE_NAME);
                const request = store.put(prediction);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Get all predictions
        async function getAllPredictions() {
            if (!predictionsDB) await initPredictionsDB();
            return new Promise((resolve, reject) => {
                const transaction = predictionsDB.transaction([PREDICTIONS_STORE_NAME], 'readonly');
                const store = transaction.objectStore(PREDICTIONS_STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }
        
        // Get prediction by game ID and type
        async function getPredictionByGameAndType(gameId, pickType) {
            const all = await getAllPredictions();
            return all.find(p => p.gameId === gameId && p.pickType === pickType);
        }
        
        // Clear all predictions
        async function clearAllPredictionsDB() {
            if (!predictionsDB) await initPredictionsDB();
            return new Promise((resolve, reject) => {
                const transaction = predictionsDB.transaction([PREDICTIONS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(PREDICTIONS_STORE_NAME);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // Delete a single prediction by ID
        async function deletePrediction(id) {
            if (!predictionsDB) await initPredictionsDB();
            return new Promise((resolve, reject) => {
                const transaction = predictionsDB.transaction([PREDICTIONS_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(PREDICTIONS_STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // Remove predictions that are missing winProb data
        async function cleanupIncompletePredictions() {
            const all = await getAllPredictions();
            const incomplete = all.filter(p => p.winProb === undefined || p.winProb === null);
            
            if (incomplete.length === 0) {
                alert('No incomplete predictions to remove.');
                return;
            }
            
            if (!confirm(`Remove ${incomplete.length} predictions that are missing win% data?\n\nThis cannot be undone.`)) {
                return;
            }
            
            let removed = 0;
            for (const pred of incomplete) {
                try {
                    await deletePrediction(pred.id);
                    removed++;
                } catch (e) {
                    console.error('Error removing prediction:', pred.id, e);
                }
            }
            
            console.log(` Cleaned up ${removed} incomplete predictions`);
            alert(`Removed ${removed} incomplete predictions.`);
            
            // Refresh the tracker display
            await renderPredictionTracker();
        }
        
        // Generate unique prediction ID
        function generatePredictionId(gameId, pickType) {
            return `${gameId}_${pickType}`;
        }
        
        // Capture predictions from current games
        async function capturePredictions() {
            if (!state.games.length) {
                console.log(' Capture: No games in state');
                return 0;
            }
            
            const now = new Date().toISOString();
            let capturedCount = 0;
            let debugStats = { total: 0, withAnalysis: 0, withRatings: 0, spreadQualified: 0, totalQualified: 0, alreadyCaptured: 0 };
            
            for (const game of state.games) {
                debugStats.total++;
                const a = game.analysis;
                if (!a) continue;
                debugStats.withAnalysis++;
                
                // Skip games without ratings
                if (a.missingRatings) continue;
                debugStats.withRatings++;
                
                // === SPREAD PREDICTION ===
                // Capture any spread pick with edge (winProb >= 52.4% breakeven)
                const spreadWinProb = a.spreadWinProb || 0;
                const spreadMeetsCriteria = game.spread !== null && a.spreadPick && spreadWinProb >= 52.4;
                if (spreadMeetsCriteria) debugStats.spreadQualified++;
                
                if (spreadMeetsCriteria) {
                    const predId = generatePredictionId(game.id, 'spread');
                    const existing = await getPredictionByGameAndType(game.id, 'spread');
                    
                    if (existing) {
                        debugStats.alreadyCaptured++;
                    } else {
                        const pick = a.spreadPick;
                        const isBestBet = spreadWinProb >= TIER_THRESHOLDS.BEST_BET; // Best Bet tier (62%+ calibrated)
                        const bestBetRating = isBestBet ? getEliteRating(spreadWinProb) : 0;
                        
                        await savePrediction({
                            id: predId,
                            gameId: game.id,
                            pickType: 'spread',
                            homeTeam: game.homeTeam,
                            awayTeam: game.awayTeam,
                            gameDate: game.commenceTime.toISOString(),
                            capturedAt: now,
                            vegasLine: game.spread,
                            pickTeam: pick.side === 'home' ? game.homeTeam : game.awayTeam,
                            pickSide: pick.side,
                            pickLine: pick.line,
                            pickDisplay: `${pick.side === 'home' ? game.homeTeam : game.awayTeam} ${pick.line > 0 ? '+' : ''}${pick.line}`,
                            confidence: a.spreadScore,
                            winProb: spreadWinProb,
                            edge: a.spreadEdge,
                            isBestBet: isBestBet,
                            bestBetRating: bestBetRating,
                            status: 'pending',
                            result: null,
                            homeScore: null,
                            awayScore: null,
                            resolvedAt: null
                        });
                        capturedCount++;
                    }
                }
                
                // === TOTAL PREDICTION ===
                // Capture any total pick with edge (winProb >= 52.4% breakeven)
                const totalWinProb = a.totalWinProb || 0;
                const totalMeetsCriteria = game.total !== null && a.totalPick && totalWinProb >= 52.4;
                if (totalMeetsCriteria) debugStats.totalQualified++;
                
                if (totalMeetsCriteria) {
                    const predId = generatePredictionId(game.id, 'total');
                    const existing = await getPredictionByGameAndType(game.id, 'total');
                    
                    if (existing) {
                        debugStats.alreadyCaptured++;
                    } else {
                        const pick = a.totalPick;
                        const isBestBet = totalWinProb >= TIER_THRESHOLDS.BEST_BET; // Best Bet tier (62%+ calibrated)
                        const bestBetRating = isBestBet ? getEliteRating(totalWinProb) : 0;
                        
                        await savePrediction({
                            id: predId,
                            gameId: game.id,
                            pickType: 'total',
                            homeTeam: game.homeTeam,
                            awayTeam: game.awayTeam,
                            gameDate: game.commenceTime.toISOString(),
                            capturedAt: now,
                            vegasLine: game.total,
                            pickTeam: pick.pick, // OVER or UNDER
                            pickSide: pick.pick.toLowerCase(),
                            pickLine: game.total,
                            pickDisplay: `${pick.pick} ${game.total}`,
                            confidence: a.totalScore,
                            winProb: totalWinProb,
                            edge: a.totalEdge,
                            isBestBet: isBestBet,
                            bestBetRating: bestBetRating,
                            status: 'pending',
                            result: null,
                            homeScore: null,
                            awayScore: null,
                            resolvedAt: null
                        });
                        capturedCount++;
                    }
                }
            }
            
            // Debug summary
            console.log(` Capture Stats: ${debugStats.total} games  ${debugStats.withAnalysis} with analysis  ${debugStats.withRatings} with ratings`);
            console.log(` Qualified: ${debugStats.spreadQualified} spreads, ${debugStats.totalQualified} totals | Already captured: ${debugStats.alreadyCaptured}`);
            if (capturedCount > 0) {
                console.log(` Captured ${capturedCount} NEW predictions`);
            }
            
            // Update debug panel
            const debugEl = document.getElementById('debugCaptureStats');
            if (debugEl) {
                debugEl.innerHTML = `Capture: ${debugStats.total} games  ${debugStats.withRatings} with ratings  <strong>${debugStats.spreadQualified} spreads, ${debugStats.totalQualified} totals</strong> qualified  ${capturedCount} NEW captured (${debugStats.alreadyCaptured} already in DB)`;
            }
            
            return capturedCount;
        }
        
        // Resolve predictions with historical game results
        async function resolvePredictions() {
            if (!state.historicalGames.length) {
                console.log(' Resolve: No historical games loaded');
                return 0;
            }
            
            const predictions = await getAllPredictions();
            const pendingPredictions = predictions.filter(p => p.status === 'pending');
            
            console.log(` Resolve: ${state.historicalGames.length} historical games, ${predictions.length} total predictions, ${pendingPredictions.length} pending`);
            
            if (!pendingPredictions.length) {
                console.log(' Resolve: No pending predictions to resolve');
                return 0;
            }
            
            // Debug: Show sample historical games and predictions to compare formats
            if (pendingPredictions.length > 0 && state.historicalGames.length > 0) {
                const samplePred = pendingPredictions[0];
                const sampleHist = state.historicalGames[0];
                console.log(' DEBUG - Sample prediction:', {
                    homeTeam: samplePred.homeTeam,
                    awayTeam: samplePred.awayTeam,
                    gameDate: samplePred.gameDate,
                    normalizedHome: normalizeTeamName(samplePred.homeTeam),
                    ratingsHome: toRatingsName(samplePred.homeTeam),
                    normalizedAway: normalizeTeamName(samplePred.awayTeam),
                    ratingsAway: toRatingsName(samplePred.awayTeam),
                    dateStr: new Date(samplePred.gameDate).toISOString().split('T')[0]
                });
                console.log(' DEBUG - Sample historical game:', {
                    homeTeam: sampleHist.homeTeam,
                    awayTeam: sampleHist.awayTeam,
                    date: sampleHist.date,
                    normalizedHome: normalizeTeamName(sampleHist.homeTeam),
                    ratingsHome: toRatingsName(sampleHist.homeTeam),
                    normalizedAway: normalizeTeamName(sampleHist.awayTeam),
                    ratingsAway: toRatingsName(sampleHist.awayTeam),
                    dateStr: new Date(sampleHist.date).toISOString().split('T')[0]
                });
                
                // Show unique prediction dates
                const predDates = [...new Set(pendingPredictions.map(p => new Date(p.gameDate).toISOString().split('T')[0]))].sort();
                const histDates = [...new Set(state.historicalGames.slice(0, 100).map(h => new Date(h.date).toISOString().split('T')[0]))].sort().reverse().slice(0, 10);
                console.log(' DEBUG - Pending prediction dates:', predDates);
                console.log(' DEBUG - Recent historical dates (last 10):', histDates);
            }
            
            let resolvedCount = 0;
            let notFoundCount = 0;
            let dateMatchCount = 0;
            let teamMatchCount = 0;
            const now = new Date().toISOString();
            
            for (const pred of pendingPredictions) {
                // Find matching historical game
                const predDate = new Date(pred.gameDate).toISOString().split('T')[0];
                
                // First check if ANY game exists for this date
                const gamesOnDate = state.historicalGames.filter(hg => {
                    const histDate = new Date(hg.date).toISOString().split('T')[0];
                    return predDate === histDate;
                });
                
                if (gamesOnDate.length > 0) {
                    dateMatchCount++;
                }
                
                const histGame = state.historicalGames.find(hg => {
                    // Match by teams and approximate date
                    const histDate = new Date(hg.date).toISOString().split('T')[0];
                    
                    // Try multiple matching strategies
                    // 1. Exact match
                    // 2. Normalized match
                    // 3. Ratings-style match (strips mascots)
                    const teamsMatch = (
                        (hg.homeTeam === pred.homeTeam && hg.awayTeam === pred.awayTeam) ||
                        (normalizeTeamName(hg.homeTeam) === normalizeTeamName(pred.homeTeam) && 
                         normalizeTeamName(hg.awayTeam) === normalizeTeamName(pred.awayTeam)) ||
                        (normalizeTeamName(hg.homeTeam) === toRatingsName(pred.homeTeam) && 
                         normalizeTeamName(hg.awayTeam) === toRatingsName(pred.awayTeam)) ||
                        (toRatingsName(hg.homeTeam) === toRatingsName(pred.homeTeam) && 
                         toRatingsName(hg.awayTeam) === toRatingsName(pred.awayTeam))
                    );
                    
                    if (teamsMatch) teamMatchCount++;
                    
                    return teamsMatch && predDate === histDate;
                });
                
                if (!histGame || histGame.homeScore == null || histGame.awayScore == null) {
                    notFoundCount++;
                    continue;
                }
                
                // Calculate result
                let result = 'loss';
                const actualMargin = histGame.homeScore - histGame.awayScore;
                const actualTotal = histGame.homeScore + histGame.awayScore;
                
                if (pred.pickType === 'spread') {
                    if (pred.pickSide === 'home') {
                        const coverMargin = actualMargin + pred.vegasLine;
                        if (coverMargin > 0) result = 'win';
                        else if (coverMargin === 0) result = 'push';
                    } else {
                        const coverMargin = -actualMargin - pred.vegasLine;
                        if (coverMargin > 0) result = 'win';
                        else if (coverMargin === 0) result = 'push';
                    }
                } else if (pred.pickType === 'total') {
                    if (pred.pickTeam === 'OVER') {
                        if (actualTotal > pred.vegasLine) result = 'win';
                        else if (actualTotal === pred.vegasLine) result = 'push';
                    } else {
                        if (actualTotal < pred.vegasLine) result = 'win';
                        else if (actualTotal === pred.vegasLine) result = 'push';
                    }
                }
                
                // Update prediction
                pred.status = 'graded';
                pred.result = result;
                pred.homeScore = histGame.homeScore;
                pred.awayScore = histGame.awayScore;
                pred.resolvedAt = now;
                
                await savePrediction(pred);
                resolvedCount++;
            }
            
            console.log(` Resolve: Resolved ${resolvedCount}, still pending ${notFoundCount} (games not yet final)`);
            console.log(` DEBUG - Date matches: ${dateMatchCount}/${pendingPredictions.length}, Team matches found: ${teamMatchCount}`);
            
            // Update debug panel
            const debugEl = document.getElementById('debugResolveStats');
            if (debugEl) {
                debugEl.innerHTML = `Resolve: ${state.historicalGames.length} historical games | ${pendingPredictions.length} pending predictions  <strong>${resolvedCount} resolved</strong>, ${notFoundCount} still waiting (${dateMatchCount} date matches)`;
            }
            
            return resolvedCount;
        }
        
        // Calculate statistics from predictions
        function calculatePredictionStats(predictions) {
            const graded = predictions.filter(p => p.status === 'graded');
            const pending = predictions.filter(p => p.status === 'pending');
            
            const wins = graded.filter(p => p.result === 'win').length;
            const losses = graded.filter(p => p.result === 'loss').length;
            const pushes = graded.filter(p => p.result === 'push').length;
            const total = wins + losses;
            
            const winRate = total > 0 ? (wins / total) * 100 : 0;
            const roi = total > 0 ? ((wins * 0.91 - losses) / total) * 100 : 0;
            const units = (wins * 0.91) - losses;
            
            return {
                wins,
                losses,
                pushes,
                total,
                pending: pending.length,
                winRate,
                roi,
                units,
                graded
            };
        }
        
        // Time frame filter state
        let selectedTimeFrame = 30;
        let currentChartType = 'roi';
        let allPredictionsCache = [];
        
        function changeTimeFrame(days) {
            selectedTimeFrame = (days === 'all' || days === 'v51') ? days : parseInt(days);
            renderPredictionTracker();
        }
        
        function switchChart(type, btn) {
            currentChartType = type;
            document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            // Best Bets tab shows BB-only; Cumulative shows all picks
            const preds = allPredictionsCache || [];
            const chartPreds = type === 'roi' 
                ? preds.filter(p => p.isBestBet || (p.winProb && p.winProb >= TIER_THRESHOLDS.BEST_BET))
                : preds;
            renderPerformanceChart(filterByTimeFrame(chartPreds, selectedTimeFrame));
        }
        
        // Filter predictions by time frame
        function filterByTimeFrame(predictions, days) {
            if (days === 'all') return predictions;
            if (days === 'v51') {
                const v51Start = new Date('2026-02-09T00:00:00');
                return predictions.filter(p => new Date(p.gameDate) >= v51Start);
            }
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - days);
            return predictions.filter(p => new Date(p.gameDate) >= cutoff);
        }
        
        // Calculate trend data
        function calculateTrends(predictions) {
            const graded = predictions.filter(p => p.status === 'graded')
                .sort((a, b) => new Date(b.gameDate) - new Date(a.gameDate));
            
            if (graded.length < 2) {
                return { trend: 'neutral', last5: '--', last10: '--', streak: '--', streakType: 'neutral' };
            }
            
            // Last 5 and last 10
            const last5 = graded.slice(0, 5);
            const last10 = graded.slice(0, 10);
            
            const last5Wins = last5.filter(p => p.result === 'win').length;
            const last5Losses = last5.filter(p => p.result === 'loss').length;
            const last10Wins = last10.filter(p => p.result === 'win').length;
            const last10Losses = last10.filter(p => p.result === 'loss').length;
            
            // Calculate streak
            let streak = 0;
            let streakType = graded[0]?.result || 'neutral';
            for (const p of graded) {
                if (p.result === streakType) streak++;
                else break;
            }
            
            // Determine if hot or cold
            const last5WinRate = last5.length > 0 ? (last5Wins / last5.length) * 100 : 50;
            let trend = 'neutral';
            if (last5WinRate >= 60) trend = 'hot';
            else if (last5WinRate < 40) trend = 'cold';
            
            return {
                trend,
                last5: `${last5Wins}-${last5Losses}`,
                last10: `${last10Wins}-${last10Losses}`,
                streak: streak,
                streakType: streakType === 'win' ? 'W' : streakType === 'loss' ? 'L' : '-',
                last5WinRate
            };
        }

        // ============================================================
        // ADVANCED VALIDATION PANEL FUNCTIONS
        // ============================================================

        // Toggle metrics bar expand/collapse
        function toggleMetricsBar() {
            const wrapper = document.getElementById('metricsBarWrapper');
            const metricsBar = document.getElementById('metricsBar');
            const toggle = document.getElementById('metricsBarToggle');
            const isExpanded = wrapper.classList.contains('expanded');

            wrapper.classList.toggle('expanded');
            metricsBar.classList.toggle('collapsed', isExpanded);
            toggle.setAttribute('aria-expanded', !isExpanded);
            metricsBar.setAttribute('aria-hidden', isExpanded);
        }

        // Collapse metrics bar (called on refresh)
        function collapseMetricsBar() {
            const wrapper = document.getElementById('metricsBarWrapper');
            const metricsBar = document.getElementById('metricsBar');
            const toggle = document.getElementById('metricsBarToggle');

            if (wrapper && metricsBar && toggle) {
                wrapper.classList.remove('expanded');
                metricsBar.classList.add('collapsed');
                toggle.setAttribute('aria-expanded', 'false');
                metricsBar.setAttribute('aria-hidden', 'true');
            }
        }

        // Toggle validation panel expand/collapse
        function toggleAdvValidation() {
            const panel = document.getElementById('advValidationPanel');
            const toggle = document.getElementById('advValidationToggle');
            const isExpanded = panel.classList.contains('expanded');

            panel.classList.toggle('expanded');
            toggle.setAttribute('aria-expanded', !isExpanded);

            // Render content on first expand
            if (!isExpanded && panel.dataset.rendered !== 'true') {
                renderAdvValidation(allPredictionsCache || []);
            }
        }

        /**
         * Render data integrity notice with health checks
         * @param {Object} results - Analysis results from AdvValidation.analyze()
         * @param {Array} predictions - Raw predictions array
         * @returns {string} HTML string
         */
        /**
         * Check model health and return alert HTML if underperforming
         * Triggers at sample size thresholds with escalating severity
         */
        function renderModelHealthAlert(results) {
            if (!results || !results.hasData) return '';
            
            const n = results.sampleSize || 0;
            const SAMPLE_MIN = 30; // Need 30+ picks before judging
            
            if (n < SAMPLE_MIN) return '';
            
            const issues = [];
            const winRate = results.winRate || 0;
            const roi = results.roi || 0;
            const brier = results.brierScore;
            const calibError = results.calibrationError;
            
            // Win rate checks (52.4% = breakeven at -110)
            if (winRate < 48 && n >= 50) {
                issues.push({ severity: 'critical', metric: 'Win Rate', value: `${winRate.toFixed(1)}%`, detail: `Well below 52.4% breakeven. Losing money on every bet over ${n} picks.` });
            } else if (winRate < 50 && n >= 40) {
                issues.push({ severity: 'critical', metric: 'Win Rate', value: `${winRate.toFixed(1)}%`, detail: `Below 50% after ${n} picks. Model is worse than a coin flip.` });
            } else if (winRate < 52.4 && n >= 30) {
                issues.push({ severity: 'warning', metric: 'Win Rate', value: `${winRate.toFixed(1)}%`, detail: `Below 52.4% breakeven after ${n} picks. Not yet profitable at -110 juice.` });
            }
            
            // ROI checks
            if (roi < -15 && n >= 50) {
                issues.push({ severity: 'critical', metric: 'ROI', value: `${roi.toFixed(1)}%`, detail: 'Significant losses. Consider pausing bets and reviewing model calibration.' });
            } else if (roi < -8 && n >= 40) {
                issues.push({ severity: 'warning', metric: 'ROI', value: `${roi.toFixed(1)}%`, detail: 'Negative return on investment. Model may need recalibration.' });
            }
            
            // Brier score checks (0.25 = random, lower = better)
            if (brier !== null && brier !== undefined) {
                if (brier > 0.26 && n >= 30) {
                    issues.push({ severity: 'critical', metric: 'Accuracy', value: brier.toFixed(4), detail: 'Worse than random guessing (0.25). Predictions are not providing value.' });
                } else if (brier > 0.245 && n >= 50) {
                    issues.push({ severity: 'warning', metric: 'Accuracy', value: brier.toFixed(4), detail: 'Near random levels (0.25). Model has minimal predictive edge.' });
                }
            }
            
            // Calibration error check
            if (calibError !== null && calibError !== undefined && calibError > 0.08 && n >= 40) {
                issues.push({ severity: 'warning', metric: 'Calibration', value: calibError.toFixed(4), detail: 'Predicted probabilities are significantly off from actual outcomes. Run fitParametersCV() to recalibrate.' });
            }
            
            if (issues.length === 0) return '';
            
            const hasCritical = issues.some(i => i.severity === 'critical');
            const severity = hasCritical ? 'critical' : 'warning';
            const icon = hasCritical ? '' : '';
            const title = hasCritical ? 'Model Needs Attention' : 'Performance Review Recommended';
            const borderColor = hasCritical ? '#e74c3c' : '#f39c12';
            const bgColor = hasCritical ? 'rgba(231, 76, 60, 0.08)' : 'rgba(243, 156, 18, 0.08)';
            
            let html = `
                <div class="adv-val-health-alert" style="
                    border: 2px solid ${borderColor};
                    background: ${bgColor};
                    border-radius: 10px;
                    padding: 1rem;
                    margin-bottom: 1rem;
                ">
                    <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                        <span style="font-size:1.2rem;">${icon}</span>
                        <strong style="font-size:0.95rem;color:${borderColor};">${title}</strong>
                        <span style="font-size:0.7rem;color:var(--text-muted);margin-left:auto;">${n} picks analyzed</span>
                    </div>
                    <div style="display:flex;flex-direction:column;gap:0.5rem;">
            `;
            
            issues.forEach(issue => {
                const dotColor = issue.severity === 'critical' ? '#e74c3c' : '#f39c12';
                html += `
                    <div style="display:flex;align-items:flex-start;gap:0.5rem;font-size:0.8rem;">
                        <span style="color:${dotColor};font-weight:800;min-width:80px;">${issue.metric}: ${issue.value}</span>
                        <span style="color:var(--text-secondary);">${issue.detail}</span>
                    </div>
                `;
            });
            
            html += `
                    </div>
                    <div style="margin-top:0.75rem;font-size:0.7rem;color:var(--text-muted);border-top:1px solid ${borderColor}33;padding-top:0.5rem;">
                        ${hasCritical 
                            ? 'Consider pausing live bets. Run <code style="background:var(--bg-input);padding:0 4px;border-radius:3px;">SpreadSheetV3Enhanced.fitParametersCV(state.historicalGames)</code> in console to recalibrate.' 
                            : 'Keep tracking  variance is normal in small samples. Alert escalates to critical if trends continue.'}
                    </div>
                </div>
            `;
            
            return html;
        }

        function renderDataIntegrityNotice(results, predictions) {
            // Calculate integrity checks
            const checks = [];
            let warningCount = 0;
            let concernCount = 0;

            // 1. Sample size check
            const sampleSize = results.sampleSize || 0;
            if (sampleSize >= 50) {
                checks.push({ icon: 'pass', label: 'Sample Size', value: `n=${sampleSize}`, status: 'pass' });
            } else if (sampleSize >= 20) {
                checks.push({ icon: 'warn', label: 'Sample Size', value: `n=${sampleSize}`, status: 'warn' });
                warningCount++;
            } else {
                checks.push({ icon: 'fail', label: 'Sample Size', value: `n=${sampleSize}`, status: 'fail' });
                concernCount++;
            }

            // 2. Calibration error check
            const calError = results.calibrationError;
            if (calError !== null && calError !== undefined) {
                if (calError < 0.05) {
                    checks.push({ icon: 'pass', label: 'Calibration', value: calError.toFixed(3), status: 'pass' });
                } else if (calError < 0.1) {
                    checks.push({ icon: 'warn', label: 'Calibration', value: calError.toFixed(3), status: 'warn' });
                    warningCount++;
                } else {
                    checks.push({ icon: 'fail', label: 'Calibration', value: calError.toFixed(3), status: 'fail' });
                    concernCount++;
                }
            }

            // 3. Temporal stability check (leakage detection)
            if (results.temporalSplit) {
                const ts = results.temporalSplit;
                if (ts.potentialLeakage) {
                    checks.push({ icon: 'fail', label: 'Temporal Stability', value: 'Degraded', status: 'fail' });
                    concernCount++;
                } else if (Math.abs(ts.winRateDiff) > 10) {
                    checks.push({ icon: 'warn', label: 'Temporal Stability', value: 'Variable', status: 'warn' });
                    warningCount++;
                } else {
                    checks.push({ icon: 'pass', label: 'Temporal Stability', value: 'Stable', status: 'pass' });
                }
            }

            // 4. Skill score check
            const skill = results.brierSkillVsNaive;
            if (skill !== null && skill !== undefined) {
                if (skill > 10) {
                    checks.push({ icon: 'pass', label: 'Skill Score', value: `+${skill.toFixed(0)}%`, status: 'pass' });
                } else if (skill > 0) {
                    checks.push({ icon: 'warn', label: 'Skill Score', value: `+${skill.toFixed(0)}%`, status: 'warn' });
                    warningCount++;
                } else {
                    checks.push({ icon: 'fail', label: 'Skill Score', value: `${skill.toFixed(0)}%`, status: 'fail' });
                    concernCount++;
                }
            }

            // 5. Win rate significance check (is it above breakeven?)
            const winRate = results.winRate;
            const ciLower = results.winRateCI95?.[0];
            if (winRate !== null && ciLower !== null) {
                if (ciLower >= 52.4) {
                    checks.push({ icon: 'pass', label: 'Breakeven', value: 'Confident', status: 'pass' });
                } else if (winRate >= 52.4) {
                    checks.push({ icon: 'warn', label: 'Breakeven', value: 'Likely', status: 'warn' });
                    warningCount++;
                } else {
                    checks.push({ icon: 'fail', label: 'Breakeven', value: 'Unclear', status: 'fail' });
                    concernCount++;
                }
            }

            // Determine overall status
            let overallStatus, overallLabel;
            if (concernCount > 0) {
                overallStatus = 'concern';
                overallLabel = 'Review Needed';
            } else if (warningCount > 0) {
                overallStatus = 'warning';
                overallLabel = 'Monitoring';
            } else {
                overallStatus = 'healthy';
                overallLabel = 'Healthy';
            }

            return `
                <div class="data-integrity-notice">
                    <div class="data-integrity-header">
                        <span class="data-integrity-icon">${overallStatus === 'healthy' ? '' : overallStatus === 'warning' ? '' : ''}</span>
                        <span class="data-integrity-title">Data Integrity</span>
                        <span class="data-integrity-status ${overallStatus}">${overallLabel}</span>
                    </div>
                    <div class="data-integrity-checks">
                        ${checks.map(c => `
                            <div class="integrity-check">
                                <span class="integrity-check-icon ${c.icon}">${c.icon === 'pass' ? '' : c.icon === 'warn' ? '!' : ''}</span>
                                <span class="integrity-check-label">${c.label}</span>
                                <span class="integrity-check-value">${c.value}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Render advanced validation panel content
        function renderAdvValidation(predictions) {
            const panel = document.getElementById('advValidationPanel');
            const content = document.getElementById('advValidationResults');
            const sampleSizeEl = document.getElementById('advValidationSampleSize');

            if (!predictions || predictions.length === 0) {
                content.innerHTML = `
                    <div class="adv-val-awaiting">
                        <div class="adv-val-awaiting-icon"></div>
                        <div>No predictions to analyze</div>
                        <div style="font-size:0.75rem;margin-top:0.5rem;color:var(--text-secondary)">
                            Click "Refresh Data" to capture predictions
                        </div>
                    </div>
                `;
                sampleSizeEl.textContent = 'n=0';
                return;
            }

            // Run advanced validation analysis
            const results = AdvValidation.analyze(predictions);

            if (!results.hasData) {
                content.innerHTML = `
                    <div class="adv-val-awaiting">
                        <div class="adv-val-awaiting-icon"></div>
                        <div>${results.message}</div>
                        <div style="font-size:0.75rem;margin-top:0.5rem;color:var(--text-secondary)">
                            ${results.pendingCount || 0} picks pending results
                        </div>
                    </div>
                `;
                sampleSizeEl.textContent = `n=${results.gradedCount || 0}`;
                return;
            }

            // Mark as rendered
            panel.dataset.rendered = 'true';
            sampleSizeEl.textContent = `n=${results.sampleSize}`;

            // Format values for display
            const brier = AdvValidation.formatBrierScore(results.brierScore);
            const skillNaive = AdvValidation.formatSkillScore(results.brierSkillVsNaive);
            const skillHist = AdvValidation.formatSkillScore(results.brierSkillVsHistorical);

            // Build calibration chart SVG
            const calibrationSVG = renderCalibrationChart(results.calibration);

            // Build residuals chart
            const residualsHTML = renderResidualsChart(predictions);

            // Build model health alert (if underperforming at sufficient sample)
            const healthAlertHTML = renderModelHealthAlert(results);

            // Build data integrity notice
            const integrityHTML = renderDataIntegrityNotice(results, predictions);

            // Build temporal comparison
            const temporalHTML = results.temporalSplit ? renderTemporalComparison(results.temporalSplit) : '';

            content.innerHTML = `
                ${healthAlertHTML}
                ${integrityHTML}

                <div class="adv-val-grid">
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">Accuracy Score</div>
                        <div class="adv-val-card-value ${brier.class}">${brier.value}</div>
                        <div class="adv-val-card-subtitle">${brier.interpretation}  0=perfect, 0.25=random</div>
                    </div>
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">Edge Over 50/50</div>
                        <div class="adv-val-card-value ${skillNaive.class}">${skillNaive.value}</div>
                        <div class="adv-val-card-subtitle">How much better than coin flip</div>
                    </div>
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">Win Rate</div>
                        <div class="adv-val-card-value ${results.winRate >= 52.4 ? 'good' : results.winRate < 50 ? 'bad' : ''}">${results.winRate ? results.winRate.toFixed(1) + '%' : '--'}</div>
                        <div class="adv-val-card-subtitle ci-tooltip" title="95% Confidence Interval">
                            ${results.winRateCI95 ? `95% CI: ${results.winRateCI95[0].toFixed(1)}${results.winRateCI95[1].toFixed(1)}%` : '--'}
                        </div>
                    </div>
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">ROI</div>
                        <div class="adv-val-card-value ${results.roi > 0 ? 'good' : results.roi < 0 ? 'bad' : ''}">${results.roi !== null ? (results.roi > 0 ? '+' : '') + results.roi.toFixed(1) + '%' : '--'}</div>
                        <div class="adv-val-card-subtitle ci-tooltip" title="95% Confidence Interval">
                            ${results.roiCI95 ? `95% CI: ${results.roiCI95[0].toFixed(1)} to ${results.roiCI95[1].toFixed(1)}%` : '--'}
                        </div>
                    </div>
                </div>

                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Calibration Curve</div>
                    <div class="calibration-chart">
                        ${calibrationSVG}
                    </div>
                    <div style="font-size:0.7rem;color:var(--text-muted);margin-top:0.5rem;text-align:center;">
                        Calibration Error: ${results.calibrationError !== null ? results.calibrationError.toFixed(4) : '--'}
                        &nbsp;|&nbsp; Closer to diagonal = better calibrated
                    </div>
                </div>

                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Prediction Error Distribution</div>
                    <div class="residuals-chart">
                        ${residualsHTML}
                    </div>
                    <div style="font-size:0.7rem;color:var(--text-muted);margin-top:0.5rem;text-align:center;">
                        How far off each prediction was  Shaded band = normal range
                    </div>
                </div>

                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Model vs Baselines</div>
                    <div class="baseline-comparison">
                        <div class="baseline-card">
                            <div class="baseline-card-header">Your Model</div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Accuracy</span>
                                <span class="baseline-card-value">${results.brierScore?.toFixed(4) || '--'}</span>
                            </div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Win Rate</span>
                                <span class="baseline-card-value">${results.winRate?.toFixed(1) || '--'}%</span>
                            </div>
                        </div>
                        <div class="baseline-card">
                            <div class="baseline-card-header">Coin Flip</div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Accuracy</span>
                                <span class="baseline-card-value">${results.baseline?.naiveBrier?.toFixed(4) || '0.2500'}</span>
                            </div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Win Rate</span>
                                <span class="baseline-card-value">50.0%</span>
                            </div>
                        </div>
                        <div class="baseline-card">
                            <div class="baseline-card-header">Historical Avg</div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Accuracy</span>
                                <span class="baseline-card-value">${results.baseline?.historicalBrier?.toFixed(4) || '--'}</span>
                            </div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Win Rate</span>
                                <span class="baseline-card-value">${results.baseline?.historicalWinRate?.toFixed(1) || '--'}%</span>
                            </div>
                        </div>
                    </div>
                </div>

                ${temporalHTML}

                <div class="adv-val-note">
                    <span class="adv-val-note-icon"></span>
                    <div>
                        <strong>How to read this:</strong> Accuracy Score measures prediction quality (0=perfect, 0.25=random guessing).
                        The calibration curve shows whether predicted win percentages match actual outcomes  closer to the diagonal line = better calibrated.
                        Positive Edge Over 50/50 means the model is beating random chance.
                    </div>
                </div>
            `;
            
            // Update toggle button to show alert status
            const toggleEl = document.getElementById('advValidationToggle');
            if (toggleEl && results.sampleSize >= 30) {
                const winRate = results.winRate || 0;
                const roi = results.roi || 0;
                const bScore = results.brierScore;
                const hasCritical = (winRate < 50 && results.sampleSize >= 40) || (roi < -15 && results.sampleSize >= 50) || (bScore > 0.26);
                const hasWarning = (winRate < 52.4) || (roi < -8) || (bScore > 0.245);
                
                // Remove old badge if exists
                const oldBadge = toggleEl.querySelector('.adv-val-alert-badge');
                if (oldBadge) oldBadge.remove();
                
                if (hasCritical || hasWarning) {
                    const badge = document.createElement('span');
                    badge.className = 'adv-val-alert-badge';
                    badge.style.cssText = `font-size:0.65rem;font-weight:700;padding:2px 6px;border-radius:4px;margin-left:6px;color:white;background:${hasCritical ? '#e74c3c' : '#f39c12'};`;
                    badge.textContent = hasCritical ? 'REVIEW' : 'CHECK';
                    toggleEl.querySelector('.adv-validation-toggle-left').appendChild(badge);
                }
            }
        }

        // Render calibration chart SVG
        function renderCalibrationChart(calibration) {
            if (!calibration || calibration.length === 0) {
                return '<div style="text-align:center;color:var(--text-muted);padding:2rem;">Insufficient data for calibration chart</div>';
            }

            const width = 520;
            const height = 320;
            const padding = { top: 20, right: 20, bottom: 48, left: 60 };
            const chartW = width - padding.left - padding.right;
            const chartH = height - padding.top - padding.bottom;

            const toX = (v) => padding.left + v * chartW;
            const toY = (v) => padding.top + (1 - v) * chartH;

            let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Calibration curve chart">`;

            // Perfect calibration line (diagonal)
            svg += `<line class="calibration-line-perfect" x1="${toX(0.5)}" y1="${toY(0.5)}" x2="${toX(1)}" y2="${toY(1)}" />`;

            // Grid lines
            [0.5, 0.6, 0.7, 0.8, 0.9, 1.0].forEach(v => {
                svg += `<line x1="${toX(0.5)}" y1="${toY(v)}" x2="${toX(1)}" y2="${toY(v)}" stroke="var(--border-color)" stroke-width="0.5" opacity="0.5" />`;
                svg += `<line x1="${toX(v)}" y1="${toY(0.5)}" x2="${toX(v)}" y2="${toY(1)}" stroke="var(--border-color)" stroke-width="0.5" opacity="0.5" />`;
            });

            // Y-axis labels
            [0.5, 0.6, 0.7, 0.8, 0.9, 1.0].forEach(v => {
                svg += `<text x="${padding.left - 8}" y="${toY(v) + 4}" fill="var(--text-muted)" text-anchor="end" font-size="10" font-family="JetBrains Mono, monospace">${(v * 100).toFixed(0)}%</text>`;
            });

            // X-axis labels
            [0.5, 0.6, 0.7, 0.8, 0.9, 1.0].forEach(v => {
                svg += `<text x="${toX(v)}" y="${height - 24}" fill="var(--text-muted)" text-anchor="middle" font-size="10" font-family="JetBrains Mono, monospace">${(v * 100).toFixed(0)}%</text>`;
            });

            // Axis titles  pushed further out to avoid overlap
            const yAxisX = 14;
            const yAxisCenterY = toY(0.75);
            svg += `<text x="${yAxisX}" y="${yAxisCenterY}" fill="var(--text-secondary)" text-anchor="middle" font-size="11" font-weight="600" transform="rotate(-90, ${yAxisX}, ${yAxisCenterY})">Actual Win %</text>`;
            svg += `<text x="${toX(0.75)}" y="${height - 6}" fill="var(--text-secondary)" text-anchor="middle" font-size="11" font-weight="600">Predicted Win %</text>`;

            // Confidence intervals (shaded areas)
            calibration.forEach(bin => {
                const x = toX(bin.predicted);
                const yLower = toY(bin.ci95Lower);
                const yUpper = toY(bin.ci95Upper);
                const rectHeight = yLower - yUpper;
                svg += `<rect class="calibration-ci" x="${x - 12}" y="${yUpper}" width="24" height="${rectHeight}" rx="3" />`;
            });

            // Model calibration line
            if (calibration.length >= 2) {
                const pathPoints = calibration.map(bin => `${toX(bin.predicted)},${toY(bin.actual)}`);
                svg += `<polyline class="calibration-line-model" points="${pathPoints.join(' ')}" />`;
            }

            // Data points
            calibration.forEach(bin => {
                const x = toX(bin.predicted);
                const y = toY(bin.actual);
                const radius = Math.min(12, Math.max(5, Math.sqrt(bin.n) * 1.2));
                svg += `<circle class="calibration-dot" cx="${x}" cy="${y}" r="${radius}">
                    <title>${bin.range}: ${(bin.actual * 100).toFixed(1)}% actual (n=${bin.n})</title>
                </circle>`;
            });

            svg += '</svg>';
            return svg;
        }

        /**
         * Render residuals plot showing prediction errors over time
         * @param {Array} predictions - Array of graded predictions
         * @returns {string} HTML string with SVG chart
         */
        function renderResidualsChart(predictions) {
            // Filter to graded predictions with valid data
            const graded = predictions.filter(p =>
                p.status === 'graded' &&
                p.winProb !== undefined &&
                p.result !== undefined
            );

            if (graded.length < 5) {
                return '<div style="text-align:center;color:var(--text-muted);padding:2rem;">Need at least 5 graded predictions for residuals chart</div>';
            }

            // Calculate residuals: actual outcome (0 or 1) - predicted probability
            const residualsData = graded.map((p, index) => {
                const actual = p.result === 'win' ? 1 : 0;
                const predicted = p.winProb / 100;
                const residual = actual - predicted;
                return {
                    index,
                    date: new Date(p.gameDate),
                    residual,
                    predicted,
                    actual,
                    team: p.pickTeam || p.homeTeam || 'Unknown',
                    type: p.pickType
                };
            }).sort((a, b) => a.date - b.date);

            const width = 520;
            const height = 240;
            const padding = { top: 15, right: 20, bottom: 40, left: 55 };
            const chartW = width - padding.left - padding.right;
            const chartH = height - padding.top - padding.bottom;

            // Calculate stats
            const residuals = residualsData.map(d => d.residual);
            const meanResidual = residuals.reduce((a, b) => a + b, 0) / residuals.length;
            const stdDev = Math.sqrt(residuals.reduce((sum, r) => sum + Math.pow(r - meanResidual, 2), 0) / residuals.length);
            const positiveCount = residuals.filter(r => r > 0).length;
            const negativeCount = residuals.filter(r => r < 0).length;

            // X scale (index/time)
            const toX = (idx) => padding.left + (idx / (residualsData.length - 1)) * chartW;

            // Y scale (-0.5 to 0.5 range typically, but clamp to -1 to 1)
            const yMin = -0.6;
            const yMax = 0.6;
            const toY = (v) => padding.top + ((yMax - v) / (yMax - yMin)) * chartH;

            let svg = `<svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Prediction error distribution">`;

            // Background band (1 std dev)
            const bandTop = toY(Math.min(yMax, stdDev));
            const bandBottom = toY(Math.max(yMin, -stdDev));
            svg += `<rect class="residuals-band" x="${padding.left}" y="${bandTop}" width="${chartW}" height="${bandBottom - bandTop}" />`;

            // Grid lines
            [-0.4, -0.2, 0, 0.2, 0.4].forEach(v => {
                svg += `<line x1="${padding.left}" y1="${toY(v)}" x2="${padding.left + chartW}" y2="${toY(v)}" stroke="var(--border-color)" stroke-width="0.5" opacity="0.5" />`;
            });

            // Zero line (horizontal)
            svg += `<line class="residuals-zero-line" x1="${padding.left}" y1="${toY(0)}" x2="${padding.left + chartW}" y2="${toY(0)}" />`;

            // Y-axis labels
            [-0.4, -0.2, 0, 0.2, 0.4].forEach(v => {
                const label = v === 0 ? '0' : (v > 0 ? '+' : '') + (v * 100).toFixed(0) + '%';
                svg += `<text x="${padding.left - 8}" y="${toY(v) + 4}" fill="var(--text-muted)" text-anchor="end" font-size="10" font-family="JetBrains Mono, monospace">${label}</text>`;
            });

            // X-axis title
            svg += `<text x="${padding.left + chartW / 2}" y="${height - 8}" fill="var(--text-secondary)" text-anchor="middle" font-size="10" font-weight="600">Predictions Over Time </text>`;

            // Mean residual trend line
            if (residualsData.length > 1) {
                const y = toY(Math.max(yMin, Math.min(yMax, meanResidual)));
                svg += `<line class="residuals-trend" x1="${padding.left}" y1="${y}" x2="${padding.left + chartW}" y2="${y}" />`;
            }

            // Data points
            residualsData.forEach((d, i) => {
                const x = toX(i);
                const clampedResidual = Math.max(yMin, Math.min(yMax, d.residual));
                const y = toY(clampedResidual);
                const colorClass = d.residual > 0.05 ? 'positive' : d.residual < -0.05 ? 'negative' : '';
                const dateStr = d.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                svg += `<circle class="residuals-dot ${colorClass}" cx="${x}" cy="${y}" r="5">
                    <title>${dateStr}: ${d.team} (${d.type})
Predicted: ${(d.predicted * 100).toFixed(1)}%
Actual: ${d.actual === 1 ? 'Win' : 'Loss'}
Residual: ${d.residual > 0 ? '+' : ''}${(d.residual * 100).toFixed(1)}%</title>
                </circle>`;
            });

            svg += '</svg>';

            // Summary stats
            const summaryHTML = `
                <div class="residuals-summary">
                    <div class="residuals-summary-item">
                        <span class="residuals-summary-dot positive"></span>
                        <span>Under-confident: ${positiveCount}</span>
                    </div>
                    <div class="residuals-summary-item">
                        <span class="residuals-summary-dot negative"></span>
                        <span>Over-confident: ${negativeCount}</span>
                    </div>
                    <div class="residuals-summary-item">
                        <span class="residuals-summary-dot neutral"></span>
                        <span>Mean: ${meanResidual > 0 ? '+' : ''}${(meanResidual * 100).toFixed(2)}%</span>
                    </div>
                </div>
            `;

            return svg + summaryHTML;
        }

        // Render temporal comparison section
        function renderTemporalComparison(temporal) {
            if (!temporal) return '';

            const diffClass = temporal.winRateDiff > 5 ? 'better' : temporal.winRateDiff < -5 ? 'worse' : 'same';
            const brierDiffClass = temporal.brierDiff !== null && temporal.brierDiff < -0.01 ? 'better' : temporal.brierDiff > 0.01 ? 'worse' : 'same';

            return `
                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Early vs Recent Performance</div>
                    <div class="baseline-comparison">
                        <div class="baseline-card">
                            <div class="baseline-card-header">First Half (n=${temporal.firstHalf.n})</div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Win Rate</span>
                                <span class="baseline-card-value">${temporal.firstHalf.winRate.toFixed(1)}%</span>
                            </div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Brier</span>
                                <span class="baseline-card-value">${temporal.firstHalf.brier?.toFixed(4) || '--'}</span>
                            </div>
                        </div>
                        <div class="baseline-card">
                            <div class="baseline-card-header">Second Half (n=${temporal.secondHalf.n})</div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Win Rate</span>
                                <span class="baseline-card-value ${diffClass}">${temporal.secondHalf.winRate.toFixed(1)}%</span>
                            </div>
                            <div class="baseline-card-row">
                                <span class="baseline-card-label">Brier</span>
                                <span class="baseline-card-value ${brierDiffClass}">${temporal.secondHalf.brier?.toFixed(4) || '--'}</span>
                            </div>
                        </div>
                    </div>
                    ${temporal.potentialLeakage ? `
                        <div class="adv-val-note" style="margin-top:0.75rem;background:var(--accent-yellow-dim);border:1px solid var(--accent-yellow);">
                            <span class="adv-val-note-icon"></span>
                            <div><strong>Warning:</strong> Performance degraded significantly in second half. This may indicate overfitting or data leakage. Review model assumptions.</div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // ====== RECORD TAB FILTER STATE ======
        let activeRecordFilter = 'bestbets'; // bestbets | all | ball1-5
        const BALL_TIERS = [
            { key: 'ball5', balls: 5, min: 75, max: 100, label: '5-Ball Locks' },
            { key: 'ball4', balls: 4, min: 72, max: 74.99, label: '4-Ball Elite' },
            { key: 'ball3', balls: 3, min: 68, max: 71.99, label: '3-Ball Strong' },
            { key: 'ball2', balls: 2, min: 64, max: 67.99, label: '2-Ball Solid' },
            { key: 'ball1', balls: 1, min: 62, max: 63.99, label: '1-Ball Good' },
        ];

        function setRecordFilter(filter, btn) {
            activeRecordFilter = filter;
            document.querySelectorAll('.record-filter-btn').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
            renderPredictionTracker();
        }

        function applyRecordFilter(predictions) {
            if (activeRecordFilter === 'all') return predictions;
            if (activeRecordFilter === 'bestbets') {
                return predictions.filter(p => p.isBestBet || (p.winProb && p.winProb >= TIER_THRESHOLDS.BEST_BET));
            }
            const tier = BALL_TIERS.find(t => t.key === activeRecordFilter);
            if (tier) {
                return predictions.filter(p => p.winProb >= tier.min && p.winProb <= tier.max && (p.isBestBet || p.winProb >= TIER_THRESHOLDS.BEST_BET));
            }
            return predictions;
        }

        function getRecordFilterLabel() {
            if (activeRecordFilter === 'all') return ' All Bets';
            if (activeRecordFilter === 'bestbets') return ' Best Bets';
            const tier = BALL_TIERS.find(t => t.key === activeRecordFilter);
            if (tier) return `${''.repeat(tier.balls)} ${tier.label}`;
            return 'Best Bets';
        }

        // Render the prediction tracker UI
        async function renderPredictionTracker() {
            const allPredictions = await getAllPredictions();
            allPredictionsCache = allPredictions;
            
            // Sort by date descending
            allPredictions.sort((a, b) => new Date(b.gameDate) - new Date(a.gameDate));
            
            // Apply time frame filter
            const timePreds = filterByTimeFrame(allPredictions, selectedTimeFrame);
            
            // Apply record filter
            const filtered = applyRecordFilter(timePreds);
            const stats = calculatePredictionStats(filtered);
            const graded = filtered.filter(p => p.status === 'graded');
            
            // ====== HERO SECTION ======
            const timeLabel = selectedTimeFrame === 'all' ? 'All Time' : `Last ${selectedTimeFrame} Days`;
            const pending = filtered.filter(p => p.status === 'pending').length;
            
            const titleEl = document.getElementById('valHeroTitle');
            if (titleEl) titleEl.textContent = getRecordFilterLabel();
            
            const metaEl = document.getElementById('valHeroMeta');
            if (metaEl) metaEl.textContent = `${timeLabel}  ${stats.total} graded${pending > 0 ? `  ${pending} pending` : ''}`;
            
            const setHeroStat = (id, val, colorClass) => {
                const el = document.getElementById(id);
                if (!el) return;
                el.textContent = val;
                el.className = 'val-hero-stat-value' + (colorClass ? ' ' + colorClass : '');
            };
            
            setHeroStat('bbHeroRecord', `${stats.wins}-${stats.losses}`,
                stats.wins > stats.losses ? 'green' : stats.losses > stats.wins ? 'red' : '');
            setHeroStat('bbHeroWinRate', stats.total > 0 ? `${stats.winRate.toFixed(1)}%` : '--',
                stats.winRate >= 55 ? 'green' : stats.winRate < 50 && stats.total > 0 ? 'red' : '');
            setHeroStat('bbHeroROI', stats.total > 0 ? `${stats.roi > 0 ? '+' : ''}${stats.roi.toFixed(1)}%` : '--',
                stats.roi > 0 ? 'green' : stats.roi < 0 ? 'red' : '');
            setHeroStat('bbHeroUnits', stats.total > 0 ? `${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u` : '--',
                stats.units > 0 ? 'green' : stats.units < 0 ? 'red' : '');
            
            // Streak
            let streak = '--';
            if (graded.length > 0) {
                const sorted = [...graded].sort((a, b) => new Date(b.gameDate) - new Date(a.gameDate));
                let count = 0;
                const firstResult = sorted[0].result;
                for (const p of sorted) { if (p.result === firstResult) count++; else break; }
                streak = firstResult === 'win' ? `${count}W ` : `${count}L`;
            }
            setHeroStat('bbHeroStreak', streak, '');
            
            // Split line
            const fSpreads = filtered.filter(p => p.pickType === 'spread');
            const fTotals = filtered.filter(p => p.pickType === 'total');
            const sprStats = calculatePredictionStats(fSpreads);
            const totStats = calculatePredictionStats(fTotals);
            const splitEl = document.getElementById('bbHeroSplit');
            if (splitEl) splitEl.innerHTML = `
                <div class="val-hero-split-item">
                    <span class="val-hero-split-dot" style="background:var(--accent-blue)"></span>
                    Spreads: <strong>${sprStats.wins}-${sprStats.losses}</strong>
                    ${sprStats.total > 0 ? `(${sprStats.winRate.toFixed(0)}%)` : ''}
                </div>
                <div class="val-hero-split-item">
                    <span class="val-hero-split-dot" style="background:var(--accent-green)"></span>
                    Totals: <strong>${totStats.wins}-${totStats.losses}</strong>
                    ${totStats.total > 0 ? `(${totStats.winRate.toFixed(0)}%)` : ''}
                </div>
            `;
            
            // ====== TREND INDICATOR ======
            renderRecordTrend(graded);
            
            // ====== ROLLING WIN RATE CHART ======
            renderRollingWinRateChart(graded);
            
            // ====== BASKETBALL RATING GRID ======
            const ratingSection = document.getElementById('valRatingSection');
            if (ratingSection) {
                // Show rating grid for bestbets and all, hide for individual ball tiers
                ratingSection.style.display = activeRecordFilter.startsWith('ball') ? 'none' : 'block';
            }
            
            const bestBetsForRating = activeRecordFilter === 'all' 
                ? timePreds.filter(p => p.isBestBet || (p.winProb && p.winProb >= TIER_THRESHOLDS.BEST_BET))
                : filtered;
            const bbGradedForRating = bestBetsForRating.filter(p => p.status === 'graded');
            
            const ratingGrid = document.getElementById('valRatingGrid');
            if (ratingGrid && !activeRecordFilter.startsWith('ball')) {
                ratingGrid.innerHTML = BALL_TIERS.map(tier => {
                    const tierPicks = bbGradedForRating.filter(p => p.winProb >= tier.min && p.winProb <= tier.max);
                    const wins = tierPicks.filter(p => p.result === 'win').length;
                    const losses = tierPicks.filter(p => p.result === 'loss').length;
                    const total = wins + losses;
                    const winRate = total > 0 ? (wins / total * 100).toFixed(0) : '--';
                    const units = (wins * 0.91) - losses;
                    const hasData = total > 0;
                    
                    let ballsHTML = '';
                    for (let i = 1; i <= 5; i++) ballsHTML += basketballSVG(14, i <= tier.balls);
                    
                    return `
                        <div class="val-rating-card ${hasData ? 'has-data' : ''}">
                            <div class="val-rating-card-title">${tier.label.replace(/\d-Ball /, '')}</div>
                            <div class="val-rating-card-balls">${ballsHTML}</div>
                            <div class="val-rating-card-record ${wins > losses ? 'green' : losses > wins ? 'red' : ''}">${hasData ? `${wins}-${losses}` : '--'}</div>
                            <div class="val-rating-card-stats">
                                <div class="val-rating-card-stat">
                                    <div class="val-rating-card-stat-value ${parseFloat(winRate) >= 52.4 ? 'green' : parseFloat(winRate) < 50 && hasData ? 'red' : ''}">${winRate}${hasData ? '%' : ''}</div>
                                    <div class="val-rating-card-stat-label">Win%</div>
                                </div>
                                <div class="val-rating-card-stat">
                                    <div class="val-rating-card-stat-value ${hasData && units >= 0 ? 'green' : hasData ? 'red' : ''}">${hasData ? (units >= 0 ? '+' : '') + units.toFixed(1) + 'u' : '--'}</div>
                                    <div class="val-rating-card-stat-label">Units</div>
                                </div>
                            </div>
                            <div class="val-rating-card-range">${tier.min}${tier.max >= 100 ? '100' : tier.max.toFixed(0)}%</div>
                        </div>
                    `;
                }).join('');
            }
            
            // ====== ROI / CUMULATIVE CHART ======
            renderPerformanceChart(filtered);
            
            // ====== TYPE BREAKDOWN ======
            renderTypeBreakdown(filtered);
            
            // ====== PICKS LIST ======
            renderTrackerPicksList(filtered);
            
            // ====== POPULATE PERFORMANCE STATS BAR ======
            const gradedPicks = allPredictions.filter(p => p.status === 'graded');
            const nGraded = gradedPicks.length;
            const winsAll = gradedPicks.filter(p => p.result === 'win').length;
            const lossesAll = nGraded - winsAll;
            
            const recEl = document.getElementById('metricRecordValue');
            const wrEl = document.getElementById('metricWinRateValue');
            const roiEl = document.getElementById('metricROIValue');
            const nEl = document.getElementById('metricSampleSizeValue');
            const updEl = document.getElementById('metricLastUpdateValue');
            
            if (recEl) recEl.textContent = nGraded > 0 ? `${winsAll}-${lossesAll}` : '--';
            if (wrEl) wrEl.textContent = nGraded > 0 ? `${((winsAll / nGraded) * 100).toFixed(1)}%` : '--';
            if (roiEl) {
                if (nGraded > 0) {
                    const unitsWon = (winsAll * 0.91) - lossesAll;
                    const roiPct = ((unitsWon / nGraded) * 100).toFixed(1);
                    roiEl.textContent = `${roiPct > 0 ? '+' : ''}${roiPct}%`;
                    roiEl.style.color = roiPct >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                } else {
                    roiEl.textContent = '--';
                }
            }
            if (nEl) nEl.textContent = nGraded > 0 ? nGraded : '--';
            if (updEl) {
                const lastGraded = gradedPicks.sort((a, b) => new Date(b.resolvedAt || b.gameDate) - new Date(a.resolvedAt || a.gameDate))[0];
                if (lastGraded) {
                    const d = new Date(lastGraded.resolvedAt || lastGraded.gameDate);
                    updEl.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                } else { updEl.textContent = '--'; }
            }
            const previewEl = document.getElementById('metricsBarPreview');
            if (previewEl && nGraded > 0) {
                const wrPct = ((winsAll / nGraded) * 100).toFixed(1);
                previewEl.textContent = `${winsAll}-${lossesAll}  ${wrPct}%`;
            }
        }

        // ====== TREND INDICATOR ======
        function renderRecordTrend(graded) {
            const trendEl = document.getElementById('valHeroTrend');
            if (!trendEl || graded.length < 5) { if (trendEl) trendEl.innerHTML = ''; return; }
            
            const sorted = [...graded].sort((a, b) => new Date(a.gameDate) - new Date(b.gameDate));
            const recent = sorted.slice(-10);
            const older = sorted.slice(-20, -10);
            
            if (older.length < 3) { trendEl.innerHTML = ''; return; }
            
            const recentWR = recent.filter(p => p.result === 'win').length / recent.length * 100;
            const olderWR = older.filter(p => p.result === 'win').length / older.length * 100;
            const diff = recentWR - olderWR;
            
            let chipClass = 'flat', arrow = '', label = 'Steady';
            if (diff > 5) { chipClass = 'up'; arrow = ''; label = 'Improving'; }
            else if (diff < -5) { chipClass = 'down'; arrow = ''; label = 'Declining'; }
            
            // Last 5 picks mini-record
            const last5 = sorted.slice(-5);
            const l5w = last5.filter(p => p.result === 'win').length;
            const l5l = last5.length - l5w;
            const l5Dots = last5.map(p => p.result === 'win' 
                ? '<span style="color:var(--accent-green);font-weight:700;">W</span>' 
                : '<span style="color:var(--accent-red);font-weight:700;">L</span>').join(' ');
            
            trendEl.innerHTML = `
                <span class="trend-chip ${chipClass}">${arrow} ${label}</span>
                <span style="font-size:0.7rem;">Last 10: <strong>${recentWR.toFixed(0)}%</strong></span>
                <span style="font-size:0.7rem;">Last 5: ${l5Dots}</span>
            `;
        }

        // ====== ROLLING WIN RATE CHART ======
        function renderRollingWinRateChart(graded) {
            const container = document.getElementById('rollingWinRateChart');
            if (!container) return;
            
            if (graded.length < 5) {
                container.innerHTML = '<div class="chart-placeholder">Need at least 5 graded picks for trend chart</div>';
                return;
            }
            
            const sorted = [...graded].sort((a, b) => new Date(a.gameDate) - new Date(b.gameDate));
            const windowSize = Math.min(7, Math.max(3, Math.floor(sorted.length / 3)));
            
            // Calculate rolling win rate
            const points = [];
            for (let i = windowSize - 1; i < sorted.length; i++) {
                const window = sorted.slice(i - windowSize + 1, i + 1);
                const wins = window.filter(p => p.result === 'win').length;
                const wr = (wins / window.length) * 100;
                const dateStr = new Date(sorted[i].gameDate).toISOString().split('T')[0];
                points.push({ x: i, wr, date: dateStr, wins, total: window.length });
            }
            
            if (points.length < 2) {
                container.innerHTML = '<div class="chart-placeholder">Need more data for trend chart</div>';
                return;
            }
            
            const width = 900, height = 220;
            const pad = { top: 25, right: 20, bottom: 40, left: 50 };
            const cw = width - pad.left - pad.right;
            const ch = height - pad.top - pad.bottom;
            
            const minWR = Math.max(0, Math.min(...points.map(p => p.wr)) - 10);
            const maxWR = Math.min(100, Math.max(...points.map(p => p.wr)) + 10);
            const range = maxWR - minWR || 1;
            
            const xScale = (i) => pad.left + ((i - points[0].x) / (points[points.length-1].x - points[0].x || 1)) * cw;
            const yScale = (wr) => pad.top + ch - ((wr - minWR) / range) * ch;
            
            // Build path
            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'}${xScale(p.x).toFixed(1)},${yScale(p.wr).toFixed(1)}`).join(' ');
            
            // Gradient fill area
            const areaD = pathD + ` L${xScale(points[points.length-1].x).toFixed(1)},${pad.top + ch} L${xScale(points[0].x).toFixed(1)},${pad.top + ch} Z`;
            
            // Determine trend color
            const firstHalf = points.slice(0, Math.floor(points.length / 2));
            const secondHalf = points.slice(Math.floor(points.length / 2));
            const avgFirst = firstHalf.reduce((s, p) => s + p.wr, 0) / firstHalf.length;
            const avgSecond = secondHalf.reduce((s, p) => s + p.wr, 0) / secondHalf.length;
            const trendUp = avgSecond > avgFirst;
            const lineColor = trendUp ? 'var(--accent-green)' : 'var(--accent-red)';
            const fillOpacity = 0.1;
            
            let svg = `<svg class="chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;
            svg += `<defs><linearGradient id="rollingFill" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="${lineColor}" stop-opacity="${fillOpacity}"/><stop offset="100%" stop-color="${lineColor}" stop-opacity="0"/></linearGradient></defs>`;
            
            // 52.4% breakeven line
            if (52.4 >= minWR && 52.4 <= maxWR) {
                const beY = yScale(52.4);
                svg += `<line x1="${pad.left}" y1="${beY}" x2="${width - pad.right}" y2="${beY}" stroke="var(--text-muted)" stroke-width="1" stroke-dasharray="6,4" opacity="0.5"/>`;
                svg += `<text x="${pad.left - 8}" y="${beY + 4}" fill="var(--text-muted)" text-anchor="end" font-size="10" font-family="JetBrains Mono, monospace">52.4%</text>`;
            }
            
            // 50% line
            if (50 >= minWR && 50 <= maxWR) {
                const y50 = yScale(50);
                svg += `<line x1="${pad.left}" y1="${y50}" x2="${width - pad.right}" y2="${y50}" stroke="var(--accent-red)" stroke-width="0.5" stroke-dasharray="3,3" opacity="0.3"/>`;
            }
            
            // Y-axis labels
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
                const val = minWR + (range * i / yTicks);
                const y = yScale(val);
                svg += `<line x1="${pad.left}" y1="${y}" x2="${width - pad.right}" y2="${y}" stroke="var(--border-color)" stroke-width="0.5" opacity="0.3"/>`;
                svg += `<text x="${pad.left - 8}" y="${y + 4}" fill="var(--text-muted)" text-anchor="end" font-size="10" font-family="JetBrains Mono, monospace">${val.toFixed(0)}%</text>`;
            }
            
            // Area fill
            svg += `<path d="${areaD}" fill="url(#rollingFill)"/>`;
            
            // Line
            svg += `<path d="${pathD}" fill="none" stroke="${lineColor}" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>`;
            
            // Dots for key points (first, last, min, max)
            const lastPt = points[points.length - 1];
            svg += `<circle cx="${xScale(lastPt.x)}" cy="${yScale(lastPt.wr)}" r="4" fill="${lineColor}" stroke="var(--bg-card)" stroke-width="2"/>`;
            svg += `<text x="${xScale(lastPt.x)}" y="${yScale(lastPt.wr) - 10}" fill="${lineColor}" text-anchor="middle" font-size="11" font-weight="700" font-family="JetBrains Mono, monospace">${lastPt.wr.toFixed(0)}%</text>`;
            
            // X-axis date labels (show ~6)
            const step = Math.max(1, Math.floor(points.length / 6));
            for (let i = 0; i < points.length; i += step) {
                const p = points[i];
                const label = formatShortDate(p.date);
                svg += `<text x="${xScale(p.x)}" y="${height - 10}" fill="var(--text-muted)" text-anchor="middle" font-size="10" font-family="JetBrains Mono, monospace">${label}</text>`;
            }
            // Always show last date
            if (points.length > 1) {
                const lp = points[points.length - 1];
                svg += `<text x="${xScale(lp.x)}" y="${height - 10}" fill="var(--text-muted)" text-anchor="middle" font-size="10" font-family="JetBrains Mono, monospace">${formatShortDate(lp.date)}</text>`;
            }
            
            svg += '</svg>';
            
            // Legend
            const currentWR = lastPt.wr;
            const subtitle = document.getElementById('rollingChartSubtitle');
            if (subtitle) subtitle.textContent = `${windowSize}-pick rolling average  Current: ${currentWR.toFixed(1)}%`;
            
            container.innerHTML = svg + `
                <div class="chart-legend">
                    <div class="chart-legend-item"><span class="chart-legend-dot" style="background:${lineColor}"></span>${trendUp ? 'Trending Up' : 'Trending Down'}</div>
                    <div class="chart-legend-item"><span class="chart-legend-dot" style="background:var(--text-muted);opacity:0.5"></span>52.4% breakeven</div>
                    <div class="chart-legend-item"><strong>${graded.length} picks analyzed</strong></div>
                </div>
            `;
        }

        // ====== TYPE BREAKDOWN ======
        function renderTypeBreakdown(filtered) {
            const el = document.getElementById('recordTypeBreakdown');
            if (!el) return;
            
            const spreads = filtered.filter(p => p.pickType === 'spread');
            const totals = filtered.filter(p => p.pickType === 'total');
            const sprStats = calculatePredictionStats(spreads);
            const totStats = calculatePredictionStats(totals);
            
            const renderCard = (label, icon, stats, color) => {
                const wr = stats.total > 0 ? stats.winRate.toFixed(1) : 0;
                const barPct = stats.total > 0 ? Math.max(5, stats.winRate) : 0;
                const barColor = stats.winRate >= 52.4 ? 'var(--accent-green)' : stats.winRate > 0 ? 'var(--accent-red)' : 'var(--text-muted)';
                return `
                    <div class="record-type-card">
                        <div class="record-type-label">${icon} ${label}</div>
                        <div class="record-type-record ${stats.wins > stats.losses ? 'green' : stats.losses > stats.wins ? 'red' : ''}">${stats.total > 0 ? `${stats.wins}-${stats.losses}` : 'No data'}</div>
                        <div class="record-type-meta">${stats.total > 0 ? `${wr}%  ${stats.units >= 0 ? '+' : ''}${stats.units.toFixed(1)}u  ${stats.roi >= 0 ? '+' : ''}${stats.roi.toFixed(1)}% ROI` : 'No graded picks'}</div>
                        <div class="record-type-bar"><div class="record-type-bar-fill" style="width:${barPct}%;background:${barColor}"></div></div>
                    </div>
                `;
            };
            
            el.innerHTML = renderCard('Spreads', '', sprStats, 'var(--accent-blue)')
                         + renderCard('Totals', '', totStats, 'var(--accent-green)');
        }

        // ====== MODEL DIAGNOSTICS MODAL ======
        function showModelDiagnosticsModal() {
            const existing = document.getElementById('diagnosticsModal');
            if (existing) existing.remove();
            
            const modal = document.createElement('div');
            modal.id = 'diagnosticsModal';
            modal.className = 'glossary-modal-overlay';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.innerHTML = `
                <div class="glossary-modal" style="max-width:800px;">
                    <div class="glossary-modal-header">
                        <h2 class="glossary-modal-title"> Model Diagnostics</h2>
                        <button class="glossary-modal-close" onclick="document.getElementById('diagnosticsModal').remove()"></button>
                    </div>
                    <div class="glossary-modal-body" id="diagnosticsModalBody" style="max-height:80vh;overflow-y:auto;padding:1rem;">
                        <div class="adv-val-awaiting">
                            <div class="adv-val-awaiting-icon"></div>
                            <div>Loading diagnostics...</div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            // Render diagnostics content
            setTimeout(async () => {
                const predictions = allPredictionsCache || await getAllPredictions();
                renderDiagnosticsContent(predictions);
            }, 100);
        }

        function renderDiagnosticsContent(predictions) {
            const body = document.getElementById('diagnosticsModalBody');
            if (!body) return;
            
            if (!predictions || predictions.length === 0) {
                body.innerHTML = `<div class="adv-val-awaiting"><div class="adv-val-awaiting-icon"></div><div>No predictions to analyze. Click "Refresh Data" first.</div></div>`;
                return;
            }
            
            if (typeof AdvValidation === 'undefined' || !AdvValidation.analyze) {
                body.innerHTML = `<div class="adv-val-awaiting"><div class="adv-val-awaiting-icon"></div><div>Advanced validation module not loaded.</div></div>`;
                return;
            }
            
            const results = AdvValidation.analyze(predictions);
            
            if (!results.hasData) {
                body.innerHTML = `<div class="adv-val-awaiting"><div class="adv-val-awaiting-icon"></div><div>${results.message}</div><div style="font-size:0.75rem;margin-top:0.5rem;color:var(--text-secondary);">${results.pendingCount || 0} picks pending results</div></div>`;
                return;
            }
            
            const brier = AdvValidation.formatBrierScore(results.brierScore);
            const skillNaive = AdvValidation.formatSkillScore(results.brierSkillVsNaive);
            const calibrationSVG = renderCalibrationChart(results.calibration);
            const residualsHTML = renderResidualsChart(predictions);
            const healthAlertHTML = renderModelHealthAlert(results);
            const integrityHTML = renderDataIntegrityNotice(results, predictions);
            const temporalHTML = results.temporalSplit ? renderTemporalComparison(results.temporalSplit) : '';
            
            body.innerHTML = `
                ${healthAlertHTML}
                ${integrityHTML}
                <div class="adv-val-grid">
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">Accuracy Score</div>
                        <div class="adv-val-card-value ${brier.class}">${brier.value}</div>
                        <div class="adv-val-card-subtitle">${brier.interpretation}  0=perfect, 0.25=random</div>
                    </div>
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">Edge Over 50/50</div>
                        <div class="adv-val-card-value ${skillNaive.class}">${skillNaive.value}</div>
                        <div class="adv-val-card-subtitle">How much better than coin flip</div>
                    </div>
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">Win Rate</div>
                        <div class="adv-val-card-value ${results.winRate >= 52.4 ? 'good' : results.winRate < 50 ? 'bad' : ''}">${results.winRate ? results.winRate.toFixed(1) + '%' : '--'}</div>
                        <div class="adv-val-card-subtitle">${results.winRateCI95 ? `95% CI: ${results.winRateCI95[0].toFixed(1)}${results.winRateCI95[1].toFixed(1)}%` : '--'}</div>
                    </div>
                    <div class="adv-val-card">
                        <div class="adv-val-card-title">ROI</div>
                        <div class="adv-val-card-value ${results.roi > 0 ? 'good' : results.roi < 0 ? 'bad' : ''}">${results.roi !== null ? (results.roi > 0 ? '+' : '') + results.roi.toFixed(1) + '%' : '--'}</div>
                        <div class="adv-val-card-subtitle">${results.roiCI95 ? `95% CI: ${results.roiCI95[0].toFixed(1)} to ${results.roiCI95[1].toFixed(1)}%` : '--'}</div>
                    </div>
                </div>
                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Calibration Curve</div>
                    <div class="calibration-chart">${calibrationSVG}</div>
                    <div style="font-size:0.7rem;color:var(--text-muted);margin-top:0.5rem;text-align:center;">
                        Calibration Error: ${results.calibrationError !== null ? results.calibrationError.toFixed(4) : '--'}  Closer to diagonal = better
                    </div>
                </div>
                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Prediction Error Distribution</div>
                    <div class="residuals-chart">${residualsHTML}</div>
                    <div style="font-size:0.7rem;color:var(--text-muted);margin-top:0.5rem;text-align:center;">
                        How far off each prediction was  Shaded band = normal range
                    </div>
                </div>
                <div class="adv-val-section">
                    <div class="adv-val-section-title"> Model vs Baselines</div>
                    <div class="baseline-comparison">
                        <div class="baseline-card">
                            <div class="baseline-card-header">Your Model</div>
                            <div class="baseline-card-row"><span class="baseline-card-label">Accuracy</span><span class="baseline-card-value">${results.brierScore?.toFixed(4) || '--'}</span></div>
                            <div class="baseline-card-row"><span class="baseline-card-label">Win Rate</span><span class="baseline-card-value">${results.winRate?.toFixed(1) || '--'}%</span></div>
                        </div>
                        <div class="baseline-card">
                            <div class="baseline-card-header">Coin Flip</div>
                            <div class="baseline-card-row"><span class="baseline-card-label">Accuracy</span><span class="baseline-card-value">${results.baseline?.naiveBrier?.toFixed(4) || '0.2500'}</span></div>
                            <div class="baseline-card-row"><span class="baseline-card-label">Win Rate</span><span class="baseline-card-value">50.0%</span></div>
                        </div>
                        <div class="baseline-card">
                            <div class="baseline-card-header">Historical Avg</div>
                            <div class="baseline-card-row"><span class="baseline-card-label">Accuracy</span><span class="baseline-card-value">${results.baseline?.historicalBrier?.toFixed(4) || '--'}</span></div>
                            <div class="baseline-card-row"><span class="baseline-card-label">Win Rate</span><span class="baseline-card-value">${results.baseline?.historicalWinRate?.toFixed(1) || '--'}%</span></div>
                        </div>
                    </div>
                </div>
                ${temporalHTML}
                <div class="adv-val-note" style="margin-top:1rem;">
                    <span class="adv-val-note-icon"></span>
                    <div><strong>How to read this:</strong> Accuracy Score measures prediction quality (0=perfect, 0.25=random). The calibration curve shows whether predicted percentages match actual outcomes. Positive Edge Over 50/50 means the model beats random chance.</div>
                </div>
            `;
        }
        function renderTrendBanner(predictions) {
            const banner = document.getElementById('trendBanner');
            const trends = calculateTrends(predictions);
            
            banner.className = `trend-banner ${trends.trend}`;
            
            let icon = '';
            let text = 'Tracking model performance...';
            
            if (trends.trend === 'hot') {
                icon = '';
                text = `Model is HOT! ${trends.last5WinRate?.toFixed(0) || 0}% win rate last 5 picks`;
            } else if (trends.trend === 'cold') {
                icon = '';
                text = `Model is COLD. ${trends.last5WinRate?.toFixed(0) || 0}% win rate last 5 picks`;
            } else if (predictions.filter(p => p.status === 'graded').length >= 5) {
                icon = '';
                text = `Model performing steady at ${trends.last5WinRate?.toFixed(0) || 0}% last 5 picks`;
            }
            
            document.getElementById('trendIndicator').innerHTML = `
                <span class="trend-icon">${icon}</span>
                <span class="trend-text" id="trendText">${text}</span>
            `;
            
            document.getElementById('last5Record').textContent = trends.last5;
            document.getElementById('last5Record').className = trends.last5 !== '--' && parseInt(trends.last5) > parseInt(trends.last5.split('-')[1]) ? 'green' : '';
            
            document.getElementById('last10Record').textContent = trends.last10;
            document.getElementById('last10Record').className = trends.last10 !== '--' && parseInt(trends.last10) > parseInt(trends.last10.split('-')[1]) ? 'green' : '';
            
            const streakColor = trends.streakType === 'W' ? 'green' : trends.streakType === 'L' ? 'red' : '';
            document.getElementById('currentStreak').textContent = trends.streak > 0 ? `${trends.streak}${trends.streakType}` : '--';
            document.getElementById('currentStreak').className = streakColor;
        }
        
        function renderBreakdownTrend(elementId, predictions) {
            const el = document.getElementById(elementId);
            const trends = calculateTrends(predictions);
            
            if (predictions.filter(p => p.status === 'graded').length < 3) {
                el.innerHTML = '';
                return;
            }
            
            let icon = '';
            let text = 'Steady';
            let className = 'breakdown-trend';
            
            if (trends.trend === 'hot') {
                icon = '';
                text = `Hot streak! ${trends.last5}`;
                className = 'breakdown-trend hot';
            } else if (trends.trend === 'cold') {
                icon = '';
                text = `Cold streak: ${trends.last5}`;
                className = 'breakdown-trend cold';
            } else {
                text = `Last 5: ${trends.last5}`;
            }
            
            el.className = className;
            el.innerHTML = `<span class="breakdown-trend-icon">${icon}</span><span class="breakdown-trend-text">${text}</span>`;
        }
        
        function renderTierTrendBar(elementId, predictions) {
            const el = document.getElementById(elementId);
            const graded = predictions.filter(p => p.status === 'graded');
            const pending = predictions.filter(p => p.status === 'pending');
            const total = graded.length + pending.length;
            
            if (total === 0) {
                el.innerHTML = '';
                return;
            }
            
            const wins = graded.filter(p => p.result === 'win').length;
            const losses = graded.filter(p => p.result === 'loss').length;
            
            const winPct = total > 0 ? (wins / total) * 100 : 0;
            const lossPct = total > 0 ? (losses / total) * 100 : 0;
            const pendingPct = total > 0 ? (pending.length / total) * 100 : 0;
            
            el.innerHTML = `
                <div class="tier-trend-segment win" style="width:${winPct}%" title="${wins} wins"></div>
                <div class="tier-trend-segment loss" style="width:${lossPct}%" title="${losses} losses"></div>
                <div class="tier-trend-segment pending" style="width:${pendingPct}%" title="${pending.length} pending"></div>
            `;
        }
        
        function renderPerformanceChart(predictions) {
            const container = document.getElementById('performanceChart');
            const graded = predictions.filter(p => p.status === 'graded')
                .sort((a, b) => new Date(a.gameDate) - new Date(b.gameDate));
            
            if (graded.length < 2) {
                container.innerHTML = '<div class="chart-placeholder">Need at least 2 graded picks to show charts</div>';
                return;
            }
            
            // Group by day
            const byDay = {};
            graded.forEach(p => {
                const day = new Date(p.gameDate).toISOString().split('T')[0];
                if (!byDay[day]) byDay[day] = [];
                byDay[day].push(p);
            });
            
            const days = Object.keys(byDay).sort();
            
            // Use wider viewBox for better resolution
            const width = 900;
            const height = 240;
            const padding = { top: 30, right: 20, bottom: 45, left: 55 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            if (currentChartType === 'roi') {
                renderROIChart(container, byDay, days, width, height, padding, chartWidth, chartHeight);
            } else if (currentChartType === 'cumulative') {
                renderCumulativeChart(container, graded, width, height, padding, chartWidth, chartHeight);
            } else {
                renderTierChart(container, graded, width, height, padding, chartWidth, chartHeight);
            }
        }
        
        // Helper function for short date format
        function formatShortDate(dateStr) {
            const d = new Date(dateStr + 'T12:00:00');
            return `${d.getMonth() + 1}/${d.getDate()}`;
        }
        
        function renderROIChart(container, byDay, days, width, height, padding, chartWidth, chartHeight) {
            // Calculate daily ROI
            const dailyData = days.map(day => {
                const picks = byDay[day];
                const wins = picks.filter(p => p.result === 'win').length;
                const losses = picks.filter(p => p.result === 'loss').length;
                const total = wins + losses;
                const roi = total > 0 ? ((wins * 0.91 - losses) / total) * 100 : 0;
                return { day, wins, losses, roi, total };
            });
            
            const maxROI = Math.max(60, Math.max(...dailyData.map(d => Math.abs(d.roi))));
            const minROI = -maxROI;
            
            // Calculate bar dimensions - bars take 70% of slot width
            const slotWidth = chartWidth / days.length;
            const barWidth = Math.max(20, slotWidth * 0.7);
            
            let svg = `<svg class="chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;
            
            // Zero line
            const zeroY = padding.top + chartHeight / 2;
            svg += `<line x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" stroke="var(--border-color)" stroke-width="1.5"/>`;
            
            // Grid lines and Y-axis labels
            [50, 25, -25, -50].forEach(val => {
                if (Math.abs(val) <= maxROI) {
                    const y = padding.top + chartHeight - ((val - minROI) / (maxROI - minROI)) * chartHeight;
                    svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="var(--border-color)" stroke-width="0.5" stroke-dasharray="4,4" opacity="0.5"/>`;
                    svg += `<text x="${padding.left - 10}" y="${y + 4}" fill="var(--text-muted)" text-anchor="end" font-size="12" font-family="JetBrains Mono, monospace">${val > 0 ? '+' : ''}${val}%</text>`;
                }
            });
            // Zero label
            svg += `<text x="${padding.left - 10}" y="${zeroY + 4}" fill="var(--text-muted)" text-anchor="end" font-size="12" font-family="JetBrains Mono, monospace">0%</text>`;
            
            // Bars and labels
            dailyData.forEach((d, i) => {
                const x = padding.left + (i * slotWidth) + (slotWidth - barWidth) / 2;
                const barHeight = Math.abs(d.roi) / (maxROI - minROI) * chartHeight;
                const y = d.roi >= 0 ? zeroY - barHeight : zeroY;
                const color = d.roi >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                
                // Bar
                svg += `<rect x="${x}" y="${y}" width="${barWidth}" height="${Math.max(4, barHeight)}" fill="${color}" rx="4"/>`;
                
                // X-axis label - show all dates with short format
                const label = formatShortDate(d.day);
                svg += `<text x="${x + barWidth / 2}" y="${height - 12}" fill="var(--text-muted)" text-anchor="middle" font-size="11" font-family="JetBrains Mono, monospace">${label}</text>`;
            });
            
            svg += '</svg>';
            
            // Calculate summary stats
            const avgROI = dailyData.length > 0 ? dailyData.reduce((s, d) => s + d.roi, 0) / dailyData.length : 0;
            const positiveDays = dailyData.filter(d => d.roi > 0).length;
            const negativeDays = dailyData.filter(d => d.roi < 0).length;
            
            container.innerHTML = svg + `
                <div class="chart-legend">
                    <div class="chart-legend-item"><span class="chart-legend-dot" style="background:var(--accent-green)"></span>${positiveDays} Winning days</div>
                    <div class="chart-legend-item"><span class="chart-legend-dot" style="background:var(--accent-red)"></span>${negativeDays} Losing days</div>
                    <div class="chart-legend-item"><strong>Avg: ${avgROI >= 0 ? '+' : ''}${avgROI.toFixed(1)}% ROI/day</strong></div>
                </div>
            `;
        }
        
        function renderCumulativeChart(container, graded, width, height, padding, chartWidth, chartHeight) {
            // Calculate cumulative units
            let cumulative = 0;
            const data = graded.map((p, idx) => {
                cumulative += p.result === 'win' ? 0.91 : p.result === 'loss' ? -1 : 0;
                return { date: p.gameDate, units: cumulative, result: p.result, index: idx };
            });
            
            const maxUnits = Math.max(5, Math.max(...data.map(d => d.units)) + 1);
            const minUnits = Math.min(-5, Math.min(...data.map(d => d.units)) - 1);
            const range = maxUnits - minUnits;
            
            const getX = (i) => padding.left + (i / Math.max(1, data.length - 1)) * chartWidth;
            const getY = (units) => padding.top + chartHeight - ((units - minUnits) / range) * chartHeight;
            
            let svg = `<svg class="chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;
            
            // Grid lines
            const gridValues = [];
            for (let v = Math.ceil(minUnits); v <= Math.floor(maxUnits); v += Math.ceil(range / 5)) {
                gridValues.push(v);
            }
            gridValues.forEach(val => {
                const y = getY(val);
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" stroke="var(--border-color)" stroke-width="0.5" stroke-dasharray="4,4" opacity="0.5"/>`;
                svg += `<text x="${padding.left - 10}" y="${y + 4}" fill="var(--text-muted)" text-anchor="end" font-size="12" font-family="JetBrains Mono, monospace">${val >= 0 ? '+' : ''}${val.toFixed(0)}u</text>`;
            });
            
            // Zero line (emphasized)
            const zeroY = getY(0);
            svg += `<line x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" stroke="var(--text-muted)" stroke-width="1.5"/>`;
            
            // Area fill
            let areaPath = `M ${getX(0)} ${zeroY}`;
            data.forEach((d, i) => areaPath += ` L ${getX(i)} ${getY(d.units)}`);
            areaPath += ` L ${getX(data.length - 1)} ${zeroY} Z`;
            const areaColor = cumulative >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            svg += `<path d="${areaPath}" fill="${areaColor}" class="chart-area"/>`;
            
            // Line
            let linePath = `M ${getX(0)} ${getY(data[0].units)}`;
            data.forEach((d, i) => {
                if (i > 0) linePath += ` L ${getX(i)} ${getY(d.units)}`;
            });
            svg += `<path d="${linePath}" stroke="${areaColor}" class="chart-line" stroke-width="3"/>`;
            
            // Dots for key points (start, middle, end)
            const keyPoints = [0, Math.floor(data.length / 4), Math.floor(data.length / 2), Math.floor(3 * data.length / 4), data.length - 1];
            keyPoints.forEach(i => {
                if (data[i]) {
                    svg += `<circle cx="${getX(i)}" cy="${getY(data[i].units)}" r="5" fill="${areaColor}" stroke="var(--bg-card)" stroke-width="2"/>`;
                }
            });
            
            // X-axis labels (pick numbers)
            const labelCount = Math.min(7, data.length);
            for (let i = 0; i < labelCount; i++) {
                const idx = Math.floor(i * (data.length - 1) / (labelCount - 1));
                if (data[idx]) {
                    svg += `<text x="${getX(idx)}" y="${height - 12}" fill="var(--text-muted)" text-anchor="middle" font-size="11" font-family="JetBrains Mono, monospace">#${idx + 1}</text>`;
                }
            }
            
            svg += '</svg>';
            
            const winCount = data.filter(d => d.result === 'win').length;
            const lossCount = data.filter(d => d.result === 'loss').length;
            
            container.innerHTML = svg + `
                <div class="chart-legend">
                    <div class="chart-legend-item"><span class="chart-legend-dot" style="background:${areaColor}"></span><strong>Total: ${cumulative >= 0 ? '+' : ''}${cumulative.toFixed(2)} units</strong></div>
                    <div class="chart-legend-item">${winCount}W - ${lossCount}L (${data.length} picks)</div>
                </div>
            `;
        }
        
        function renderTierChart(container, graded, width, height, padding, chartWidth, chartHeight) {
            // Win% tiers - calibrated thresholds (62%+ Best Bet, 58-62% Elite, 55-58% High, 52.4-55% Medium, <52.4% Low)
            const tiers = [
                { name: 'Best Bet', range: '62%+', min: TIER_THRESHOLDS.BEST_BET, max: 100, color: 'var(--conf-bestbet)' },
                { name: 'Elite', range: '58-62%', min: TIER_THRESHOLDS.ELITE, max: TIER_THRESHOLDS.BEST_BET - 0.01, color: 'var(--conf-elite)' },
                { name: 'High', range: '55-58%', min: TIER_THRESHOLDS.HIGH, max: TIER_THRESHOLDS.ELITE - 0.01, color: 'var(--conf-high)' },
                { name: 'Medium', range: '52-55%', min: TIER_THRESHOLDS.MEDIUM, max: TIER_THRESHOLDS.HIGH - 0.01, color: 'var(--conf-medium)' },
                { name: 'Low', range: '<52%', min: 0, max: TIER_THRESHOLDS.MEDIUM - 0.01, color: 'var(--conf-low)' }
            ];
            
            const tierData = tiers.map(t => {
                const picks = graded.filter(p => {
                    const wp = p.winProb || 50;
                    return wp >= t.min && wp <= t.max;
                });
                const wins = picks.filter(p => p.result === 'win').length;
                const losses = picks.filter(p => p.result === 'loss').length;
                const total = wins + losses;
                const winRate = total > 0 ? (wins / total) * 100 : 0;
                const units = (wins * 0.91) - losses;
                return { ...t, wins, losses, total, winRate, units };
            });
            
            const barHeight = (chartHeight - 50) / 5;
            const barGap = 12;
            
            // Adjust padding for left-side stats
            const leftStatsWidth = 90;
            const barStartX = padding.left + leftStatsWidth;
            const actualChartWidth = width - barStartX - padding.right;
            
            let svg = `<svg class="chart-svg" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet">`;
            
            // 52.4% break-even line
            const breakEvenX = barStartX + (52.4 / 100) * actualChartWidth;
            svg += `<line x1="${breakEvenX}" y1="${padding.top - 5}" x2="${breakEvenX}" y2="${height - padding.bottom + 10}" stroke="var(--accent-yellow)" stroke-width="2" stroke-dasharray="6,4"/>`;
            svg += `<text x="${breakEvenX}" y="${padding.top - 12}" fill="var(--accent-yellow)" text-anchor="middle" font-size="11" font-weight="600">52.4% Break Even</text>`;
            
            // X-axis percentage markers
            [0, 25, 50, 75, 100].forEach(pct => {
                const x = barStartX + (pct / 100) * actualChartWidth;
                svg += `<text x="${x}" y="${height - 8}" fill="var(--text-muted)" text-anchor="middle" font-size="10" font-family="JetBrains Mono, monospace">${pct}%</text>`;
            });
            
            tierData.forEach((t, i) => {
                const y = padding.top + i * (barHeight + barGap);
                const barWidth = t.total > 0 ? (t.winRate / 100) * actualChartWidth : 0;
                const bgWidth = actualChartWidth;
                
                // Stats on LEFT side (before bars)
                if (t.total > 0) {
                    svg += `<text x="${padding.left}" y="${y + barHeight / 2 - 2}" fill="var(--text-primary)" text-anchor="start" font-size="13" font-weight="700" font-family="JetBrains Mono, monospace">${t.wins}-${t.losses}</text>`;
                    svg += `<text x="${padding.left}" y="${y + barHeight / 2 + 13}" fill="var(--text-muted)" text-anchor="start" font-size="11" font-family="JetBrains Mono, monospace">${t.winRate.toFixed(0)}%</text>`;
                } else {
                    svg += `<text x="${padding.left}" y="${y + barHeight / 2 + 5}" fill="var(--text-muted)" text-anchor="start" font-size="11">0-0</text>`;
                }
                
                // Background bar
                svg += `<rect x="${barStartX}" y="${y}" width="${bgWidth}" height="${barHeight}" fill="var(--bg-input)" rx="6"/>`;
                
                // Win rate bar
                if (barWidth > 0) {
                    svg += `<rect x="${barStartX}" y="${y}" width="${barWidth}" height="${barHeight}" fill="${t.color}" rx="6"/>`;
                }
                
                // Tier name + units INSIDE bar
                const unitsText = t.total > 0 ? ` ${t.units >= 0 ? '+' : ''}${t.units.toFixed(1)}u` : '';
                svg += `<text x="${barStartX + 12}" y="${y + barHeight / 2 + 5}" fill="white" font-size="14" font-weight="700">${t.name}${unitsText}</text>`;
            });
            
            svg += '</svg>';
            
            container.innerHTML = svg + `
                <div class="chart-legend">
                    <div class="chart-legend-item">Actual win rate by Win% tier  52.4% needed to break even at -110 odds</div>
                </div>
            `;
        }
        
        function renderDailyCalendar(predictions) {
            const container = document.getElementById('dailyCalendar');
            const graded = predictions.filter(p => p.status === 'graded');
            
            if (graded.length === 0) {
                container.innerHTML = '<div class="calendar-loading">No graded picks yet. Refresh data to capture predictions.</div>';
                return;
            }
            
            // Group by day
            const byDay = {};
            predictions.forEach(p => {
                const day = new Date(p.gameDate).toISOString().split('T')[0];
                if (!byDay[day]) byDay[day] = [];
                byDay[day].push(p);
            });
            
            // Get date range (last N days based on time frame)
            const endDate = new Date();
            const startDate = new Date();
            const daysToShow = selectedTimeFrame === 'all' ? 28 : Math.min(selectedTimeFrame, 28);
            startDate.setDate(endDate.getDate() - daysToShow + 1);
            
            // Adjust to start on Sunday
            startDate.setDate(startDate.getDate() - startDate.getDay());
            
            let html = '<div class="calendar-grid">';
            
            // Headers
            ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].forEach(day => {
                html += `<div class="calendar-header">${day}</div>`;
            });
            
            // Days
            const today = new Date().toISOString().split('T')[0];
            let currentDate = new Date(startDate);
            
            for (let i = 0; i < 35; i++) {
                const dateStr = currentDate.toISOString().split('T')[0];
                const dayPicks = byDay[dateStr] || [];
                const gradedPicks = dayPicks.filter(p => p.status === 'graded');
                const pendingPicks = dayPicks.filter(p => p.status === 'pending');
                
                const wins = gradedPicks.filter(p => p.result === 'win').length;
                const losses = gradedPicks.filter(p => p.result === 'loss').length;
                const total = wins + losses;
                const units = (wins * 0.91) - losses;
                
                let dayClass = 'calendar-day';
                if (dateStr > today) {
                    dayClass += ' future';
                } else if (total === 0 && pendingPicks.length === 0) {
                    dayClass += ' no-picks';
                } else if (total > 0) {
                    if (wins > losses) dayClass += ' winning';
                    else if (losses > wins) dayClass += ' losing';
                    else dayClass += ' even';
                }
                
                const dateLabel = currentDate.getDate();
                
                html += `<div class="${dayClass}" onclick="showDayDetail('${dateStr}')" data-date="${dateStr}">
                    <div class="calendar-day-date">${dateLabel}</div>`;
                
                if (total > 0 || pendingPicks.length > 0) {
                    html += `<div class="calendar-day-record">${total > 0 ? `${wins}-${losses}` : `${pendingPicks.length}P`}</div>`;
                    if (total > 0) {
                        html += `<div class="calendar-day-units ${units >= 0 ? 'positive' : 'negative'}">${units >= 0 ? '+' : ''}${units.toFixed(1)}u</div>`;
                    }
                    
                    // Win% tier breakdown dots (62%+ Best Bet, 58-62% Elite, 55-58% High) - calibrated thresholds
                    const picksWithWinProb = gradedPicks.filter(p => p.winProb !== undefined && p.winProb !== null);
                    const bestBetPicks = picksWithWinProb.filter(p => p.winProb >= TIER_THRESHOLDS.BEST_BET);
                    const elitePicks = picksWithWinProb.filter(p => p.winProb >= TIER_THRESHOLDS.ELITE && p.winProb < TIER_THRESHOLDS.BEST_BET);
                    const highPicks = picksWithWinProb.filter(p => p.winProb >= TIER_THRESHOLDS.HIGH && p.winProb < TIER_THRESHOLDS.ELITE);
                    if (bestBetPicks.length > 0 || elitePicks.length > 0 || highPicks.length > 0) {
                        html += '<div class="calendar-day-breakdown">';
                        if (bestBetPicks.length > 0) html += `<div class="calendar-day-dot" style="background:var(--conf-bestbet)" title="${bestBetPicks.length} best bet picks (62%+)"></div>`;
                        if (elitePicks.length > 0) html += `<div class="calendar-day-dot" style="background:var(--conf-elite)" title="${elitePicks.length} elite picks (58-62%)"></div>`;
                        if (highPicks.length > 0) html += `<div class="calendar-day-dot" style="background:var(--conf-high)" title="${highPicks.length} high picks (55-58%)"></div>`;
                        html += '</div>';
                    }
                }
                
                html += '</div>';
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function showDayDetail(dateStr) {
            const modal = document.getElementById('dayDetailModal');
            const title = document.getElementById('dayDetailTitle');
            const body = document.getElementById('dayDetailBody');
            
            const dayPicks = allPredictionsCache.filter(p => 
                new Date(p.gameDate).toISOString().split('T')[0] === dateStr
            );
            
            if (dayPicks.length === 0) return;
            
            const dateObj = new Date(dateStr + 'T12:00:00');
            const dateLabel = dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
            title.textContent = dateLabel;
            
            const graded = dayPicks.filter(p => p.status === 'graded');
            const pending = dayPicks.filter(p => p.status === 'pending');
            const wins = graded.filter(p => p.result === 'win').length;
            const losses = graded.filter(p => p.result === 'loss').length;
            const units = (wins * 0.91) - losses;
            const winRate = (wins + losses) > 0 ? (wins / (wins + losses)) * 100 : 0;
            
            let html = `
                <div class="day-detail-stats">
                    <div class="day-detail-stat">
                        <div class="day-detail-stat-value ${wins > losses ? 'green' : losses > wins ? 'red' : ''}">${wins}-${losses}</div>
                        <div class="day-detail-stat-label">Record</div>
                    </div>
                    <div class="day-detail-stat">
                        <div class="day-detail-stat-value ${units >= 0 ? 'green' : 'red'}">${units >= 0 ? '+' : ''}${units.toFixed(2)}u</div>
                        <div class="day-detail-stat-label">Units</div>
                    </div>
                    <div class="day-detail-stat">
                        <div class="day-detail-stat-value ${winRate >= 55 ? 'green' : winRate < 50 && graded.length > 0 ? 'red' : ''}">${graded.length > 0 ? winRate.toFixed(0) + '%' : '--'}</div>
                        <div class="day-detail-stat-label">Win Rate</div>
                    </div>
                </div>
            `;
            
            // Calculate stats by tier (calibrated thresholds)
            const tiers = [
                { key: 'bestbet', label: 'Best Bet 62%+', min: TIER_THRESHOLDS.BEST_BET, max: 100 },
                { key: 'elite', label: 'Elite 58-62%', min: TIER_THRESHOLDS.ELITE, max: TIER_THRESHOLDS.BEST_BET - 0.01 },
                { key: 'high', label: 'High 55-58%', min: TIER_THRESHOLDS.HIGH, max: TIER_THRESHOLDS.ELITE - 0.01 },
                { key: 'medium', label: 'Med 52-55%', min: TIER_THRESHOLDS.MEDIUM, max: TIER_THRESHOLDS.HIGH - 0.01 },
                { key: 'low', label: 'Low <52%', min: 0, max: TIER_THRESHOLDS.MEDIUM - 0.01 }
            ];
            
            // Separate graded picks into those with valid winProb and those without
            const gradedWithWinProb = graded.filter(p => p.winProb !== undefined && p.winProb !== null);
            const gradedWithoutWinProb = graded.filter(p => p.winProb === undefined || p.winProb === null);
            
            const tierStats = tiers.map(tier => {
                const tierPicks = gradedWithWinProb.filter(p => {
                    return p.winProb >= tier.min && p.winProb <= tier.max;
                });
                const tierWins = tierPicks.filter(p => p.result === 'win').length;
                const tierLosses = tierPicks.filter(p => p.result === 'loss').length;
                const tierUnits = (tierWins * 0.91) - tierLosses;
                const tierWinRate = (tierWins + tierLosses) > 0 ? (tierWins / (tierWins + tierLosses)) * 100 : 0;
                return {
                    ...tier,
                    wins: tierWins,
                    losses: tierLosses,
                    units: tierUnits,
                    winRate: tierWinRate,
                    total: tierWins + tierLosses
                };
            }).filter(t => t.total > 0); // Only show tiers that have graded picks
            
            // Add unknown tier if there are picks without winProb
            if (gradedWithoutWinProb.length > 0) {
                const unknownWins = gradedWithoutWinProb.filter(p => p.result === 'win').length;
                const unknownLosses = gradedWithoutWinProb.filter(p => p.result === 'loss').length;
                const unknownUnits = (unknownWins * 0.91) - unknownLosses;
                const unknownWinRate = (unknownWins + unknownLosses) > 0 ? (unknownWins / (unknownWins + unknownLosses)) * 100 : 0;
                tierStats.push({
                    key: 'unknown',
                    label: 'Unknown*',
                    wins: unknownWins,
                    losses: unknownLosses,
                    units: unknownUnits,
                    winRate: unknownWinRate,
                    total: unknownWins + unknownLosses
                });
            }
            
            if (tierStats.length > 0) {
                html += `<div class="day-detail-tier-breakdown">
                    <div class="day-detail-tier-title">Performance by Tier</div>`;
                tierStats.forEach(t => {
                    html += `
                        <div class="day-detail-tier-row ${t.key}">
                            <div class="day-detail-tier-label ${t.key}">${t.label}</div>
                            <div class="day-detail-tier-stat">
                                <div class="day-detail-tier-stat-value ${t.wins > t.losses ? 'green' : t.losses > t.wins ? 'red' : ''}">${t.wins}-${t.losses}</div>
                                <div class="day-detail-tier-stat-label">Record</div>
                            </div>
                            <div class="day-detail-tier-stat">
                                <div class="day-detail-tier-stat-value ${t.units >= 0 ? 'green' : 'red'}">${t.units >= 0 ? '+' : ''}${t.units.toFixed(2)}u</div>
                                <div class="day-detail-tier-stat-label">Units</div>
                            </div>
                            <div class="day-detail-tier-stat">
                                <div class="day-detail-tier-stat-value ${t.winRate >= 55 ? 'green' : t.winRate < 50 ? 'red' : ''}">${t.winRate.toFixed(0)}%</div>
                                <div class="day-detail-tier-stat-label">Win Rate</div>
                            </div>
                        </div>`;
                });
                if (gradedWithoutWinProb.length > 0) {
                    html += `<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.5rem;">*Unknown = picks captured before win% tracking was added</div>`;
                }
                html += `</div>`;
            }
            
            // Helper for win% tier label (calibrated thresholds)
            const getWinProbTier = (p) => {
                if (p.winProb === undefined || p.winProb === null) return 'Unknown';
                const wp = p.winProb;
                return wp >= TIER_THRESHOLDS.BEST_BET ? 'Best Bet 62%+' : wp >= TIER_THRESHOLDS.ELITE ? 'Elite 58%+' : wp >= TIER_THRESHOLDS.HIGH ? 'High 55%+' : wp >= TIER_THRESHOLDS.MEDIUM ? 'Med 52%+' : 'Low';
            };
            
            // Helper to format pick display with teams for totals
            const formatPickDisplay = (p) => {
                if (p.pickType === 'total') {
                    return `${p.pickDisplay} <span style="color:var(--text-muted);font-size:0.7rem;">(${p.awayTeam} @ ${p.homeTeam})</span>`;
                }
                return p.pickDisplay;
            };
            
            if (pending.length > 0) {
                html += `<div class="day-detail-picks-title"> Pending (${pending.length})</div>`;
                pending.forEach(p => {
                    const tierLabel = getWinProbTier(p);
                    const wpDisplay = p.winProb !== undefined && p.winProb !== null ? ` ${p.winProb.toFixed(0)}%` : '';
                    html += `<div class="day-detail-pick pending">
                        <div class="day-detail-pick-info">${formatPickDisplay(p)} <span style="color:var(--text-muted);font-size:0.75rem;">(${tierLabel}${wpDisplay})</span></div>
                        <div class="day-detail-pick-result pending">PENDING</div>
                    </div>`;
                });
            }
            
            if (graded.length > 0) {
                html += `<div class="day-detail-picks-title"> Graded (${graded.length})</div>`;
                graded.forEach(p => {
                    const tierLabel = getWinProbTier(p);
                    const wpDisplay = p.winProb !== undefined && p.winProb !== null ? ` ${p.winProb.toFixed(0)}%` : '';
                    html += `<div class="day-detail-pick ${p.result}">
                        <div class="day-detail-pick-info">${formatPickDisplay(p)} <span style="color:var(--text-muted);font-size:0.75rem;">(${tierLabel}${wpDisplay})</span></div>
                        <div class="day-detail-pick-result ${p.result}">${p.result.toUpperCase()}</div>
                    </div>`;
                });
            }
            
            body.innerHTML = html;
            modal.style.display = 'flex';
        }
        
        function closeDayDetail() {
            document.getElementById('dayDetailModal').style.display = 'none';
        }
        
        // Close modal on outside click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('dayDetailModal');
            if (e.target === modal) {
                closeDayDetail();
            }
        });
        
        function filterTrackerPicks(filter, btn) {
            currentTrackerFilter = filter;
            document.querySelectorAll('.val-pick-filter').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            renderPredictionTracker();
        }
        
        async function renderTrackerPicksList(predictions) {
            const container = document.getElementById('trackerPicksList');
            if (!container) return;
            
            // Data is already filtered by record filter
            const filtered = predictions;
            
            // Update count label
            const countEl = document.getElementById('picksCountLabel');
            if (countEl) countEl.textContent = `${filtered.length} picks`;
            
            if (!filtered.length) {
                container.innerHTML = `
                    <div class="tracker-empty">
                        <div class="tracker-empty-icon"></div>
                        <div class="tracker-empty-title">No picks found</div>
                        <div class="tracker-empty-text">Click "Refresh Data" to capture today's predictions. They'll automatically resolve when games complete.</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = renderPicksList(filtered);
        }
        
        function renderPicksList(filtered) {
            return filtered.slice(0, 100).map(p => {
                // Use winProb for tier classification (calibrated thresholds)
                const wp = p.winProb || (50 + (p.confidence - 50) * 0.24);
                const isBestBetTier = wp >= TIER_THRESHOLDS.BEST_BET;
                const confColor = wp >= TIER_THRESHOLDS.BEST_BET ? 'var(--conf-bestbet)' :
                                  wp >= TIER_THRESHOLDS.ELITE ? 'var(--conf-elite)' :
                                  wp >= TIER_THRESHOLDS.HIGH ? 'var(--conf-high)' :
                                  wp >= TIER_THRESHOLDS.MEDIUM ? 'var(--conf-medium)' : 'var(--conf-low)';
                const tierLabel = wp >= TIER_THRESHOLDS.BEST_BET ? 'Best Bet' : wp >= TIER_THRESHOLDS.ELITE ? 'Elite' : wp >= TIER_THRESHOLDS.HIGH ? 'High' : wp >= TIER_THRESHOLDS.MEDIUM ? 'Med' : 'Low';
                const dateStr = new Date(p.gameDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const typeIcon = p.pickType === 'spread' ? '' : '';
                const typeLabel = p.pickType === 'spread' ? 'SPR' : 'TOT';
                
                // Basketball rating for Best Bet picks
                const rating = isBestBetTier ? getEliteRating(wp) : 0;
                const ratingDisplay = rating > 0 ? renderEliteRatingMini(wp) : '';
                
                let detailsStr = `${p.awayTeam} @ ${p.homeTeam}  ${dateStr}`;
                if (p.status === 'graded' && p.homeScore !== null) {
                    if (p.pickType === 'spread') {
                        detailsStr += `  Final: ${p.awayScore}-${p.homeScore}`;
                    } else {
                        detailsStr += `  Total: ${p.homeScore + p.awayScore}`;
                    }
                }
                
                const resultClass = p.status === 'pending' ? 'pending' : p.result;
                const resultText = p.status === 'pending' ? 'PENDING' : p.result.toUpperCase();
                
                return `
                    <div class="tracker-pick ${resultClass}">
                        <div class="tracker-pick-main">
                            <div class="tracker-pick-team">
                                ${typeIcon} ${p.pickDisplay}
                                ${isBestBetTier ? '<span class="best-bet-badge"> BEST BET</span>' : ''}
                            </div>
                            <div class="tracker-pick-details">${detailsStr}  <strong>${tierLabel}</strong> (${wp.toFixed(0)}% Win)${isBestBetTier ? ` ${ratingDisplay}` : ''}</div>
                        </div>
                        <div class="tracker-pick-meta">
                            <div class="tracker-pick-type">${typeLabel}</div>
                            <div class="tracker-pick-conf" style="background:${confColor}">${wp.toFixed(0)}%</div>
                            <div class="tracker-pick-outcome ${resultClass}">${resultText}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Export predictions to CSV
        async function exportPredictions() {
            const predictions = await getAllPredictions();
            if (!predictions.length) {
                alert('No predictions to export');
                return;
            }
            
            const csvContent = generatePredictionsCSV(predictions);
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `spreadsheet_predictions_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Generate CSV content from predictions
        function generatePredictionsCSV(predictions) {
            const headers = ['Date', 'Away Team', 'Home Team', 'Type', 'Pick', 'Line', 'WinProb', 'Confidence', 'Edge', 'Best Bet', 'Status', 'Result', 'Away Score', 'Home Score', 'GameID', 'PickSide', 'PickTeam', 'CapturedAt'];
            const rows = predictions.map(p => {
                const wp = p.winProb || (50 + (p.confidence - 50) * 0.24);
                return [
                    p.gameDate,
                    p.awayTeam,
                    p.homeTeam,
                    p.pickType,
                    p.pickDisplay,
                    p.vegasLine,
                    wp.toFixed(2),
                    p.confidence,
                    p.edge.toFixed(2),
                    p.isBestBet ? 'Yes' : 'No',
                    p.status,
                    p.result || '',
                    p.awayScore || '',
                    p.homeScore || '',
                    p.gameId || '',
                    p.pickSide || '',
                    p.pickTeam || '',
                    p.capturedAt || ''
                ];
            });
            
            return [headers, ...rows].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
        }
        
        // Share predictions via native share (mobile) or copy to clipboard
        async function sharePredictions() {
            const predictions = await getAllPredictions();
            if (!predictions.length) {
                alert('No predictions to share');
                return;
            }
            
            const csvContent = generatePredictionsCSV(predictions);
            const fileName = `spreadsheet_predictions_${new Date().toISOString().split('T')[0]}.csv`;
            
            // Try native share API first (mobile)
            if (navigator.share && navigator.canShare) {
                try {
                    const file = new File([csvContent], fileName, { type: 'text/csv' });
                    if (navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            files: [file],
                            title: 'Spread Sheet Predictions',
                            text: `My betting predictions as of ${new Date().toLocaleDateString()}`
                        });
                        return;
                    }
                } catch (e) {
                    if (e.name !== 'AbortError') {
                        console.warn('Share failed:', e);
                    } else {
                        return; // User cancelled
                    }
                }
            }
            
            // Fallback: copy to clipboard or download
            try {
                await navigator.clipboard.writeText(csvContent);
                alert('CSV data copied to clipboard! Paste into a file or email.');
            } catch (e) {
                // Final fallback: just download
                exportPredictions();
            }
        }
        
        // Import predictions from CSV file
        async function importPredictions(file) {
            if (!file) return;
            
            const text = await file.text();
            const lines = text.split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
                alert('CSV file appears to be empty or invalid');
                return;
            }
            
            // Parse header to find column indices
            const headerLine = lines[0];
            const headers = headerLine.split(',').map(h => h.replace(/"/g, '').trim().toLowerCase());
            
            const getIndex = (names) => {
                for (const name of names) {
                    const idx = headers.indexOf(name.toLowerCase());
                    if (idx >= 0) return idx;
                }
                return -1;
            };
            
            // Find column indices (flexible matching)
            const cols = {
                date: getIndex(['date', 'gamedate']),
                awayTeam: getIndex(['away team', 'awayteam', 'away']),
                homeTeam: getIndex(['home team', 'hometeam', 'home']),
                type: getIndex(['type', 'picktype']),
                pick: getIndex(['pick', 'pickdisplay']),
                line: getIndex(['line', 'vegasline']),
                winProb: getIndex(['winprob', 'win%', 'winprobability']),
                confidence: getIndex(['confidence', 'score']),
                edge: getIndex(['edge']),
                bestBet: getIndex(['best bet', 'bestbet', 'isbest']),
                status: getIndex(['status']),
                result: getIndex(['result']),
                awayScore: getIndex(['away score', 'awayscore']),
                homeScore: getIndex(['home score', 'homescore']),
                gameId: getIndex(['gameid', 'game id']),
                pickSide: getIndex(['pickside', 'side']),
                pickTeam: getIndex(['pickteam', 'team']),
                capturedAt: getIndex(['capturedat', 'captured'])
            };
            
            // Validate required columns
            if (cols.date < 0 || cols.awayTeam < 0 || cols.homeTeam < 0 || cols.type < 0 || cols.pick < 0) {
                alert('CSV is missing required columns (Date, Away Team, Home Team, Type, Pick)');
                return;
            }
            
            const parseCell = (row, idx) => {
                if (idx < 0 || idx >= row.length) return '';
                return row[idx].replace(/"/g, '').trim();
            };
            
            let imported = 0;
            let skipped = 0;
            
            for (let i = 1; i < lines.length; i++) {
                // Parse CSV line (handle quoted values)
                const row = [];
                let current = '';
                let inQuotes = false;
                for (const char of lines[i]) {
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        row.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                row.push(current);
                
                try {
                    const gameDate = parseCell(row, cols.date);
                    const awayTeam = parseCell(row, cols.awayTeam);
                    const homeTeam = parseCell(row, cols.homeTeam);
                    const pickType = parseCell(row, cols.type).toLowerCase();
                    const pickDisplay = parseCell(row, cols.pick);
                    
                    if (!gameDate || !awayTeam || !homeTeam || !pickType || !pickDisplay) {
                        skipped++;
                        continue;
                    }
                    
                    // Parse date - handle both ISO and locale formats
                    let parsedDate;
                    if (gameDate.includes('T')) {
                        parsedDate = new Date(gameDate);
                    } else {
                        parsedDate = new Date(gameDate + 'T12:00:00');
                    }
                    
                    if (isNaN(parsedDate.getTime())) {
                        skipped++;
                        continue;
                    }
                    
                    const gameId = parseCell(row, cols.gameId) || `imported_${parsedDate.toISOString().split('T')[0]}_${awayTeam}_${homeTeam}_${pickType}`;
                    const predId = `${gameId}_${pickType}`;
                    
                    // Check if already exists
                    const existing = await getPredictionByGameAndType(gameId, pickType);
                    if (existing) {
                        skipped++;
                        continue;
                    }
                    
                    const status = parseCell(row, cols.status).toLowerCase() || 'pending';
                    const result = parseCell(row, cols.result).toLowerCase() || null;
                    const winProb = parseFloat(parseCell(row, cols.winProb)) || 50;
                    const confidence = parseFloat(parseCell(row, cols.confidence)) || 50;
                    const edge = parseFloat(parseCell(row, cols.edge)) || 0;
                    const isBestBet = ['yes', 'true', '1'].includes(parseCell(row, cols.bestBet).toLowerCase());
                    const awayScore = parseCell(row, cols.awayScore) ? parseInt(parseCell(row, cols.awayScore)) : null;
                    const homeScore = parseCell(row, cols.homeScore) ? parseInt(parseCell(row, cols.homeScore)) : null;
                    const pickSide = parseCell(row, cols.pickSide) || (pickType === 'total' ? pickDisplay.split(' ')[0].toLowerCase() : 'unknown');
                    const pickTeam = parseCell(row, cols.pickTeam) || pickDisplay.split(' ')[0];
                    const capturedAt = parseCell(row, cols.capturedAt) || new Date().toISOString();
                    
                    await savePrediction({
                        id: predId,
                        gameId: gameId,
                        pickType: pickType,
                        homeTeam: homeTeam,
                        awayTeam: awayTeam,
                        gameDate: parsedDate.toISOString(),
                        capturedAt: capturedAt,
                        vegasLine: parseFloat(parseCell(row, cols.line)) || 0,
                        pickTeam: pickTeam,
                        pickSide: pickSide,
                        pickLine: parseFloat(parseCell(row, cols.line)) || 0,
                        pickDisplay: pickDisplay,
                        confidence: confidence,
                        winProb: winProb,
                        edge: edge,
                        isBestBet: isBestBet,
                        bestBetRating: isBestBet ? getEliteRating(winProb) : 0,
                        status: status === 'graded' ? 'graded' : 'pending',
                        result: result && ['win', 'loss', 'push'].includes(result) ? result : null,
                        homeScore: homeScore,
                        awayScore: awayScore,
                        resolvedAt: status === 'graded' ? new Date().toISOString() : null
                    });
                    
                    imported++;
                } catch (e) {
                    console.warn('Error importing row:', e);
                    skipped++;
                }
            }
            
            // Clear file input
            const fileInput = document.getElementById('settingsImportInput');
            if (fileInput) fileInput.value = '';
            
            alert(`Import complete!\n\n Imported: ${imported} predictions\n Skipped: ${skipped} (duplicates or invalid)`);
            
            if (imported > 0) {
                renderPredictionTracker();
            }
        }
        
        // Clear all predictions with confirmation
        async function clearAllPredictions() {
            if (!confirm('Are you sure you want to clear ALL prediction data? This cannot be undone.')) return;
            if (!confirm('Really delete everything? All your tracking history will be lost.')) return;
            
            await clearAllPredictionsDB();
            renderPredictionTracker();
        }
        
        // Legacy validation functions (kept for compatibility)
        function runValidation(n = 25) { 
            renderPredictionTracker();
        }
        function loadValidation(n, btn) { runValidation(n); }
        function renderValidation() { renderPredictionTracker(); }

        // ==================== MARCH MADNESS BRACKET SIMULATOR ====================
        
        // ===== MARCH MADNESS TOURNAMENT ENGINE v2 =====
        // 68-team field, auto-bids, First Four, Monte Carlo, constraint-based bracketing

        let bracketConfig = {
            use_auto_bids: true,
            avoid_same_conf: true,
            balance_regions: true,
            first_four: true,
            rng_seed: null,
            n_sims: 1000,
            mismatch_damp: 0.85,
            play_in_seed: 11,
            swap_limit: 3
        };

        let bracketState = {
            teams: [],
            field: null,
            seedList: [],
            tiebreakNotes: [],
            bracket: null,
            results: null,
            upsets: [],
            swapLog: [],
            monteCarloResults: null,
            firstFour: []
        };

        // Seeded RNG (mulberry32) for reproducibility
        function makeRng(seed) {
            if (seed == null) return () => Math.random();
            let s = seed | 0;
            return function() {
                s |= 0; s = s + 0x6D2B79F5 | 0;
                let t = Math.imul(s ^ s >>> 15, 1 | s);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // === STEP 1: Build 68-Team Field ===
        function buildField() {
            const allTeams = Object.values(state.ratings)
                .filter(t => t.netRating !== undefined && t.offRating !== undefined && t.defRating !== undefined)
                .map(t => ({ name: t.name, conf: t.conference, net: t.netRating, off: t.offRating, def: t.defRating }))
                .sort((a, b) => b.net - a.net);

            if (allTeams.length < 68) {
                console.warn(` Only ${allTeams.length} teams available, need 68 for full field`);
            }

            const confTeams = {};
            allTeams.forEach(t => { if (!confTeams[t.conf]) confTeams[t.conf] = []; confTeams[t.conf].push(t.net); });
            const confMedian = {};
            Object.keys(confTeams).forEach(c => {
                const sorted = [...confTeams[c]].sort((a, b) => b - a);
                confMedian[c] = sorted[Math.floor(sorted.length / 2)];
            });

            const autoBids = [];
            if (bracketConfig.use_auto_bids) {
                const conferences = [...new Set(allTeams.map(t => t.conf))].sort();
                conferences.forEach(conf => {
                    const best = allTeams.find(t => t.conf === conf);
                    if (best) autoBids.push({ ...best, bidType: 'auto' });
                });
                console.log(` Field: ${autoBids.length} conferences  ${autoBids.length} auto-bids`);
            }

            const autoBidNames = new Set(autoBids.map(t => t.name));
            const atLargePool = allTeams.filter(t => !autoBidNames.has(t.name));
            const targetSize = bracketConfig.first_four ? 68 : 64;
            const atLargeCount = Math.max(0, targetSize - autoBids.length);
            const atLarges = atLargePool.slice(0, atLargeCount).map(t => ({ ...t, bidType: 'at-large' }));

            const lastFourIn = atLarges.slice(-4);
            const firstFourOut = atLargePool.slice(atLargeCount, atLargeCount + 4).map(t => ({ ...t, bidType: 'out' }));

            const field = [...autoBids, ...atLarges].sort((a, b) => b.net - a.net);
            field.forEach((t, i) => { t.overallSeed = i + 1; t.confMedian = confMedian[t.conf] || 0; });

            // Compute net rating standard deviation across the field for adaptive tiebreak
            const nets = field.map(t => t.net);
            const mean = nets.reduce((s, v) => s + v, 0) / nets.length;
            const variance = nets.reduce((s, v) => s + (v - mean) ** 2, 0) / nets.length;
            const stddev = Math.sqrt(variance);
            // Tiebreak window = 0.15  stddev (typically ~0.91.5 pts depending on season parity)
            const tiebreakWindow = Math.max(0.15, Math.min(2.0, 0.15 * stddev));
            console.log(` Field stddev: ${stddev.toFixed(2)}, adaptive tiebreak window: ${tiebreakWindow.toFixed(3)} pts`);

            // Validate field size
            if (field.length !== targetSize) {
                console.warn(` Field has ${field.length} teams (target: ${targetSize})`);
            }

            // Log bubble teams
            if (lastFourIn.length && firstFourOut.length) {
                const cutline = lastFourIn[lastFourIn.length - 1]?.net;
                const firstOut = firstFourOut[0]?.net;
                console.log(` Bubble: Last in ${lastFourIn[lastFourIn.length-1]?.name} (${cutline?.toFixed(1)}), First out ${firstFourOut[0]?.name} (${firstOut?.toFixed(1)}), gap ${(cutline - firstOut)?.toFixed(2)}`);
            }

            bracketState.field = { autoBids, atLarges, lastFourIn, firstFourOut, all: field, confMedian, stddev, tiebreakWindow };
            return bracketState.field;
        }

        // === STEP 2: Assign Seeds 1-68 with Tiebreaks ===
        function assignSeeds(field) {
            const teams = [...field.all];
            const notes = [];
            const tbWindow = field.tiebreakWindow || 0.3;
            notes.push(`Tiebreak window: ${tbWindow.toFixed(3)} pts (0.15  =${(field.stddev||0).toFixed(2)})`);

            // Multi-pass tiebreak: scan for clusters of teams within adaptive window
            // Within each cluster, prefer teams from stronger conferences (higher median net)
            let changed = true;
            let passes = 0;
            while (changed && passes < 3) {
                changed = false;
                passes++;
                for (let i = 0; i < teams.length - 1; i++) {
                    const a = teams[i], b = teams[i + 1];
                    const gap = Math.abs(a.net - b.net);
                    if (gap <= tbWindow && a.conf !== b.conf) {
                        if (b.confMedian > a.confMedian) {
                            [teams[i], teams[i + 1]] = [teams[i + 1], teams[i]];
                            notes.push(`Tiebreak: Swapped #${i+1} ${b.name} (${b.conf}, median ${b.confMedian.toFixed(1)}) over ${a.name} (${a.conf}, median ${a.confMedian.toFixed(1)})  gap only ${gap.toFixed(2)} pts, stronger conf`);
                            changed = true;
                        }
                    }
                }
            }
            if (passes > 1) notes.push(`Tiebreak stabilized after ${passes} passes`);
            teams.forEach((t, i) => { t.overallSeed = i + 1; });
            bracketState.seedList = teams;
            bracketState.tiebreakNotes = notes;
            return { teams, notes };
        }

        // === STEP 3: First Four Setup ===
        function setupFirstFour(seedList) {
            if (!bracketConfig.first_four) return { pairings: [], mainBracketTeams: seedList };

            const autoBids = seedList.filter(t => t.bidType === 'auto').sort((a, b) => a.net - b.net);
            const lowestAQs = autoBids.slice(0, 4);

            const atLarges = seedList.filter(t => t.bidType === 'at-large').sort((a, b) => a.net - b.net);
            const lowestALs = atLarges.slice(0, 4);

            const playInNames = new Set([...lowestAQs, ...lowestALs].map(t => t.name));
            const mainBracket = seedList.filter(t => !playInNames.has(t.name));
            const playInSeed = bracketConfig.play_in_seed;

            const pairings = [
                { type: '16-seed', seedLine: 16, t1: lowestAQs[0], t2: lowestAQs[1], label: 'First Four (16)' },
                { type: '16-seed', seedLine: 16, t1: lowestAQs[2], t2: lowestAQs[3], label: 'First Four (16)' },
                { type: 'at-large', seedLine: playInSeed, t1: lowestALs[0], t2: lowestALs[1], label: `First Four (${playInSeed})` },
                { type: 'at-large', seedLine: playInSeed, t1: lowestALs[2], t2: lowestALs[3], label: `First Four (${playInSeed})` }
            ];

            bracketState.firstFour = pairings;
            return { pairings, mainBracketTeams: mainBracket };
        }

        // === STEP 4: S-Curve Bracketing with Constraints ===
        function buildBracket(mainTeams, firstFourPairings) {
            const MAX_SWAP_ATTEMPTS = bracketConfig.swap_limit || 3;
            const regions = ['SOUTH', 'EAST', 'MIDWEST', 'WEST'];
            const bracket = { SOUTH: [], EAST: [], MIDWEST: [], WEST: [] };
            const swapLog = [];

            const hasFF = bracketConfig.first_four && firstFourPairings.length === 4;
            const playInSeed = bracketConfig.play_in_seed; // 11 or 12

            // Which regions get First Four play-in slots
            const ff16Regions = ['SOUTH', 'WEST'];         // 16-seed play-in winners land here
            const ffALRegions = ['EAST', 'MIDWEST'];        // at-large play-in winners land here
            const direct16Regions = ['EAST', 'MIDWEST'];    // these get direct 16-seeds
            const directALRegions = ['SOUTH', 'WEST'];      // these get direct at-large-line seeds

            // Build seed-line capacity map: how many direct placements per line
            // When FF is on: seed 16 and play_in_seed each have only 2 direct slots
            const seedLineDefs = [];
            for (let seed = 1; seed <= 16; seed++) {
                if (hasFF && seed === 16) {
                    seedLineDefs.push({ seed, capacity: 2, targetRegions: direct16Regions });
                } else if (hasFF && seed === playInSeed) {
                    seedLineDefs.push({ seed, capacity: 2, targetRegions: directALRegions });
                } else {
                    seedLineDefs.push({ seed, capacity: 4, targetRegions: [...regions] });
                }
            }

            // S-curve: fill each seed line from sorted mainTeams
            const teamsToPlace = [...mainTeams];
            let teamIdx = 0;

            seedLineDefs.forEach(line => {
                const group = teamsToPlace.slice(teamIdx, teamIdx + line.capacity);
                // Serpentine: reverse every even seed line
                if (line.seed % 2 === 0) group.reverse();

                line.targetRegions.forEach((r, i) => {
                    if (group[i]) {
                        bracket[r].push({ ...group[i], seed: line.seed, region: r });
                    }
                });
                teamIdx += line.capacity;
            });

            // Insert First Four placeholders into the reserved slots
            if (hasFF) {
                // 16-seed play-in placeholders  ff16Regions (South, West)
                firstFourPairings.filter(p => p.type === '16-seed').forEach((p, i) => {
                    const region = ff16Regions[i];
                    bracket[region].push({
                        name: `${p.t1.name} / ${p.t2.name}`, conf: 'TBD',
                        net: Math.max(p.t1.net, p.t2.net), off: 0, def: 0,
                        seed: 16, region, isFirstFour: true, firstFourPairing: p, bidType: 'auto'
                    });
                });

                // At-large play-in placeholders  ffALRegions (East, Midwest)
                firstFourPairings.filter(p => p.type === 'at-large').forEach((p, i) => {
                    const region = ffALRegions[i];
                    bracket[region].push({
                        name: `${p.t1.name} / ${p.t2.name}`, conf: 'TBD',
                        net: Math.max(p.t1.net, p.t2.net), off: 0, def: 0,
                        seed: playInSeed, region, isFirstFour: true, firstFourPairing: p, bidType: 'at-large'
                    });
                });
            }

            // Sort each region by seed and verify 16 teams
            regions.forEach(r => {
                bracket[r].sort((a, b) => a.seed - b.seed);
                if (bracket[r].length !== 16) {
                    console.warn(` Region ${r} has ${bracket[r].length} teams (expected 16)`);
                    // Trim excess if over, pad warning if under
                    while (bracket[r].length > 16) bracket[r].pop();
                }
            });

            // === Constraint A: Avoid same-conference R64 matchups ===
            if (bracketConfig.avoid_same_conf) {
                const r64Pairs = [[0,15],[7,8],[4,11],[3,12],[5,10],[2,13],[6,9],[1,14]];
                // Helper: check if swapping would create a new conflict in the target region
                const wouldCreateConflict = (otherRegionTeams, slotIdx, incomingConf) => {
                    for (const [pi1, pi2] of r64Pairs) {
                        if (pi1 === slotIdx || pi2 === slotIdx) {
                            const partnerIdx = pi1 === slotIdx ? pi2 : pi1;
                            if (otherRegionTeams[partnerIdx] && otherRegionTeams[partnerIdx].conf === incomingConf) return true;
                        }
                    }
                    return false;
                };

                regions.forEach(r => {
                    const teams = bracket[r];
                    r64Pairs.forEach(([i1, i2]) => {
                        if (!teams[i1] || !teams[i2]) return;
                        if (teams[i1].conf !== teams[i2].conf || teams[i1].conf === 'TBD') return;

                        // Try swapping either team (i2 first since it's the lower seed, then i1)
                        let fixed = false;
                        let attempts = 0;
                        for (const swapIdx of [i2, i1]) {
                            if (fixed) break;
                            for (const otherR of regions) {
                                if (otherR === r || fixed) continue;
                                if (attempts >= MAX_SWAP_ATTEMPTS) break;
                                attempts++;
                                const ot = bracket[otherR];
                                if (!ot[swapIdx] || ot[swapIdx].conf === 'TBD') continue;
                                // Candidate must not share conf with either team in the conflict
                                if (ot[swapIdx].conf === teams[i1].conf || ot[swapIdx].conf === teams[i2].conf) continue;
                                // Must not create a new conflict in the other region
                                if (wouldCreateConflict(ot, swapIdx, teams[swapIdx].conf)) continue;
                                // Must be same seed line
                                if (ot[swapIdx].seed !== teams[swapIdx].seed) continue;

                                swapLog.push(`Conf fix: ${teams[swapIdx].name} (${r}, ${teams[swapIdx].conf})  ${ot[swapIdx].name} (${otherR}, ${ot[swapIdx].conf})  avoid ${teams[i1].conf} R64 matchup at seeds ${teams[i1].seed}v${teams[i2].seed}`);
                                const temp = teams[swapIdx];
                                teams[swapIdx] = { ...ot[swapIdx], region: r };
                                ot[swapIdx] = { ...temp, region: otherR };
                                fixed = true;
                            }
                        }
                        if (!fixed) {
                            swapLog.push(` Could not resolve ${teams[i1].conf} conflict: ${teams[i1].name} (${teams[i1].seed}) vs ${teams[i2].name} (${teams[i2].seed}) in ${r} (${attempts}/${MAX_SWAP_ATTEMPTS} attempts)`);
                        }
                    });
                });
            }

            // === Constraint B: Balance top-4 seeds across regions ===
            if (bracketConfig.balance_regions) {
                const str = {};
                regions.forEach(r => { str[r] = bracket[r].filter(t => t.seed <= 4).reduce((s, t) => s + t.net, 0); });
                const maxR = regions.reduce((a, b) => str[a] > str[b] ? a : b);
                const minR = regions.reduce((a, b) => str[a] < str[b] ? a : b);
                const imb = str[maxR] - str[minR];
                if (imb > 10 && maxR !== minR) {
                    let bestSwap = null, bestImp = 0;
                    bracket[maxR].filter(t => t.seed >= 3 && t.seed <= 4).forEach(mt => {
                        bracket[minR].filter(t => t.seed === mt.seed).forEach(nt => {
                            const newImb = Math.abs((str[maxR] - mt.net + nt.net) - (str[minR] - nt.net + mt.net));
                            const imp = imb - newImb;
                            if (imp > bestImp) { bestImp = imp; bestSwap = { mt, nt }; }
                        });
                    });
                    if (bestSwap && bestImp > 2) {
                        const { mt, nt } = bestSwap;
                        const iMax = bracket[maxR].indexOf(mt);
                        const iMin = bracket[minR].indexOf(nt);
                        bracket[maxR][iMax] = { ...nt, region: maxR };
                        bracket[minR][iMin] = { ...mt, region: minR };
                        swapLog.push(`Balance: ${mt.name} (${maxR})  ${nt.name} (${minR})  reduced top-4 imbalance by ${bestImp.toFixed(1)} pts`);
                    }
                }

                // Post-swap region strength audit (always log)
                const finalStr = {};
                regions.forEach(r => { finalStr[r] = bracket[r].filter(t => t.seed <= 4).reduce((s, t) => s + t.net, 0); });
                const vals = Object.values(finalStr);
                const finalMax = Math.max(...vals), finalMin = Math.min(...vals);
                const finalGap = finalMax - finalMin;
                const regionSummary = regions.map(r => `${r}: ${finalStr[r].toFixed(1)}`).join(', ');
                swapLog.push(`Region audit: Top-4 strength  ${regionSummary} (gap: ${finalGap.toFixed(1)} pts${finalGap > 10 ? '  still elevated' : ' '})`);
            }

            bracketState.bracket = bracket;
            bracketState.swapLog = swapLog;
            return { bracket, swapLog };
        }

        // === STEP 5: Enhanced Game Simulation ===
        function getWinProb(t1, t2, dampFactor) {
            let diff = t1.net - t2.net;
            if (dampFactor != null && dampFactor < 1 && Math.abs(diff) > 10) {
                const excess = Math.abs(diff) - 10;
                diff = Math.sign(diff) * (10 + excess * dampFactor);
            }
            return 1 / (1 + Math.pow(10, -diff / 10));
        }

        function playGame(t1, t2, rng, dampFactor) {
            const prob1 = getWinProb(t1, t2, dampFactor);
            const rand = (rng || Math.random)();
            const winner = rand < prob1 ? t1 : t2;
            const loser = winner === t1 ? t2 : t1;
            return { t1, t2, winner, loser, prob1: prob1 * 100, prob2: (1 - prob1) * 100, isUpset: winner.seed > loser.seed };
        }

        function simulateRegion(teams, regionName, rng, dampFactor) {
            const r64Matchups = [[0,15],[7,8],[4,11],[3,12],[5,10],[2,13],[6,9],[1,14]];
            const r64Games = [], r32Teams = [];

            r64Matchups.forEach(([i1, i2]) => {
                let t1 = teams[i1], t2 = teams[i2];
                if (t1?.isFirstFour && t1.firstFourPairing) {
                    const ff = t1.firstFourPairing;
                    const ffR = playGame(ff.t1, ff.t2, rng, dampFactor);
                    t1 = { ...ffR.winner, seed: t1.seed, region: t1.region };
                    t1._ffGame = ffR;
                }
                if (t2?.isFirstFour && t2.firstFourPairing) {
                    const ff = t2.firstFourPairing;
                    const ffR = playGame(ff.t1, ff.t2, rng, dampFactor);
                    t2 = { ...ffR.winner, seed: t2.seed, region: t2.region };
                    t2._ffGame = ffR;
                }
                if (!t1 || !t2) return;
                const game = playGame(t1, t2, rng, dampFactor);
                r64Games.push(game);
                r32Teams.push(game.winner);
                if (game.isUpset) bracketState.upsets.push({ round: 'R64', region: regionName, ...game });
            });

            const r32Games = [], s16Teams = [];
            for (let i = 0; i < r32Teams.length; i += 2) {
                const g = playGame(r32Teams[i], r32Teams[i+1], rng, dampFactor);
                r32Games.push(g); s16Teams.push(g.winner);
                if (g.isUpset) bracketState.upsets.push({ round: 'R32', region: regionName, ...g });
            }
            const s16Games = [], e8Teams = [];
            for (let i = 0; i < s16Teams.length; i += 2) {
                const g = playGame(s16Teams[i], s16Teams[i+1], rng, dampFactor);
                s16Games.push(g); e8Teams.push(g.winner);
                if (g.isUpset) bracketState.upsets.push({ round: 'S16', region: regionName, ...g });
            }
            const e8Game = playGame(e8Teams[0], e8Teams[1], rng, dampFactor);
            if (e8Game.isUpset) bracketState.upsets.push({ round: 'E8', region: regionName, ...e8Game });

            return { r64: r64Games, r32: r32Games, s16: s16Games, e8: e8Game, winner: e8Game.winner };
        }

        function simulateTournament(bracket, rng, dampFactor) {
            bracketState.upsets = [];
            const results = { regions: {}, finalFour: {}, championship: null, champion: null };
            ['SOUTH','EAST','MIDWEST','WEST'].forEach(r => {
                results.regions[r] = simulateRegion(bracket[r].sort((a,b) => a.seed - b.seed), r, rng, dampFactor);
            });
            const sw = results.regions.SOUTH.winner, ew = results.regions.EAST.winner;
            const mw = results.regions.MIDWEST.winner, ww = results.regions.WEST.winner;
            if (sw && ew) { const s1 = playGame(sw, ew, rng, dampFactor); s1.label = 'SOUTH vs EAST'; results.finalFour.semi1 = s1; if (s1.isUpset) bracketState.upsets.push({ round: 'Final Four', ...s1 }); }
            if (mw && ww) { const s2 = playGame(mw, ww, rng, dampFactor); s2.label = 'MIDWEST vs WEST'; results.finalFour.semi2 = s2; if (s2.isUpset) bracketState.upsets.push({ round: 'Final Four', ...s2 }); }
            const f1 = results.finalFour.semi1?.winner, f2 = results.finalFour.semi2?.winner;
            if (f1 && f2) { const ch = playGame(f1, f2, rng, dampFactor); ch.label = 'CHAMPIONSHIP'; results.championship = ch; results.champion = ch.winner; if (ch.isUpset) bracketState.upsets.push({ round: 'Championship', ...ch }); }
            return results;
        }

        // === STEP 6: Monte Carlo ===
        function runMonteCarlo(bracket, nSims, rngSeed, dampFactor) {
            const teamStats = {};
            const allNames = [];
            Object.values(bracket).forEach(region => {
                region.forEach(t => {
                    if (t.isFirstFour && t.firstFourPairing) {
                        [t.firstFourPairing.t1, t.firstFourPairing.t2].forEach(ft => {
                            if (!teamStats[ft.name]) { teamStats[ft.name] = { titles: 0, ff: 0, e8: 0, s16: 0, r32: 0, wins: 0, seed: t.seed, conf: ft.conf }; allNames.push(ft.name); }
                        });
                    } else if (!t.isFirstFour) {
                        if (!teamStats[t.name]) { teamStats[t.name] = { titles: 0, ff: 0, e8: 0, s16: 0, r32: 0, wins: 0, seed: t.seed, conf: t.conf }; allNames.push(t.name); }
                    }
                });
            });

            for (let sim = 0; sim < nSims; sim++) {
                const rng = makeRng(rngSeed != null ? rngSeed + sim : null);
                const regionWinners = {};

                ['SOUTH','EAST','MIDWEST','WEST'].forEach(region => {
                    const regionTeams = bracket[region].map(t => {
                        const c = { ...t };
                        if (t.firstFourPairing) c.firstFourPairing = { ...t.firstFourPairing, t1: { ...t.firstFourPairing.t1 }, t2: { ...t.firstFourPairing.t2 } };
                        return c;
                    }).sort((a,b) => a.seed - b.seed);

                    const matchups = [[0,15],[7,8],[4,11],[3,12],[5,10],[2,13],[6,9],[1,14]];
                    const r64W = [];
                    matchups.forEach(([i1,i2]) => {
                        let t1 = regionTeams[i1], t2 = regionTeams[i2];
                        if (t1?.isFirstFour && t1.firstFourPairing) { const r = playGame(t1.firstFourPairing.t1, t1.firstFourPairing.t2, rng, dampFactor); t1 = { ...r.winner, seed: t1.seed, region }; }
                        if (t2?.isFirstFour && t2.firstFourPairing) { const r = playGame(t2.firstFourPairing.t1, t2.firstFourPairing.t2, rng, dampFactor); t2 = { ...r.winner, seed: t2.seed, region }; }
                        if (!t1 || !t2) return;
                        const g = playGame(t1, t2, rng, dampFactor);
                        r64W.push(g.winner);
                        if (teamStats[g.winner.name]) teamStats[g.winner.name].wins++;
                    });
                    const r32W = [];
                    for (let i = 0; i < r64W.length; i += 2) {
                        const g = playGame(r64W[i], r64W[i+1], rng, dampFactor);
                        r32W.push(g.winner);
                        if (teamStats[g.winner.name]) { teamStats[g.winner.name].wins++; teamStats[g.winner.name].r32++; }
                    }
                    const s16W = [];
                    for (let i = 0; i < r32W.length; i += 2) {
                        const g = playGame(r32W[i], r32W[i+1], rng, dampFactor);
                        s16W.push(g.winner);
                        if (teamStats[g.winner.name]) { teamStats[g.winner.name].wins++; teamStats[g.winner.name].s16++; }
                    }
                    const e8G = playGame(s16W[0], s16W[1], rng, dampFactor);
                    if (teamStats[e8G.winner.name]) { teamStats[e8G.winner.name].wins++; teamStats[e8G.winner.name].e8++; }
                    regionWinners[region] = e8G.winner;
                });

                ['SOUTH','EAST','MIDWEST','WEST'].forEach(r => { if (regionWinners[r] && teamStats[regionWinners[r].name]) teamStats[regionWinners[r].name].ff++; });

                if (regionWinners.SOUTH && regionWinners.EAST && regionWinners.MIDWEST && regionWinners.WEST) {
                    const s1 = playGame(regionWinners.SOUTH, regionWinners.EAST, rng, dampFactor);
                    if (teamStats[s1.winner.name]) teamStats[s1.winner.name].wins++;
                    const s2 = playGame(regionWinners.MIDWEST, regionWinners.WEST, rng, dampFactor);
                    if (teamStats[s2.winner.name]) teamStats[s2.winner.name].wins++;
                    const ch = playGame(s1.winner, s2.winner, rng, dampFactor);
                    if (teamStats[ch.winner.name]) { teamStats[ch.winner.name].wins++; teamStats[ch.winner.name].titles++; }
                }
            }

            const mcResults = allNames.map(name => ({
                name, seed: teamStats[name].seed, conf: teamStats[name].conf,
                titlePct: teamStats[name].titles / nSims * 100,
                ffPct: teamStats[name].ff / nSims * 100,
                e8Pct: teamStats[name].e8 / nSims * 100,
                s16Pct: teamStats[name].s16 / nSims * 100,
                r32Pct: teamStats[name].r32 / nSims * 100,
                avgWins: teamStats[name].wins / nSims
            })).sort((a, b) => b.titlePct - a.titlePct);

            bracketState.monteCarloResults = { nSims, results: mcResults };
            return bracketState.monteCarloResults;
        }

        // === ORCHESTRATOR ===
        function runBracketSimulation() {
            if (!Object.keys(state.ratings).length) { alert('Please load ratings data first'); return; }
            const statusEl = document.getElementById('bracketStatus');
            const nSims = parseInt(document.getElementById('simCountSelect').value);
            bracketConfig.n_sims = nSims;
            bracketConfig.use_auto_bids = document.getElementById('toggleAutoBids')?.checked ?? true;
            bracketConfig.first_four = document.getElementById('toggleFirstFour')?.checked ?? true;
            bracketConfig.avoid_same_conf = document.getElementById('toggleAvoidConf')?.checked ?? true;
            bracketConfig.balance_regions = document.getElementById('toggleBalance')?.checked ?? true;
            bracketConfig.mismatch_damp = parseFloat(document.getElementById('dampSlider')?.value ?? 0.85);
            bracketConfig.play_in_seed = parseInt(document.getElementById('playInSeedSelect')?.value ?? 11);
            bracketConfig.swap_limit = parseInt(document.getElementById('swapLimitInput')?.value ?? 3);
            const rngInput = document.getElementById('rngSeedInput')?.value;
            bracketConfig.rng_seed = rngInput ? parseInt(rngInput) : null;

            statusEl.innerHTML = '<div style="color:var(--accent-blue)"> Building field & simulating...</div>';

            setTimeout(() => {
                try {
                    const field = buildField();
                    const { teams: seeded, notes } = assignSeeds(field);
                    const { pairings, mainBracketTeams } = setupFirstFour(seeded);
                    const { bracket, swapLog } = buildBracket(mainBracketTeams, pairings);
                    bracketState.teams = bracket;

                    const rng = makeRng(bracketConfig.rng_seed);
                    const results = simulateTournament(bracket, rng, bracketConfig.mismatch_damp);
                    bracketState.results = results;

                    let mcResults = null;
                    if (nSims > 1) mcResults = runMonteCarlo(bracket, nSims, bracketConfig.rng_seed, bracketConfig.mismatch_damp);

                    renderFieldSelection(field);
                    renderFullBracket(results);
                    if (mcResults) renderMonteCarloResults(mcResults);
                    renderSwapLog(swapLog, notes);

                    const ct = bracketConfig.first_four ? 68 : 64;
                    const confCount = field.autoBids.length;
                    const alCount = field.atLarges.length;
                    statusEl.innerHTML = `<div style="color:var(--accent-green)"> ${ct}-team field (${confCount} AQ + ${alCount} AL)  ${bracketState.upsets.length} upsets  ${nSims.toLocaleString()} sims${swapLog.length ? `  ${swapLog.length} bracket swaps` : ''}${notes.length ? `  ${notes.length} tiebreaks` : ''}</div>`;
                } catch (e) {
                    console.error('Bracket error:', e);
                    statusEl.innerHTML = '<div style="color:var(--accent-red)"> Error: ' + e.message + '</div>';
                }
            }, 50);
        }

        // Contenders analysis (preserved)
        function analyzeContenders() {
            if (!Object.keys(state.ratings).length) { alert('Please load ratings data first'); return; }
            const section = document.getElementById('contendersSection');
            const grid = document.getElementById('contendersGrid');
            section.style.display = 'block';
            const allTeams = Object.values(state.ratings)
                .filter(t => t.netRating !== undefined && t.offRating !== undefined && t.defRating !== undefined)
                .map((t, idx) => ({ name: t.name, conf: t.conference, net: t.netRating, off: t.offRating, def: t.defRating, rank: idx + 1 }))
                .sort((a, b) => b.net - a.net);
            const byOff = [...allTeams].sort((a, b) => b.off - a.off);
            const byDef = [...allTeams].sort((a, b) => a.def - b.def);
            allTeams.forEach(t => { t.offRank = byOff.findIndex(x => x.name === t.name) + 1; t.defRank = byDef.findIndex(x => x.name === t.name) + 1; t.netRank = allTeams.findIndex(x => x.name === t.name) + 1; });
            const champ = allTeams.filter(t => t.offRank <= 20 && t.defRank <= 20).slice(0, 12);
            const ff4 = allTeams.filter(t => t.offRank <= 30 && t.defRank <= 30 && !champ.find(c => c.name === t.name)).slice(0, 10);
            const e8 = allTeams.filter(t => t.offRank <= 45 && t.defRank <= 45 && !champ.find(c => c.name === t.name) && !ff4.find(c => c.name === t.name)).slice(0, 10);
            const s16 = allTeams.filter(t => t.offRank <= 60 && t.defRank <= 60 && !champ.find(c => c.name === t.name) && !ff4.find(c => c.name === t.name) && !e8.find(c => c.name === t.name)).slice(0, 10);
            const renderList = (teams, title, color, icon) => {
                if (!teams.length) return '';
                return `<div class="info-card" style="border-top:3px solid ${color};"><h3 style="margin-bottom:0.75rem;">${icon} ${title}</h3><div style="font-size:0.8rem;">${teams.map((t, i) => `<div style="display:flex;justify-content:space-between;align-items:center;padding:0.4rem 0;border-bottom:1px solid var(--border-color);${i === teams.length - 1 ? 'border:none;' : ''}"><div style="font-weight:600;">${t.name}</div><div style="display:flex;gap:0.75rem;color:var(--text-secondary);font-size:0.75rem;"><span title="Net Rating Rank">#${t.netRank}</span><span title="Offense Rank" style="color:var(--accent-green);">O:${t.offRank}</span><span title="Defense Rank" style="color:var(--accent-blue);">D:${t.defRank}</span></div></div>`).join('')}</div></div>`;
            };
            grid.innerHTML = `${renderList(champ, 'Championship Contenders', 'gold', '')}${renderList(ff4, 'Final Four Contenders', 'silver', '')}${renderList(e8, 'Elite 8 Contenders', '#cd7f32', '')}${renderList(s16, 'Sweet 16 Potential', 'var(--accent-blue)', '')}`;
        }

        // === FIELD SELECTION RENDERING ===
        function renderFieldSelection(field) {
            const c = document.getElementById('fieldSelectionPanel');
            if (!c) return;
            c.style.display = 'block';
            const row = (t, ffTag) => {
                const badge = t.bidType === 'auto' ? '<span style="font-size:0.55rem;background:var(--accent-green);color:white;padding:1px 4px;border-radius:3px;margin-left:3px;">AQ</span>' : '<span style="font-size:0.55rem;background:var(--accent-blue);color:white;padding:1px 4px;border-radius:3px;margin-left:3px;">AL</span>';
                const ffBadge = ffTag ? `<span style="font-size:0.5rem;background:var(--accent-red);color:white;padding:1px 3px;border-radius:3px;margin-left:2px;font-family:JetBrains Mono,monospace;">${ffTag}</span>` : '';
                return `<div style="display:flex;justify-content:space-between;align-items:center;padding:0.25rem 0.4rem;border-bottom:1px solid var(--border-color);font-size:0.73rem;"><div style="display:flex;align-items:center;gap:0.3rem;"><span style="color:var(--text-muted);min-width:18px;font-family:JetBrains Mono,monospace;font-size:0.65rem;">${t.overallSeed}</span><span style="font-weight:600;">${t.name}</span>${badge}${ffBadge}</div><div style="display:flex;gap:0.6rem;color:var(--text-secondary);font-family:JetBrains Mono,monospace;font-size:0.65rem;"><span>${t.conf}</span><span style="color:${t.net > 0 ? 'var(--accent-green)' : 'var(--accent-red)'};">${t.net.toFixed(1)}</span></div></div>`;
            };

            // Identify First Four teams for tagging
            const ffPairings = bracketState.firstFour || [];
            const ffTagMap = {};
            if (bracketConfig.first_four && ffPairings.length === 4) {
                const piSeed = bracketConfig.play_in_seed;
                // 16-seed play-ins (AQ teams)
                const ff16 = ffPairings.filter(p => p.type === '16-seed');
                ff16.forEach((p, gi) => {
                    const letter = String.fromCharCode(97 + gi * 2); // a, c
                    const letter2 = String.fromCharCode(98 + gi * 2); // b, d
                    if (p.t1) ffTagMap[p.t1.name] = `16${letter}`;
                    if (p.t2) ffTagMap[p.t2.name] = `16${letter2}`;
                });
                // At-large play-ins
                const ffAL = ffPairings.filter(p => p.type === 'at-large');
                ffAL.forEach((p, gi) => {
                    const letter = String.fromCharCode(97 + gi * 2);
                    const letter2 = String.fromCharCode(98 + gi * 2);
                    if (p.t1) ffTagMap[p.t1.name] = `${piSeed}${letter}`;
                    if (p.t2) ffTagMap[p.t2.name] = `${piSeed}${letter2}`;
                });
            }

            // Bubble gap calculation
            const lastIn = field.lastFourIn[field.lastFourIn.length - 1];
            const firstOut = field.firstFourOut[0];
            const bubbleGap = (lastIn && firstOut) ? (lastIn.net - firstOut.net).toFixed(2) : '?';
            const bubbleInfo = `<div style="font-size:0.65rem;color:var(--text-muted);margin-top:0.4rem;padding:0.4rem;background:var(--bg-input);border-radius:6px;text-align:center;">Bubble gap: <strong style="color:var(--accent-theme);">${bubbleGap} pts</strong> between last in (${lastIn?.name || '?'}) and first out (${firstOut?.name || '?'})</div>`;

            // First Four panel
            const piSeed = bracketConfig.play_in_seed;
            let ffPanel = '';
            if (bracketConfig.first_four && ffPairings.length === 4) {
                const ffRow = (p, label) => {
                    if (!p.t1 || !p.t2) return '';
                    return `<div style="display:flex;align-items:center;gap:0.4rem;padding:0.3rem 0;border-bottom:1px solid var(--border-color);font-size:0.73rem;">
                        <span style="font-size:0.6rem;font-weight:700;color:var(--accent-red);min-width:22px;font-family:JetBrains Mono,monospace;">${label}</span>
                        <span style="font-weight:600;flex:1;">${p.t1.name} <span style="color:var(--text-muted);font-size:0.6rem;">(${p.t1.conf})</span></span>
                        <span style="color:var(--text-muted);font-size:0.6rem;">vs</span>
                        <span style="font-weight:600;flex:1;text-align:right;">${p.t2.name} <span style="color:var(--text-muted);font-size:0.6rem;">(${p.t2.conf})</span></span>
                    </div>`;
                };
                const ff16Games = ffPairings.filter(p => p.type === '16-seed');
                const ffALGames = ffPairings.filter(p => p.type === 'at-large');
                ffPanel = `<div style="background:var(--bg-input);border-radius:8px;padding:0.6rem;margin-top:0.75rem;border-left:3px solid var(--accent-red);">
                    <div style="font-size:0.7rem;font-weight:700;color:var(--accent-red);margin-bottom:0.4rem;"> FIRST FOUR PLAY-INS</div>
                    <div style="font-size:0.6rem;color:var(--text-muted);margin-bottom:0.3rem;font-weight:600;">16-SEED GAMES (lowest AQs)</div>
                    ${ff16Games.map((p, i) => ffRow(p, `16${String.fromCharCode(97 + i * 2)}/${String.fromCharCode(98 + i * 2)}`)).join('')}
                    <div style="font-size:0.6rem;color:var(--text-muted);margin:0.4rem 0 0.3rem;font-weight:600;">${piSeed}-SEED GAMES (lowest at-larges)</div>
                    ${ffALGames.map((p, i) => ffRow(p, `${piSeed}${String.fromCharCode(97 + i * 2)}/${String.fromCharCode(98 + i * 2)}`)).join('')}
                </div>`;
            }

            c.innerHTML = `<div class="info-card" style="margin-bottom:1rem;"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;"><h3 style="margin:0;"> Field of ${field.autoBids.length + field.atLarges.length}</h3><div style="font-size:0.75rem;color:var(--text-muted);">${field.autoBids.length} auto-bids  ${field.atLarges.length} at-large</div></div>
                <details style="margin-bottom:0.5rem;"><summary style="cursor:pointer;font-size:0.8rem;font-weight:600;color:var(--accent-theme);padding:0.3rem 0;"> Auto-Bids (${field.autoBids.length})</summary><div style="max-height:300px;overflow-y:auto;margin-top:0.25rem;">${field.autoBids.sort((a,b)=>b.net-a.net).map(t => row(t, ffTagMap[t.name])).join('')}</div></details>
                <details style="margin-bottom:0.5rem;"><summary style="cursor:pointer;font-size:0.8rem;font-weight:600;color:var(--accent-blue);padding:0.3rem 0;"> At-Large (${field.atLarges.length})</summary><div style="max-height:300px;overflow-y:auto;margin-top:0.25rem;">${field.atLarges.sort((a,b)=>b.net-a.net).map(t => row(t, ffTagMap[t.name])).join('')}</div></details>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.75rem;margin-top:0.75rem;">
                    <div style="background:var(--bg-input);border-radius:8px;padding:0.6rem;border-left:3px solid var(--accent-yellow);"><div style="font-size:0.7rem;font-weight:700;color:var(--accent-yellow);margin-bottom:0.4rem;">LAST 4 IN</div>${field.lastFourIn.map(t=>`<div style="font-size:0.73rem;padding:0.15rem 0;display:flex;justify-content:space-between;"><span>${t.name} <span style="color:var(--text-muted);font-size:0.6rem;">${t.conf}</span></span><span style="color:var(--text-muted);font-size:0.65rem;">${t.net.toFixed(1)}</span></div>`).join('')}</div>
                    <div style="background:var(--bg-input);border-radius:8px;padding:0.6rem;border-left:3px solid var(--accent-red);"><div style="font-size:0.7rem;font-weight:700;color:var(--accent-red);margin-bottom:0.4rem;">FIRST 4 OUT</div>${field.firstFourOut.map(t=>`<div style="font-size:0.73rem;padding:0.15rem 0;display:flex;justify-content:space-between;"><span>${t.name} <span style="color:var(--text-muted);font-size:0.6rem;">${t.conf}</span></span><span style="color:var(--text-muted);font-size:0.65rem;">${t.net.toFixed(1)}</span></div>`).join('')}</div>
                </div>${ffPanel}${bubbleInfo}</div>`;
        }

        // === MONTE CARLO RENDERING ===
        function renderMonteCarloResults(mc) {
            const c = document.getElementById('monteCarloPanel');
            if (!c) return;
            c.style.display = 'block';
            const top25 = mc.results.slice(0, 25);
            const maxT = Math.max(...top25.map(t => t.titlePct), 1);
            const th = (label) => `<th style="padding:0.35rem 0.25rem;color:var(--text-muted);font-size:0.6rem;white-space:nowrap;">${label}</th>`;
            c.innerHTML = `<div class="info-card"><h3 style="margin-bottom:0.75rem;"> Title Odds <span style="font-size:0.7rem;color:var(--text-muted);font-weight:400;">(${mc.nSims.toLocaleString()} sims)</span></h3><div style="overflow-x:auto;"><table style="width:100%;font-size:0.73rem;border-collapse:collapse;"><thead><tr style="border-bottom:2px solid var(--border-color);text-align:left;">${th('TEAM')}${th('CONF')}${th('SEED')}${th('')}${th('FF')}${th('E8')}${th('S16')}${th('R32')}${th('AVG W')}${th('')}</tr></thead><tbody>${top25.map((t,i) => {
                const mono = 'font-family:JetBrains Mono,monospace;';
                const bg = i < 4 ? 'background:var(--accent-green-dim);' : '';
                return `<tr style="border-bottom:1px solid var(--border-color);${bg}"><td style="padding:0.3rem 0.25rem;font-weight:600;white-space:nowrap;">${t.name}</td><td style="padding:0.3rem 0.25rem;color:var(--text-muted);font-size:0.65rem;">${t.conf || ''}</td><td style="padding:0.3rem 0.25rem;color:var(--text-muted);${mono}">${t.seed}</td><td style="padding:0.3rem 0.25rem;font-weight:700;color:var(--accent-green);${mono}">${t.titlePct.toFixed(1)}%</td><td style="padding:0.3rem 0.25rem;${mono}">${t.ffPct.toFixed(1)}%</td><td style="padding:0.3rem 0.25rem;${mono}">${t.e8Pct.toFixed(1)}%</td><td style="padding:0.3rem 0.25rem;${mono}">${(t.s16Pct||0).toFixed(1)}%</td><td style="padding:0.3rem 0.25rem;${mono}">${(t.r32Pct||0).toFixed(1)}%</td><td style="padding:0.3rem 0.25rem;${mono}">${t.avgWins.toFixed(1)}</td><td style="padding:0.3rem 0.25rem;min-width:70px;"><div style="background:var(--bg-input);border-radius:3px;height:12px;overflow:hidden;"><div style="height:100%;width:${(t.titlePct/maxT*100).toFixed(0)}%;background:var(--accent-green);border-radius:3px;"></div></div></td></tr>`;
            }).join('')}</tbody></table></div></div>`;
        }

        // === SWAP LOG RENDERING ===
        function renderSwapLog(swapLog, notes) {
            const c = document.getElementById('swapLogPanel');
            if (!c) return;
            const tbWindowNote = (notes || []).filter(n => n.startsWith('Tiebreak window'));
            const tiebreaks = (notes || []).filter(n => n.startsWith('Tiebreak:') || n.startsWith('Tiebreak stab'));
            const confFixes = (swapLog || []).filter(n => n.startsWith('Conf fix') || n.startsWith(''));
            const balFixes = (swapLog || []).filter(n => n.startsWith('Balance'));
            const regionAudit = (swapLog || []).filter(n => n.startsWith('Region audit'));
            c.style.display = 'block';
            const section = (title, items, color) => {
                if (!items.length) return '';
                return `<div style="margin-bottom:0.6rem;"><div style="font-size:0.7rem;font-weight:700;color:${color};margin-bottom:0.3rem;text-transform:uppercase;">${title} (${items.length})</div>${items.map(n => `<div style="font-size:0.73rem;padding:0.2rem 0;color:var(--text-secondary);border-bottom:1px solid var(--border-color);"> ${n}</div>`).join('')}</div>`;
            };
            const tbWin = bracketState.field?.tiebreakWindow;
            const tbStd = bracketState.field?.stddev;
            const damp = bracketConfig.mismatch_damp;
            const methodology = `<div style="margin-top:0.75rem;padding-top:0.5rem;border-top:1px solid var(--border-color);font-size:0.7rem;color:var(--text-muted);line-height:1.6;">
                <strong style="color:var(--text-secondary);">Methodology</strong><br>
                <span style="color:var(--text-secondary);">Field:</span> Top ${bracketConfig.first_four ? 68 : 64} teams by net rating. ${bracketConfig.use_auto_bids ? 'Auto-bids: best net rating per conference (proxy for conf champ).' : 'No auto-bids.'}<br>
                <span style="color:var(--text-secondary);">Seeding:</span> S-curve with serpentine. Adaptive tiebreak window: <strong>${tbWin ? tbWin.toFixed(3) : '?'} pts</strong> (0.15  =${tbStd ? tbStd.toFixed(2) : '?'})  prefer stronger conference median.<br>
                ${bracketConfig.avoid_same_conf ? `<span style="color:var(--text-secondary);">Conf conflicts:</span> Same-seed-line swaps across regions. Max <strong>${bracketConfig.swap_limit}</strong> attempts per conflict before logging and preserving bracket integrity.<br>` : ''}
                ${bracketConfig.balance_regions ? '<span style="color:var(--text-secondary);">Region balance:</span> Top-4 seed net rating sum checked; one protected 3/4-seed swap allowed if gap >10 pts. Post-swap audit logged.<br>' : ''}
                <span style="color:var(--text-secondary);">Simulation:</span> Log5 win probability. Mismatch dampening: <strong>${damp.toFixed(2)}</strong>${damp < 1 ? ` (gaps >10 pts compressed by ${((1 - damp) * 100).toFixed(0)}%)` : ' (disabled, no compression)'}. RNG: ${bracketConfig.rng_seed != null ? `seeded (${bracketConfig.rng_seed})` : 'unseeded (random)'}.
            </div>`;
            c.innerHTML = `<div class="info-card" style="border-left:3px solid var(--accent-blue);"><h3 style="margin-bottom:0.5rem;font-size:0.85rem;"> Adjustments & Notes</h3>${section('Seed Tiebreaks', [...tbWindowNote, ...tiebreaks], 'var(--accent-yellow)')}${section('Conference Conflict Resolution', confFixes, 'var(--accent-blue)')}${section('Region Balancing', [...balFixes, ...regionAudit], 'var(--accent-green)')}${methodology}</div>`;
        }

        // === BRACKET RENDERING ===
        function renderFullBracket(results) {
            const wrapper = document.getElementById('bracketWrapper');
            const statsBar = document.getElementById('bracketStatsBar');
            const champion = results.champion;
            bracketState.results = results;
            statsBar.style.display = 'flex';
            statsBar.innerHTML = `<div class="bracket-stat"><div class="bracket-stat-value green">${champion?.name || 'TBD'}</div><div class="bracket-stat-label"> Champion (${champion?.seed} seed)</div></div><div class="bracket-stat"><div class="bracket-stat-value red">${bracketState.upsets.length}</div><div class="bracket-stat-label">Upsets</div></div><div class="bracket-stat"><div class="bracket-stat-value">${results.championship?.prob1?.toFixed(0) || '-'}%</div><div class="bracket-stat-label">Champ Win Prob</div></div><div class="bracket-stat"><div class="bracket-stat-value">${bracketConfig.mismatch_damp.toFixed(2)}</div><div class="bracket-stat-label">Upset Damp</div></div>`;
            wrapper.innerHTML = `<div class="bracket-container">${renderFinalFourTop(results)}<div class="bracket-quadrants"><div class="bracket-quadrant">${renderRegionQuadrant(results.regions.SOUTH, 'SOUTH', false)}</div><div class="bracket-quadrant">${renderRegionQuadrant(results.regions.EAST, 'EAST', true)}</div><div class="bracket-quadrant">${renderRegionQuadrant(results.regions.MIDWEST, 'MIDWEST', false)}</div><div class="bracket-quadrant">${renderRegionQuadrant(results.regions.WEST, 'WEST', true)}</div></div></div><div class="bracket-legend"><div class="bracket-legend-item"><div class="bracket-legend-box" style="background:var(--accent-green-dim);border:1px solid var(--accent-green);"></div> Winner</div><div class="bracket-legend-item"><div class="bracket-legend-box" style="background:var(--accent-red-dim);border:2px solid var(--accent-red);"></div> Upset</div><div class="bracket-legend-item" style="margin-left:1rem;font-style:italic;">Click any game for analysis</div></div>`;
        }

        function renderFinalFourTop(results) {
            const semi1 = results.finalFour.semi1, semi2 = results.finalFour.semi2, champ = results.championship, champion = results.champion;
            if (semi1) { semi1.gameId = 'FF-semi1-0'; semi1.round = 'Final Four'; }
            if (semi2) { semi2.gameId = 'FF-semi2-0'; semi2.round = 'Final Four'; }
            if (champ) { champ.gameId = 'FF-champ-0'; champ.round = 'Championship'; }
            const ffG = (game, label, id) => {
                if (!game) return `<div class="bracket-ff-game"><div class="bracket-ff-label">${label}</div><div style="text-align:center;color:var(--text-muted);font-size:0.7rem;">TBD</div></div>`;
                const t1W = game.winner.name === game.t1.name;
                return `<div class="bracket-ff-game ${game.isUpset ? 'upset' : ''}" onclick="showGameAnalysis('${id}')" style="cursor:pointer;"><div class="bracket-ff-label">${label}</div><div class="bracket-game-team ${t1W ? 'winner' : 'loser'}" style="padding:5px 8px;"><span class="bracket-game-seed">${game.t1.seed}</span><span class="bracket-game-name" style="font-size:0.7rem;">${game.t1.name}</span><span class="bracket-game-prob">${game.prob1.toFixed(0)}%</span></div><div class="bracket-game-team ${!t1W ? 'winner' : 'loser'}" style="padding:5px 8px;"><span class="bracket-game-seed">${game.t2.seed}</span><span class="bracket-game-name" style="font-size:0.7rem;">${game.t2.name}</span><span class="bracket-game-prob">${game.prob2.toFixed(0)}%</span></div></div>`;
            };
            const cBox = champion ? `<div class="bracket-champ-box"><div class="bracket-champ-label"> NATIONAL CHAMPION</div><div class="bracket-champ-team">${champion.name}</div><div class="bracket-champ-seed">(${champion.seed} seed) ${champion.region}</div></div>` : '';
            return `<div class="bracket-ff-top"><div class="bracket-ff-title">FINAL FOUR & CHAMPIONSHIP</div><div class="bracket-ff-row">${ffG(semi1, 'SEMIFINAL 1', 'FF-semi1-0')}${cBox}${ffG(semi2, 'SEMIFINAL 2', 'FF-semi2-0')}</div><div class="bracket-ff-row" style="margin-top:0.75rem;">${ffG(champ, 'CHAMPIONSHIP GAME', 'FF-champ-0')}</div></div>`;
        }

        function renderRegionQuadrant(region, name, flip) {
            const gH = (game, round, idx) => {
                if (!game) return '';
                const t1W = game.winner.name === game.t1.name;
                const gid = `${name}-${round}-${idx}`;
                return `<div class="bracket-game ${game.isUpset ? 'upset' : ''}" onclick="showGameAnalysis('${gid}')" data-game-id="${gid}"><div class="bracket-game-team ${t1W ? 'winner' : 'loser'}"><span class="bracket-game-seed">${game.t1.seed}</span><span class="bracket-game-name">${game.t1.name}</span><span class="bracket-game-prob">${game.prob1.toFixed(0)}%</span></div><div class="bracket-game-team ${!t1W ? 'winner' : 'loser'}"><span class="bracket-game-seed">${game.t2.seed}</span><span class="bracket-game-name">${game.t2.name}</span><span class="bracket-game-prob">${game.prob2.toFixed(0)}%</span></div></div>`;
            };
            region.r64.forEach((g,i) => { g.gameId = `${name}-r64-${i}`; g.round = 'Round of 64'; });
            region.r32.forEach((g,i) => { g.gameId = `${name}-r32-${i}`; g.round = 'Round of 32'; });
            region.s16.forEach((g,i) => { g.gameId = `${name}-s16-${i}`; g.round = 'Sweet 16'; });
            if (region.e8) { region.e8.gameId = `${name}-e8-0`; region.e8.round = 'Elite 8'; }
            const mc = (rn, lb, gms, pc) => `<div class="bracket-round-col ${pc}"><div class="bracket-round-title">${lb}</div><div class="bracket-games-col">${gms}</div></div>`;
            const r64 = mc('r64','R64',region.r64.map((g,i)=>gH(g,'r64',i)).join(''),'r64');
            const r32 = mc('r32','R32',region.r32.map((g,i)=>gH(g,'r32',i)).join(''),'r32');
            const s16 = mc('s16','S16',region.s16.map((g,i)=>gH(g,'s16',i)).join(''),'s16');
            const e8 = mc('e8','E8',gH(region.e8,'e8',0),'e8');
            return `<div class="bracket-region-title">${name} REGION</div><div class="bracket-rounds-row">${flip ? e8+s16+r32+r64 : r64+r32+s16+e8}</div>`;
        }

        function findGameById(gameId) {
            const r = bracketState.results; if (!r) return null;
            const [region, round, idx] = gameId.split('-');
            const i = parseInt(idx);
            if (region === 'FF') { if (round === 'semi1') return r.finalFour.semi1; if (round === 'semi2') return r.finalFour.semi2; if (round === 'champ') return r.championship; }
            else { const reg = r.regions[region]; if (!reg) return null; if (round === 'r64') return reg.r64[i]; if (round === 'r32') return reg.r32[i]; if (round === 's16') return reg.s16[i]; if (round === 'e8') return reg.e8; }
            return null;
        }

        function generateGameAnalysis(game) {
            const t1 = game.t1, t2 = game.t2, winner = game.winner, loser = game.loser;
            const netDiff = (t1.net - t2.net).toFixed(1);
            let analysis = '';
            if (game.isUpset) {
                analysis = `Upset! ${winner.name} (${winner.seed}) over ${loser.name} (${loser.seed}). `;
                analysis += Math.abs(parseFloat(netDiff)) < 5 ? `Only ${Math.abs(parseFloat(netDiff)).toFixed(1)} pts apart in net rating.` : `Had a ${(game.winner === t1 ? game.prob1 : game.prob2).toFixed(0)}% chance.`;
            } else {
                if (game.prob1 > 85 || game.prob2 > 85) analysis = `${winner.name} dominates. Superior ${winner.off > loser.off ? 'offense' : 'defense'} was too much.`;
                else if (game.prob1 > 65 || game.prob2 > 65) analysis = `${winner.name} advances. Net rating edge of ${Math.abs(parseFloat(netDiff))} pts proved decisive.`;
                else analysis = `Close one  ${winner.name} wins with only ${Math.abs(parseFloat(netDiff)).toFixed(1)} pts separating them.`;
            }
            const mc = bracketState.monteCarloResults;
            if (mc) { const w = mc.results.find(r=>r.name===winner.name), l = mc.results.find(r=>r.name===loser.name); if (w && l) analysis += ` Title odds: ${winner.name} ${w.titlePct.toFixed(1)}%, ${loser.name} ${l.titlePct.toFixed(1)}%.`; }
            return { text: analysis, factors: [{ label: 'Net Rating', t1: t1.net.toFixed(1), t2: t2.net.toFixed(1) },{ label: 'Offense', t1: t1.off.toFixed(1), t2: t2.off.toFixed(1) },{ label: 'Defense', t1: t1.def.toFixed(1), t2: t2.def.toFixed(1) },{ label: 'Win Prob', t1: game.prob1.toFixed(0)+'%', t2: game.prob2.toFixed(0)+'%' }] };
        }

        function showGameAnalysis(gameId) {
            const game = findGameById(gameId); if (!game) return;
            const analysis = generateGameAnalysis(game);
            const t1Win = game.winner.name === game.t1.name;
            const modal = document.createElement('div');
            modal.className = 'bracket-analysis-modal';
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
            modal.innerHTML = `<div class="bracket-analysis-content"><div class="bracket-analysis-header"><div class="bracket-analysis-title">${game.round || 'Game'} Analysis</div><button class="bracket-analysis-close" onclick="this.closest('.bracket-analysis-modal').remove()"></button></div><div class="bracket-analysis-matchup"><div class="bracket-analysis-team ${t1Win ? 'winner' : ''}"><div class="bracket-analysis-seed">${game.t1.seed} seed</div><div class="bracket-analysis-name">${game.t1.name}</div><div class="bracket-analysis-prob">${game.prob1.toFixed(0)}%</div></div><div class="bracket-analysis-vs">VS</div><div class="bracket-analysis-team ${!t1Win ? 'winner' : ''}"><div class="bracket-analysis-seed">${game.t2.seed} seed</div><div class="bracket-analysis-name">${game.t2.name}</div><div class="bracket-analysis-prob">${game.prob2.toFixed(0)}%</div></div></div><div class="bracket-analysis-text">${analysis.text}</div><div class="bracket-analysis-factors"><div class="bracket-analysis-factor" style="font-weight:600;color:var(--text-muted);"><span>Metric</span><span>${game.t1.name.substring(0,10)}</span><span>${game.t2.name.substring(0,10)}</span></div>${analysis.factors.map(f=>`<div class="bracket-analysis-factor"><span>${f.label}</span><span style="${t1Win?'font-weight:600;':''}">${f.t1}</span><span style="${!t1Win?'font-weight:600;':''}">${f.t2}</span></div>`).join('')}</div></div>`;
            document.body.appendChild(modal);
        }

        function switchTab(tab) {
            // Update tab buttons - remove active and update aria-selected
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');

            // Activate selected tab
            const tabBtn = document.getElementById(`tab${tab.charAt(0).toUpperCase() + tab.slice(1)}`);
            if (tabBtn) {
                tabBtn.classList.add('active');
                tabBtn.setAttribute('aria-selected', 'true');
            }

            // Show selected content
            const tabContent = document.getElementById(`${tab}Tab`);
            if (tabContent) {
                tabContent.style.display = 'block';
                tabContent.setAttribute('role', 'tabpanel');
            }

            // Show/hide global confidence legend based on tab (only for Games and Best Bets)
            const globalLegend = document.getElementById('globalConfidenceLegend');
            if (globalLegend) {
                if (tab === 'games' || tab === 'bestbets') {
                    // Don't force show  let user toggle decide. Just don't hide it.
                } else {
                    globalLegend.classList.remove('visible');
                }
            }

            // Render content if needed
            if (tab === 'bestbets') renderBestBets();
            if (tab === 'rankings') renderRankings();
            if (tab === 'analytics') renderAnalytics();
            if (tab === 'validation') renderPredictionTracker();
            if (tab === 'tracked') renderTrackedBetsTab();
        }

        // ===== Tab Badge Updates =====
        function updateTabBadges(filteredGames) {
            try {
                const gamesCount = (filteredGames || state.games || []).length;
                const gEl = document.getElementById('tabGamesCount');
                if (gEl) gEl.textContent = gamesCount || '';

                // Count best bets (62%+ win prob picks)
                let bbCount = 0;
                (state.games || []).forEach(g => {
                    const a = g.analysis;
                    if (!a) return;
                    if (a.spreadPick && (a.spreadWinProb || 0) >= 62) bbCount++;
                    if (a.totalPick && (a.totalWinProb || 0) >= 62) bbCount++;
                });
                const bEl = document.getElementById('tabBetsCount');
                if (bEl) bEl.textContent = bbCount || '';
            } catch (e) { /* silent */ }
        }

        // ===== Sticky Tab Bar Observer =====
        (function initStickyTabs() {
            const tabs = document.querySelector('.tabs-container');
            if (!tabs) return;
            const sentinel = document.createElement('div');
            sentinel.style.height = '1px';
            sentinel.style.visibility = 'hidden';
            tabs.parentNode.insertBefore(sentinel, tabs);
            const observer = new IntersectionObserver(([entry]) => {
                tabs.classList.toggle('stuck', !entry.isIntersecting);
            }, { threshold: 0, rootMargin: '0px' });
            observer.observe(sentinel);
        })();

        // ===== Games At-A-Glance Summary Bar (3B) =====
        function renderGamesSummaryBar(games) {
            const bar = document.getElementById('gamesSummaryBar');
            if (!bar || !games?.length) { if (bar) bar.innerHTML = ''; return; }
            
            const total = games.length;
            let bestBetCount = 0, spreadPicks = 0, totalPicks = 0;
            games.forEach(g => {
                const a = g.analysis;
                if (!a) return;
                const minP = gamesFilters?.minProb || 54;
                if (a.spreadPick && a.spreadEdge >= 2 && (a.spreadWinProb||0) >= minP) spreadPicks++;
                if (a.totalPick && a.totalEdge >= 3 && (a.totalWinProb||0) >= minP) totalPicks++;
                const bestProb = Math.max(
                    (a.spreadPick && a.spreadEdge >= 2) ? (a.spreadWinProb||0) : 0,
                    (a.totalPick && a.totalEdge >= 3) ? (a.totalWinProb||0) : 0
                );
                if (bestProb >= 62) bestBetCount++;
            });
            
            bar.innerHTML = `
                <div class="games-summary-chip"><strong>${total}</strong> Games</div>
                ${bestBetCount > 0 ? `<div class="games-summary-chip highlight"><strong>${bestBetCount}</strong> Best Bets</div>` : ''}
                <div class="games-summary-chip"><strong>${spreadPicks}</strong> Spread Picks</div>
                <div class="games-summary-chip"><strong>${totalPicks}</strong> Total Picks</div>
            `;
        }

        // ===== Best Bets Quick Stats Bar (4B) =====
        function renderBBQuickStats(picks) {
            const el = document.getElementById('bbQuickStats');
            if (!el) return;
            if (!picks?.length) { el.innerHTML = ''; return; }
            
            const avgWP = picks.reduce((s, p) => s + p.winProb, 0) / picks.length;
            const best = picks[0];
            const todayCount = picks.filter(p => {
                if (!p.game?.commenceTime) return false;
                const d = p.game.commenceTime;
                const now = new Date();
                return d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate();
            }).length;
            
            el.innerHTML = `
                <div class="bb-quick-stat"><strong>${picks.length}</strong> picks</div>
                ${todayCount > 0 ? `<div class="bb-quick-stat"><strong>${todayCount}</strong> today</div>` : ''}
                <div class="bb-quick-stat">Avg: <strong>${avgWP.toFixed(1)}%</strong></div>
                <div class="bb-quick-stat">Top: <strong>${best.pick}</strong> (${best.winProb.toFixed(0)}%)</div>
            `;
        }

        // ===== Rankings Search (5A) =====
        let rankingsSearchTerm = '';
        function filterRankingsBySearch(value) {
            rankingsSearchTerm = value.trim().toLowerCase();
            renderRankings();
        }

        // ===== Track Pick Button (4D) =====
        async function trackPick(gameId, pickType, btn) {
            try {
                const predId = `track_${gameId}_${pickType}`;
                
                // Check if already tracked - if so, untrack
                if (btn.classList.contains('tracked')) {
                    await deletePrediction(predId);
                    btn.innerHTML = ' Track';
                    btn.classList.remove('tracked');
                    updateTrackedBadge();
                    return;
                }
                
                const game = state.games.find(g => g.id === gameId);
                if (!game || !game.analysis) return;
                const a = game.analysis;
                const pick = pickType === 'spread' ? a.spreadPick : a.totalPick;
                if (!pick) return;
                
                const wp = pickType === 'spread' ? (a.spreadWinProb || 50) : (a.totalWinProb || 50);
                const edge = pickType === 'spread' ? (a.spreadEdge || 0) : (a.totalEdge || 0);
                const isBB = wp >= (typeof TIER_THRESHOLDS !== 'undefined' ? TIER_THRESHOLDS.BEST_BET : 62);
                
                const prediction = {
                    id: predId,
                    gameId: gameId,
                    gameDate: game.commenceTime ? game.commenceTime.toISOString() : new Date().toISOString(),
                    homeTeam: game.homeTeam,
                    awayTeam: game.awayTeam,
                    pickType: pickType,
                    pickTeam: pick.team || pick.pick || '',
                    pickLine: pick.line || 0,
                    pickDisplay: `${pick.team || pick.pick} ${pick.line || ''}`.trim(),
                    winProb: wp,
                    confidence: 50 + edge * 2,
                    edge: edge,
                    isBestBet: isBB,
                    bestBetRating: isBB && typeof getEliteRating === 'function' ? getEliteRating(wp) : 0,
                    status: 'pending',
                    result: null,
                    trackedAt: new Date().toISOString()
                };
                
                if (typeof savePrediction === 'function') {
                    await savePrediction(prediction);
                }
                
                btn.innerHTML = '<span class="track-label"> Tracked</span><span class="untrack-label"> Untrack</span>';
                btn.classList.add('tracked');
                updateTrackedBadge();
            } catch (e) {
                console.error('Track pick error:', e);
                btn.textContent = ' Error';
            }
        }

        // ===== Tracked Bets Tab (7-Day Strip) =====
        let trackedWeekOffset = 0; // 0 = current week ending today, -7 = previous week, etc.
        let trackedSelectedDate = null; // currently selected date string 'YYYY-MM-DD'
        let trackedAllPicks = []; // cache of all tracked predictions

        function getDateString(date) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        function getTodayString() {
            return getDateString(new Date());
        }

        function getTrackedDateForPick(p) {
            // Use gameDate (when the game is) to group by day
            if (p.gameDate) {
                const d = new Date(p.gameDate);
                return getDateString(d);
            }
            // Fallback to trackedAt
            if (p.trackedAt) {
                return getDateString(new Date(p.trackedAt));
            }
            return getTodayString();
        }

        async function loadTrackedPicks() {
            try {
                const all = await getAllPredictions();
                trackedAllPicks = all.filter(p => p.trackedAt);
            } catch (e) {
                console.warn('Could not load tracked picks:', e);
                trackedAllPicks = [];
            }
        }

        function getPicksForDate(dateStr) {
            return trackedAllPicks
                .filter(p => getTrackedDateForPick(p) === dateStr)
                .sort((a, b) => (b.winProb || 0) - (a.winProb || 0));
        }

        function getPickCountByDate() {
            const counts = {};
            trackedAllPicks.forEach(p => {
                const d = getTrackedDateForPick(p);
                counts[d] = (counts[d] || 0) + 1;
            });
            return counts;
        }

        function renderDayStrip() {
            const container = document.getElementById('trackedDayCards');
            if (!container) return;

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayStr = getDateString(today);

            // Build 7 days: offset determines the end date
            // offset=0 means the strip ends at today
            // offset=-7 means the strip ends 7 days before today
            const endDate = new Date(today);
            endDate.setDate(endDate.getDate() + trackedWeekOffset);
            
            const days = [];
            for (let i = 6; i >= 0; i--) {
                const d = new Date(endDate);
                d.setDate(d.getDate() - i);
                days.push(d);
            }

            const counts = getPickCountByDate();
            const dows = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            // Default selection: today if visible, otherwise the last day in strip
            if (!trackedSelectedDate) {
                trackedSelectedDate = todayStr;
            }
            // If selected date isn't in this strip, select the last day
            const stripDates = days.map(d => getDateString(d));
            if (!stripDates.includes(trackedSelectedDate)) {
                trackedSelectedDate = stripDates[stripDates.length - 1];
            }

            container.innerHTML = days.map(d => {
                const ds = getDateString(d);
                const isToday = ds === todayStr;
                const isActive = ds === trackedSelectedDate;
                const count = counts[ds] || 0;
                const dow = dows[d.getDay()];
                const dateNum = `${d.getMonth() + 1}/${d.getDate()}`;

                return `<div class="tracked-day-card ${isActive ? 'active' : ''} ${isToday ? 'today' : ''}" onclick="selectTrackedDay('${ds}')">
                    <div class="tracked-day-card-dow">${isToday ? 'Today' : dow}</div>
                    <div class="tracked-day-card-date">${dateNum}</div>
                    ${count > 0 ? `<div class="tracked-day-card-count">${count} pick${count !== 1 ? 's' : ''}</div>` : ''}
                    ${count > 0 && !isActive ? '<div class="tracked-day-card-dot"></div>' : ''}
                </div>`;
            }).join('');

            // Disable forward arrow if strip already contains today
            const fwdBtn = document.getElementById('trackedDayForward');
            if (fwdBtn) {
                fwdBtn.disabled = trackedWeekOffset >= 0;
            }
        }

        function selectTrackedDay(dateStr) {
            trackedSelectedDate = dateStr;
            renderDayStrip();
            renderTrackedPicksForDay();
        }

        function shiftTrackedWeek(delta) {
            trackedWeekOffset += delta;
            if (trackedWeekOffset > 0) trackedWeekOffset = 0;
            trackedSelectedDate = null; // auto-select
            renderDayStrip();
            renderTrackedPicksForDay();
        }

        // Get the effective W/L result for a tracked pick:
        // Auto-graded result takes priority, then manual, then null
        function getEffectiveResult(pick) {
            if (pick.status === 'graded' && pick.result) return { result: pick.result, source: 'auto' };
            if (pick.manualResult) return { result: pick.manualResult, source: 'manual' };
            return null;
        }

        // Set manual W/L result on a tracked pick
        async function setTrackedResult(gameId, pickType, result) {
            try {
                const all = await getAllPredictions();
                const pred = all.find(p => p.gameId === gameId && p.pickType === pickType && p.trackedAt);
                if (!pred) return;
                // Don't allow manual override if already auto-graded
                if (pred.status === 'graded' && pred.result) return;
                // Toggle: if already set to this result, clear it
                pred.manualResult = (pred.manualResult === result) ? null : result;
                await savePrediction(pred);
                await loadTrackedPicks();
                renderTrackedPicksForDay();
            } catch (e) {
                console.error('Set tracked result error:', e);
            }
        }

        function renderTrackedPicksForDay() {
            const grid = document.getElementById('trackedBetsGrid');
            const summaryEl = document.getElementById('trackedDaySummary');
            if (!grid) return;

            const picks = getPicksForDate(trackedSelectedDate);
            const isToday = trackedSelectedDate === getTodayString();

            // Update clear button label
            const clearBtn = document.getElementById('trackedClearDayBtn');
            if (clearBtn) {
                clearBtn.textContent = isToday ? ' Clear Today' : ' Clear Day';
            }

            if (!picks.length) {
                if (summaryEl) summaryEl.style.display = 'none';
                const dateObj = new Date(trackedSelectedDate + 'T12:00:00');
                const dateLabel = isToday ? 'today' : dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                grid.innerHTML = `<div class="bb-empty-state" style="grid-column:1/-1;">
                    <div class="bb-empty-icon"></div>
                    <div class="bb-empty-title">No tracked picks for ${dateLabel}</div>
                    <div class="bb-empty-text">${isToday ? 'Use the  Track button on any pick in the Games or Best Bets tab.' : 'You didn\'t track any picks this day.'}</div>
                </div>`;
                return;
            }

            // Summary
            const spreads = picks.filter(p => p.pickType === 'spread').length;
            const totals = picks.filter(p => p.pickType === 'total').length;
            const bestBets = picks.filter(p => p.isBestBet).length;
            const results = picks.map(p => getEffectiveResult(p)).filter(Boolean);
            const wins = results.filter(r => r.result === 'win').length;
            const losses = results.filter(r => r.result === 'loss').length;
            const pushes = results.filter(r => r.result === 'push').length;
            const pending = picks.length - results.length;

            if (summaryEl) {
                summaryEl.style.display = 'flex';
                const recordStr = (wins || losses || pushes) 
                    ? `<div class="tracked-summary-stat" style="font-weight:700;${wins > losses ? 'color:var(--accent-green);' : wins < losses ? 'color:var(--accent-red);' : ''}">
                        ${wins}W-${losses}L${pushes ? `-${pushes}P` : ''}${pending ? ` <span style="font-weight:400;color:var(--text-muted);font-size:0.7rem;">(${pending} pending)</span>` : ''}
                       </div>` 
                    : '';
                summaryEl.innerHTML = `
                    <div class="tracked-summary-stat"> <strong>${picks.length}</strong> pick${picks.length !== 1 ? 's' : ''}</div>
                    ${recordStr}
                    ${spreads ? `<div class="tracked-summary-stat"> <strong>${spreads}</strong> spread${spreads !== 1 ? 's' : ''}</div>` : ''}
                    ${totals ? `<div class="tracked-summary-stat"> <strong>${totals}</strong> total${totals !== 1 ? 's' : ''}</div>` : ''}
                    ${bestBets ? `<div class="tracked-summary-stat"> <strong>${bestBets}</strong> best bet${bestBets !== 1 ? 's' : ''}</div>` : ''}
                `;
            }

            // Render pick cards
            grid.innerHTML = picks.map((p, i) => {
                const tier = getWinProbClass(p.winProb || 50);
                const typeLabel = p.pickType === 'spread' ? 'SPR' : 'O/U';
                const pickDisplay = p.pickDisplay || `${p.pickTeam} ${p.pickLine || ''}`.trim();
                const matchup = `${p.awayTeam || '?'} @ ${p.homeTeam || '?'}`;
                const gameDate = p.gameDate ? new Date(p.gameDate) : null;
                const timeStr = gameDate ? gameDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) : '';

                // W/L result display
                const eff = getEffectiveResult(p);
                const isAutoGraded = p.status === 'graded' && p.result;
                const resultClass = eff ? `result-${eff.result}` : '';
                const escGid = p.gameId.replace(/'/g, "\\'");
                
                let resultHTML = '';
                if (isAutoGraded) {
                    // Locked auto-graded result
                    const label = p.result === 'win' ? 'W' : p.result === 'loss' ? 'L' : 'P';
                    resultHTML = `<div class="tracked-card-result">
                        <div class="tracked-result-locked ${p.result}">${label}</div>
                        <div class="tracked-result-source auto">Final</div>
                    </div>`;
                } else {
                    // Manual W/L/P toggles
                    const mr = p.manualResult || '';
                    resultHTML = `<div class="tracked-card-result">
                        <div class="tracked-result-btns">
                            <button class="tracked-result-btn ${mr === 'win' ? 'win-active' : ''}" onclick="setTrackedResult('${escGid}','${p.pickType}','win')">W</button>
                            <button class="tracked-result-btn ${mr === 'loss' ? 'loss-active' : ''}" onclick="setTrackedResult('${escGid}','${p.pickType}','loss')">L</button>
                            <button class="tracked-result-btn ${mr === 'push' ? 'push-active' : ''}" onclick="setTrackedResult('${escGid}','${p.pickType}','push')">P</button>
                        </div>
                        <div class="tracked-result-source">${mr ? 'Manual' : ''}</div>
                    </div>`;
                }

                return `<div class="tracked-card tier-${tier} ${resultClass}">
                    <div class="tracked-card-rank">#${i + 1}</div>
                    <div class="tracked-card-body">
                        <div class="tracked-card-pick">${pickDisplay}</div>
                        <div class="tracked-card-matchup">${matchup}</div>
                        <div class="tracked-card-meta">${timeStr ? timeStr + '  ' : ''}${typeLabel}</div>
                    </div>
                    <div class="tracked-card-prob">
                        <div class="tracked-card-prob-value ${tier}">${(p.winProb || 50).toFixed(0)}%</div>
                        <div class="tracked-card-type">${typeLabel}</div>
                    </div>
                    ${resultHTML}
                    ${isToday ? `<button class="tracked-card-remove" onclick="removeTrackedBet('${escGid}','${p.pickType}')" title="Remove"></button>` : ''}
                </div>`;
            }).join('');
        }

        async function renderTrackedBetsTab() {
            await loadTrackedPicks();
            renderDayStrip();
            renderTrackedPicksForDay();
        }

        async function removeTrackedBet(gameId, pickType) {
            try {
                const predId = `track_${gameId}_${pickType}`;
                await deletePrediction(predId);
                await loadTrackedPicks();
                renderDayStrip();
                renderTrackedPicksForDay();
                updateTrackedBadge();
                restoreTrackedButtonStates();
            } catch (e) {
                console.error('Remove tracked bet error:', e);
                try {
                    const all = await getAllPredictions();
                    const match = all.find(p => p.gameId === gameId && p.pickType === pickType && p.trackedAt);
                    if (match) {
                        await deletePrediction(match.id);
                        await loadTrackedPicks();
                        renderDayStrip();
                        renderTrackedPicksForDay();
                        updateTrackedBadge();
                    }
                } catch (e2) { console.error('Fallback remove failed:', e2); }
            }
        }

        async function clearTrackedBetsForDay() {
            const picks = getPicksForDate(trackedSelectedDate);
            if (!picks.length) return;
            const isToday = trackedSelectedDate === getTodayString();
            const label = isToday ? "today's" : 'this day\'s';
            if (!confirm(`Clear ${label} ${picks.length} tracked pick${picks.length !== 1 ? 's' : ''}? This cannot be undone.`)) return;
            try {
                for (const p of picks) {
                    await deletePrediction(p.id);
                }
                await loadTrackedPicks();
                renderDayStrip();
                renderTrackedPicksForDay();
                updateTrackedBadge();
                restoreTrackedButtonStates();
            } catch (e) {
                console.error('Clear tracked bets error:', e);
            }
        }

        async function updateTrackedBadge() {
            try {
                const all = await getAllPredictions();
                // Badge shows today's tracked count
                const todayStr = getTodayString();
                const todayCount = all.filter(p => p.trackedAt && getTrackedDateForPick(p) === todayStr).length;
                const badge = document.getElementById('tabTrackedCount');
                if (badge) badge.textContent = todayCount || '';
            } catch (e) { /* silent */ }
        }

        // Update tracked badge on initial load + one-time data wipe
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(async () => {
                // One-time wipe of old tracked data
                const WIPE_KEY = 'tracked_bets_wiped_v2';
                if (!localStorage.getItem(WIPE_KEY)) {
                    try {
                        const all = await getAllPredictions();
                        const oldTracked = all.filter(p => p.trackedAt);
                        for (const p of oldTracked) {
                            await deletePrediction(p.id);
                        }
                        console.log(` One-time wipe: cleared ${oldTracked.length} old tracked bets`);
                    } catch (e) { /* silent */ }
                    localStorage.setItem(WIPE_KEY, Date.now().toString());
                }
                updateTrackedBadge();
            }, 1500);
        });

        // Restore tracked state on buttons after renders
        async function restoreTrackedButtonStates() {
            try {
                const all = await getAllPredictions();
                const trackedIds = new Set(all.filter(p => p.trackedAt).map(p => `${p.gameId}_${p.pickType}`));
                document.querySelectorAll('.bb-track-btn[id^="track-"]').forEach(btn => {
                    const parts = btn.id.replace('track-', '').split('-');
                    // gameId may contain dashes, pickType is last segment
                    const pickType = parts.pop();
                    const gameId = parts.join('-');
                    if (trackedIds.has(`${gameId}_${pickType}`)) {
                        btn.innerHTML = '<span class="track-label"> Tracked</span><span class="untrack-label"> Untrack</span>';
                        btn.classList.add('tracked');
                    }
                });
            } catch (e) { /* silent */ }
        }

        // ===== Back To Top FAB (10D) =====
        (function initBackToTop() {
            const fab = document.getElementById('backToTopFab');
            if (!fab) return;
            window.addEventListener('scroll', () => {
                fab.classList.toggle('visible', window.scrollY > window.innerHeight);
            }, { passive: true });
        })();

        // ===== Loading Skeletons (10A) =====
        function showLoadingSkeletons(containerId, count = 6) {
            const el = document.getElementById(containerId);
            if (!el) return;
            el.innerHTML = Array.from({ length: count }, () => `
                <div class="skeleton-card">
                    <div class="skeleton-row">
                        <div>
                            <div class="skeleton-line title"></div>
                            <div class="skeleton-line meta"></div>
                        </div>
                        <div style="margin-left:auto;display:flex;gap:0.5rem;">
                            <div class="skeleton-line badge"></div>
                            <div class="skeleton-line prob"></div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // ===== Time Group Headers (3D) =====
        function insertTimeGroupHeaders(container) {
            try {
                const cards = [...container.querySelectorAll('.game-card-new')];
                let lastTimeSlot = '';
                cards.forEach(card => {
                    const meta = card.querySelector('.game-matchup-meta span');
                    if (!meta) return;
                    const text = meta.textContent || '';
                    // Extract time portion (after "")
                    const timePart = text.split('').pop()?.trim() || '';
                    // Round to hour slot
                    const hourMatch = timePart.match(/(\d{1,2}:\d{2}\s*[AP]M)/i);
                    if (!hourMatch) return;
                    const timeStr = hourMatch[1].replace(/:00/,'').trim();
                    const hourSlot = timeStr.replace(/:30|:15|:45/,':00');
                    if (hourSlot !== lastTimeSlot) {
                        lastTimeSlot = hourSlot;
                        const header = document.createElement('div');
                        header.className = 'time-group-header';
                        header.textContent = timePart;
                        card.parentNode.insertBefore(header, card);
                    }
                });
            } catch (e) { /* silent */ }
        }
        
        // ==================== RANKINGS SYSTEM ====================
        
        let rankingsState = {
            view: 'table',
            sortBy: 'composite',
            sortDir: 'desc'
        };
        
        /**
         * Calculate composite score for futures betting
         * Weights: Net Rating (40%), Offensive Rating (20%), Defensive Rating (20%), 
         *          Rank (10%), Conference Strength (10%)
         */
        function calculateCompositeScore(rating) {
            if (!rating) return 0;
            
            // Normalize net rating (typically -20 to +30)
            const netNorm = Math.max(0, Math.min(100, (rating.netRating + 20) * 2));
            
            // Normalize offensive rating (typically 90 to 125)
            const offNorm = Math.max(0, Math.min(100, (rating.offRating - 90) * 2.85));
            
            // Normalize defensive rating (inverted - lower is better, typically 85 to 115)
            const defNorm = Math.max(0, Math.min(100, (115 - rating.defRating) * 3.33));
            
            // Rank score (1-363 -> 100-0)
            const rankNorm = Math.max(0, 100 - ((rating.rank - 1) / 3.63));
            
            // Conference strength bonus
            const confStrength = getConferenceStrength(rating.conference);
            
            // Weighted composite
            const composite = (
                netNorm * 0.40 +
                offNorm * 0.20 +
                defNorm * 0.20 +
                rankNorm * 0.10 +
                confStrength * 0.10
            );
            
            return Math.round(composite * 10) / 10;
        }
        
        /**
         * Get conference strength rating (0-100)
         */
        function getConferenceStrength(conf) {
            const strengths = {
                'Big Ten': 95, 'SEC': 93, 'Big 12': 92, 'ACC': 88, 'Big East': 85,
                'AAC': 70, 'Mountain West': 68, 'WCC': 65, 'MVC': 60, 'A-10': 58,
                'Pac-12': 55, 'CUSA': 50, 'MAC': 48, 'Sun Belt': 45, 'WAC': 42,
                'Southland': 35, 'Big South': 35, 'OVC': 33, 'SWAC': 30, 'MEAC': 28
            };
            return strengths[conf] || 40;
        }
        
        /**
         * Calculate ceiling and floor projections
         */
        function calculateProjections(rating) {
            const score = calculateCompositeScore(rating);
            
            // Ceiling based on offensive upside and conference strength
            let ceiling = 'Round of 64';
            if (score >= 85) ceiling = 'Champion';
            else if (score >= 78) ceiling = 'Final Four';
            else if (score >= 72) ceiling = 'Elite 8';
            else if (score >= 65) ceiling = 'Sweet 16';
            else if (score >= 55) ceiling = 'Round of 32';
            else if (score >= 45) ceiling = 'Round of 64';
            else ceiling = 'NIT/Bubble';
            
            // Floor based on consistency and defensive rating
            let floor = 'First Weekend';
            if (score >= 80) floor = 'Sweet 16';
            else if (score >= 70) floor = 'Round of 32';
            else if (score >= 60) floor = 'Round of 64';
            else if (score >= 50) floor = 'First Four';
            else floor = 'NIT';
            
            return { ceiling, floor };
        }
        
        /**
         * Get all teams with computed scores
         */
        function getRankedTeams() {
            const teams = [];
            
            for (const [key, rating] of Object.entries(state.ratings)) {
                const composite = calculateCompositeScore(rating);
                const projections = calculateProjections(rating);
                
                teams.push({
                    ...rating,
                    key,
                    composite,
                    ceiling: projections.ceiling,
                    floor: projections.floor,
                    confStrength: getConferenceStrength(rating.conference),
                    sosRank: Math.round(rating.rank * 0.8 + Math.random() * 40) // Simulated SOS
                });
            }
            
            // Sort by composite score
            teams.sort((a, b) => b.composite - a.composite);
            
            // Assign composite rank
            teams.forEach((t, i) => t.compositeRank = i + 1);
            
            return teams;
        }
        
        function setRankingsView(view, btn) {
            document.querySelectorAll('#rankingsTab .filter-pill').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            rankingsState.view = view;
            renderRankings();
        }
        
        function sortRankings(field) {
            if (rankingsState.sortBy === field) {
                rankingsState.sortDir = rankingsState.sortDir === 'desc' ? 'asc' : 'desc';
            } else {
                rankingsState.sortBy = field;
                rankingsState.sortDir = field === 'defRating' ? 'asc' : 'desc'; // Lower defense is better
            }
            renderRankings();
        }
        
        function renderRankings() {
            const confFilter = document.getElementById('rankingsConfFilter').value;
            let teams = getRankedTeams();
            
            // Apply conference filter
            if (confFilter === 'power') {
                teams = teams.filter(t => POWER_CONFERENCES.includes(t.conference));
            } else if (confFilter !== 'all') {
                teams = teams.filter(t => t.conference === confFilter);
            }
            
            // Apply search filter
            if (rankingsSearchTerm) {
                teams = teams.filter(t => 
                    t.name.toLowerCase().includes(rankingsSearchTerm) ||
                    (t.conference || '').toLowerCase().includes(rankingsSearchTerm)
                );
            }
            
            // Show/hide conference summary
            const confSummary = document.getElementById('conferenceSummary');
            
            if (confFilter !== 'all' && confFilter !== 'power') {
                confSummary.style.display = 'block';
                renderConferenceSummary(teams, confFilter);
            } else {
                confSummary.style.display = 'none';
            }
            
            // Apply sorting
            const sortField = rankingsState.sortBy;
            const sortDir = rankingsState.sortDir;
            teams.sort((a, b) => {
                let aVal = a[sortField];
                let bVal = b[sortField];
                if (sortDir === 'asc') return aVal - bVal;
                return bVal - aVal;
            });
            
            // Render table
            renderRankingsTable(teams, confFilter);
        }
        
        function renderTopTeams(teams) {
            // Elite tier (top 15)
            const elite = teams.filter(t => t.compositeRank <= 15);
            document.getElementById('eliteTeamsGrid').innerHTML = elite.map(t => renderTeamCard(t, 'elite')).join('');
            
            // Contenders (16-40)
            const contenders = teams.filter(t => t.compositeRank > 15 && t.compositeRank <= 40);
            document.getElementById('contenderTeamsGrid').innerHTML = contenders.map(t => renderTeamCard(t, 'contender')).join('');
        }
        
        function renderTeamCard(team, tier) {
            const rankClass = team.compositeRank <= 5 ? 'top-5' : team.compositeRank <= 15 ? 'top-15' : '';
            const scoreClass = team.composite >= 80 ? 'elite' : '';
            
            return `
                <div class="team-card ${tier}">
                    <div class="team-card-header">
                        <span class="team-card-rank ${rankClass}">#${team.compositeRank}</span>
                        <span class="team-card-score ${scoreClass}">${team.composite.toFixed(1)}</span>
                    </div>
                    <div class="team-card-name">${team.name}</div>
                    <div class="team-card-conf">${team.conference}  KenPom #${team.rank}</div>
                    <div class="team-card-stats">
                        <div class="team-card-stat">
                            <div class="team-card-stat-value ${team.netRating >= 0 ? 'positive' : 'negative'}">${team.netRating >= 0 ? '+' : ''}${team.netRating.toFixed(1)}</div>
                            <div class="team-card-stat-label">Net</div>
                        </div>
                        <div class="team-card-stat">
                            <div class="team-card-stat-value">${team.offRating.toFixed(1)}</div>
                            <div class="team-card-stat-label">Off</div>
                        </div>
                        <div class="team-card-stat">
                            <div class="team-card-stat-value">${team.defRating.toFixed(1)}</div>
                            <div class="team-card-stat-label">Def</div>
                        </div>
                    </div>
                    <div class="team-card-projection">
                        <div class="projection-item">
                            <span class="projection-label">Ceiling</span>
                            <span>${team.ceiling}</span>
                        </div>
                        <div class="projection-item">
                            <span class="projection-label">Floor</span>
                            <span>${team.floor}</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function renderConferenceSummary(teams, confName) {
            if (!teams.length) {
                document.getElementById('confSummaryGrid').innerHTML = '<div class="empty-state">No teams found</div>';
                return;
            }
            
            const avgComposite = teams.reduce((s, t) => s + t.composite, 0) / teams.length;
            const avgNet = teams.reduce((s, t) => s + t.netRating, 0) / teams.length;
            const topTeam = teams[0];
            const tourneyTeams = teams.filter(t => t.composite >= 55).length;
            const eliteTeams = teams.filter(t => t.composite >= 75).length;
            
            document.getElementById('confSummaryGrid').innerHTML = `
                <div class="conf-summary-card highlight">
                    <div class="conf-summary-value">${avgComposite.toFixed(1)}</div>
                    <div class="conf-summary-label">Avg Score</div>
                </div>
                <div class="conf-summary-card">
                    <div class="conf-summary-value">${avgNet >= 0 ? '+' : ''}${avgNet.toFixed(1)}</div>
                    <div class="conf-summary-label">Avg Net Rating</div>
                </div>
                <div class="conf-summary-card">
                    <div class="conf-summary-value">${tourneyTeams}</div>
                    <div class="conf-summary-label">Tourney Teams</div>
                </div>
                <div class="conf-summary-card">
                    <div class="conf-summary-value">${eliteTeams}</div>
                    <div class="conf-summary-label">Elite Teams</div>
                </div>
                <div class="conf-summary-card">
                    <div class="conf-summary-value">#${topTeam.compositeRank}</div>
                    <div class="conf-summary-label">Best Team Rank</div>
                </div>
                <div class="conf-summary-card">
                    <div class="conf-summary-value">${teams.length}</div>
                    <div class="conf-summary-label">Total Teams</div>
                </div>
            `;
            
            document.getElementById('rankingsTableTitle').textContent = ` ${confName} Rankings`;
        }
        
        function renderRankingsTable(teams, confFilter) {
            if (confFilter === 'all' || confFilter === 'power') {
                document.getElementById('rankingsTableTitle').textContent = confFilter === 'power' ? ' Power Conference Rankings' : 'Full Rankings';
            }
            
            const tbody = document.getElementById('rankingsTableBody');
            
            if (!teams.length) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align:center;padding:2rem;">No teams loaded. Click Refresh to load data.</td></tr>';
                return;
            }
            
            tbody.innerHTML = teams.slice(0, 100).map((t, i) => {
                const rowClass = (t.compositeRank <= 15 ? 'elite' : t.compositeRank <= 40 ? 'contender' : '') + (t.compositeRank <= 25 ? ' top-25' : '');
                // Sparkline bars: normalize offense (90-125) and defense (85-115, inverted)
                const offPct = Math.max(0, Math.min(100, ((t.offRating - 90) / 35) * 100));
                const defPct = Math.max(0, Math.min(100, ((115 - t.defRating) / 30) * 100));
                return `
                    <tr class="${rowClass}" style="animation: cardFadeInUp 0.2s ease ${i * 0.02}s both;">
                        <td><strong>#${t.compositeRank}</strong></td>
                        <td>
                            <div style="font-weight:600;">${t.name}</div>
                            <div style="font-size:0.7rem;color:var(--text-muted);">KenPom #${t.rank}</div>
                        </td>
                        <td><span style="font-size:0.75rem;">${t.conference}</span></td>
                        <td><strong style="color:${t.composite >= 75 ? 'var(--accent-green)' : t.composite >= 60 ? 'var(--accent-blue)' : 'inherit'}">${t.composite.toFixed(1)}</strong></td>
                        <td class="${t.netRating >= 0 ? 'positive' : 'negative'}">${t.netRating >= 0 ? '+' : ''}${t.netRating.toFixed(1)}</td>
                        <td><div class="rating-bar-container">${t.offRating.toFixed(1)} <span class="rating-bar"><span class="rating-bar-fill offense" style="width:${offPct}%"></span></span></div></td>
                        <td><div class="rating-bar-container">${t.defRating.toFixed(1)} <span class="rating-bar"><span class="rating-bar-fill defense" style="width:${defPct}%"></span></span></div></td>
                        <td>${t.sosRank}</td>
                        <td><span style="font-size:0.75rem;color:var(--accent-green);">${t.ceiling}</span></td>
                        <td><span style="font-size:0.75rem;color:var(--text-muted);">${t.floor}</span></td>
                    </tr>
                `;
            }).join('');
        }
        
        // ==================== END RANKINGS SYSTEM ====================
        function filterGames(f, btn) { 
            document.querySelectorAll('#gamesTab .filter-pill').forEach(b => {
                if (['All', '7+', '5+'].includes(b.textContent)) {
                    b.classList.remove('active');
                }
            }); 
            btn.classList.add('active'); 
            renderGames(f, state.currentSort); 
        }
        function updateStatus(type, status, msg) { const el = document.getElementById(`${type}Status`); el.className = `status-badge ${status}`; el.textContent = msg; }

        // ==================== SKELETON LOADING SYSTEM ====================

        /**
         * Generate skeleton HTML for game cards
         * @param {number} count - Number of skeleton cards to generate
         * @returns {string} HTML string
         */
        function generateGameSkeletons(count = 4) {
            return `<div class="skeleton-stagger">${Array(count).fill(0).map(() => `
                <div class="skeleton-game-card">
                    <div class="skeleton-game-header">
                        <div class="skeleton-team">
                            <div class="skeleton skeleton-team-logo"></div>
                            <div class="skeleton-team-info">
                                <div class="skeleton skeleton-team-name"></div>
                                <div class="skeleton skeleton-team-record"></div>
                            </div>
                        </div>
                        <div class="skeleton skeleton-vs"></div>
                        <div class="skeleton-team">
                            <div class="skeleton-team-info" style="align-items:flex-end;">
                                <div class="skeleton skeleton-team-name"></div>
                                <div class="skeleton skeleton-team-record"></div>
                            </div>
                            <div class="skeleton skeleton-team-logo"></div>
                        </div>
                    </div>
                    <div class="skeleton-game-details">
                        <div class="skeleton skeleton-stat-box"></div>
                        <div class="skeleton skeleton-stat-box"></div>
                        <div class="skeleton skeleton-stat-box"></div>
                    </div>
                </div>
            `).join('')}</div>`;
        }

        /**
         * Generate skeleton HTML for best bet cards
         * @param {number} count - Number of skeleton cards to generate
         * @returns {string} HTML string
         */
        function generateBestBetSkeletons(count = 3) {
            return `<div class="skeleton-grid skeleton-stagger">${Array(count).fill(0).map(() => `
                <div class="skeleton-best-bet">
                    <div class="skeleton-bet-header">
                        <div class="skeleton skeleton-bet-badge"></div>
                        <div class="skeleton skeleton-bet-value"></div>
                    </div>
                    <div class="skeleton-bet-details">
                        <div class="skeleton skeleton-bet-line long"></div>
                        <div class="skeleton skeleton-bet-line medium"></div>
                        <div class="skeleton skeleton-bet-line short"></div>
                    </div>
                </div>
            `).join('')}</div>`;
        }

        /**
         * Generate branded loading state with logo
         * @param {string} message - Loading message to display
         * @returns {string} HTML string
         */
        function generateBrandedLoading(message = 'Loading data...') {
            return `
                <div class="loading-state-branded">
                    <img src="assets/brand/logo-icon.png" alt="" class="loading-logo" aria-hidden="true">
                    <p class="loading-text">${message}</p>
                    <div class="loading-progress">
                        <div class="loading-progress-bar"></div>
                    </div>
                </div>
            `;
        }

        /**
         * Show skeleton loading state for a container
         * @param {string} containerId - ID of the container element
         * @param {string} skeletonType - Type of skeleton ('games', 'bestBets', 'branded')
         * @param {string} message - Optional message for branded loading
         */
        function showSkeletonLoading(containerId, skeletonType = 'branded', message = 'Loading...') {
            const container = document.getElementById(containerId);
            if (!container) return;

            let skeletonHTML;
            switch (skeletonType) {
                case 'games':
                    skeletonHTML = generateGameSkeletons(4);
                    break;
                case 'bestBets':
                    skeletonHTML = generateBestBetSkeletons(3);
                    break;
                case 'branded':
                default:
                    skeletonHTML = generateBrandedLoading(message);
                    break;
            }
            container.innerHTML = skeletonHTML;
        }

        // ==================== END SKELETON LOADING SYSTEM ====================

        async function refreshAllData() {
            const btn = document.getElementById('refreshBtn');
            const refreshStatus = document.getElementById('refreshStatus');
            const refreshText = btn.querySelector('.refresh-text');

            // Start refresh state
            btn.disabled = true;
            btn.classList.add('refreshing');
            btn.setAttribute('aria-busy', 'true');
            refreshText.textContent = 'Loading...';
            refreshStatus.textContent = 'Refreshing data...';
            document.getElementById('statusDot').style.background = 'var(--accent-yellow)';

            // Collapse metrics bar during refresh
            collapseMetricsBar();

            // Show skeleton loading states
            showSkeletonLoading('gamesList', 'games');
            showSkeletonLoading('bestBetsList', 'branded', 'Loading best bets...');
            
            // Initialize prediction tracking database
            try {
                await initPredictionsDB();
            } catch (e) {
                console.warn('Could not initialize predictions DB:', e);
            }
            
            try { 
                updateStatus('ratings', '', ' Loading...'); 
                const rd = await fetchRatings(); 
                processRatings(rd); 
                updateStatus('ratings', 'success', ` ${Object.keys(state.ratings).length} teams`); 
            } catch (e) { 
                updateStatus('ratings', 'error', ` ${e.message}`); 
            } 
            
            try {
                updateStatus('odds', '', ' Loading...');
                const od = await fetchOddsGames();
                console.log('[Odds] Raw API response:', od?.length || 0, 'games from API');
                if (od && od.length > 0) {
                    console.log('[Odds] Sample game from API:', od[0]?.home_team, 'vs', od[0]?.away_team, 'at', od[0]?.commence_time);
                }
                processGames(od);
                console.log('[Odds] After processing:', state.games.length, 'games in state');
                if (state.games.length > 0) {
                    const times = state.games.map(g => g.commenceTime.toLocaleTimeString()).slice(0, 5);
                    console.log('[Odds] Sample game times:', times);
                }
                const totalFromAPI = od?.length || 0;
                const liveFiltered = totalFromAPI - state.games.length;
                const missingCount = state.games.filter(g => g.analysis?.missingRatings).length;
                let statusMsg = ` ${state.games.length} upcoming`;
                if (liveFiltered > 0) statusMsg += ` (${liveFiltered} live hidden)`;
                if (missingCount > 0) statusMsg += ` (${missingCount} missing ratings)`;
                updateStatus('odds', 'success', statusMsg); 
                
                // Capture predictions from current games
                try {
                    const capturedCount = await capturePredictions();
                    if (capturedCount > 0) {
                        console.log(` Captured ${capturedCount} new predictions`);
                    }
                } catch (e) {
                    console.warn('Could not capture predictions:', e);
                }
            } catch (e) { 
                updateStatus('odds', 'error', ` ${e.message}`); 
            } 
            
            try { 
                const hd = await fetchHistoricalGames(); 
                processHistoricalGames(hd); 
                
                // Auto-resolve predictions with historical results
                try {
                    const resolvedCount = await resolvePredictions();
                    if (resolvedCount > 0) {
                        console.log(` Resolved ${resolvedCount} predictions`);
                    }
                } catch (e) {
                    console.warn('Could not resolve predictions:', e);
                }
            } catch (e) { 
                console.log('Historical:', e.message); 
            } 
            
            renderGames();
            
            // Update prediction tracker
            try {
                await renderPredictionTracker();
            } catch (e) {
                console.warn('Could not render prediction tracker:', e);
            }
            
            // Default to "By Time" sort after refresh
            const timeBtn = document.querySelector('#gamesTab button[onclick*="time"]');
            if (timeBtn) sortGames('time', timeBtn);
            
            // Default Best Bets to "Highest Value" + "Today"
            bbFilters.type = 'value';
            bbFilters.todayOnly = true;
            document.querySelectorAll('.bb-type-tab:not(#bbTabToday)').forEach(t => t.classList.remove('active'));
            const valueBtn = document.getElementById('bbTabValue');
            if (valueBtn) valueBtn.classList.add('active');
            const todayBtn = document.getElementById('bbTabToday');
            if (todayBtn) todayBtn.classList.add('active');
            renderBestBets();
            document.getElementById('lastUpdate').textContent = `Updated ${new Date().toLocaleTimeString()}`; 
            document.getElementById('statusDot').style.background = 'var(--accent-green)';
            document.getElementById('settingsPanel').classList.remove('expanded'); 
            
            // End refresh state
            btn.disabled = false; 
            btn.classList.remove('refreshing');
            btn.setAttribute('aria-busy', 'false');
            refreshText.textContent = 'Refresh Data';
            refreshStatus.textContent = 'Refresh complete.';
            
            saveConfig(); 
        }

        // ==================== SHARE TOP 10 FEATURE ====================

        /**
         * Show a toast notification
         * @param {string} message - Message to display
         * @param {number} duration - Duration in ms (default 3000)
         */
        function showShareToast(message, duration = 3000) {
            const toast = document.getElementById('shareToast');
            if (!toast) return;

            toast.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // Base64 encoded logos for shareable image (avoids CORS issues)
        const LOGO_HORIZONTAL_B64 = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAAAAAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAUDBAQEAwUEBAQFBQUGBwwIBwcHBw8LCwkMEQ8SEhEPERETFhwXExQaFRERGCEYGh0dHx8fExciJCIeJBweHx7/2wBDAQUFBQcGBw4ICA4eFBEUHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh7/wAARCADIAMgDASIAAhEBAxEB/8QAHAABAAIDAQEBAAAAAAAAAAAAAAEHBQYIBAMC/8QARhAAAAUDAgQEAwQDDAsAAAAAAAECAwQFBhEHIRITMUEIUWFxFCKBFSMykUKh8BckQ1JicoKDkrGz0RYzNDc4U1STosPx/8QAGwEBAAIDAQEAAAAAAAAAAAAAAAIEAQMFBgf/xAAvEQACAgEDAwEGBgMBAAAAAAAAAQIRAwQSITFBUQUTImFxgZEUIzKxwdFCoeEG/9oADAMBAAIRAxEAPwDsYAAQJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAECQMgB83nW2UG664htJd1Hgh8PtKn/APXRf+8QbWYuJ6wHmKdCWha0TI5pR+IycLBe4+zTiHEEtCyWk+hpPJGG0WfsAADIAAAAAAAAAAAAAAAAAAAAAAABqmqN3xLGsmdcMlCXFMp4WGjPHNdVslH7diMZjFyaiiMpKKtmK1V1Qt7T6Cn49apVUeRmNT2TLmOdiM/4iM9/fGRRVXv3Vq7XDc+1W7Wgr/AzFT94Rep9c/UhphW/XrlmHddZrr7dYmL53Fy88BH0It9tu3YejnXjQSN2Slutw0deWWHiLz9f1jla71eEfytBOLyLh7r6+Fao6vp/o8pfm6+ElB8qvHl1yfK8Cumj0d2rnfdxypLa0Flc50up9vnyQ2ekXLqzbnC/TLrcrjJFk41RTzDP0yZmf6yGm1ysx7vdptFpiHsOPE7KJaMcsi7H+3kLMo1Pfqc1uDE4OavZHG4SSP6mOTqvXPVNFiwwzU5ybbi0unCXTp3o6+m9D9L12XLPFaxxSSkm+vLfV+Otll6Q6y0m8ZZUOqxVUW40lhUR0/ldMuvLM/zwe/uLXMsjlvVTTGbBo0arOSmY1WbdI4bjCjStKyLP4/Lbr2Fs+HrUBd82ebdRPgrlLWUaoIPY1H+i59cH9SMej0mpWqxOe3bJVuj4vo/kzzWr0r0uVRUt0He2Xmuq+ZtOoloU297Wft2qvSWYr60KWphREvKFkotzI/IcqaiaVW/b2sNt2fDlVBdPqvL563XEG4WVmR4Mix28h2f5Dm7XD/iesX+o/wAQx1/T8slNpPin+xyNfihKKk1za/cao6VW/pzo1dL1ElVF9c/4ZLnxTiFY4HNsYIvMx89NNe7MtLT63remN1KVKjwyRIVHZI0Nnk9tzLP0FheKr/clWP57X+IQ06nUOkq8HLivgI/GqkrlmrlllTpGZkvPnsN8GsmFPJzcjTk3Y8rWOlUf5LamX5bESyGrydqjaKM82Tjb3dXFsSSLqa87Y9D8hodG8RliT6ozDkM1WnsvL4WpcpgiaPfGckZ4L1FEXQma54YrHWS1/BNVWYhw8ZQgzcWaM/8An+sbVqLb91zbDgJuzU60/sFRtnDJEROx8PycvlN8fTyCOixpe8+ra+30MPWZX0XZP7/U6yEjXdO4z0SwaDFflFLdZp0dtUgiMidw2kuPCsHv67jYhyZLbKjrwdqwAAMEgAAAAgSAAAAAAAAAB9Bzd4tZ7lRvK0rTJZ/CfPNkN/orPOEZ9iJf9odIluOU/FpCmSNX6A3HknFOVTuWh0u3zrz9cf3jZBLbJt1UXz446/Q1S/VBJX7y488rj6mFrFy0alZKVMRzS/gm/nX7YLp9Rg11i5Lh+5osBdNir6zJPXHoXn+YzVBtik0hBKZjIef7vOlxrP8Ay+gtmzLWpkemHWrr4WYjvyMtuKMs524jx+r8x840n4VZX+Ehukv8pdF8aX8n0jWS1Psk9VLbF/4x6v4FDSLMdpcRM+jTXzqzGXFrWez/AJlgXlpjTG6babF8XTDciPKb4o0NxOFcXZWPM+3puM3DsOlUWoPVuqT23qTHSTzBfxz7cXn2xjqKf1svOrybnp9wfELRSGTOMUDj6IPfjx3WeN/Yuw7OCOfUtR1dSzc7fPR+OK8WcbNLBhTektYeN/j6Xzfmjcb1u2VczcVElhDJRjcMiQrYyXjGfUiIa/ofMcoXiFKA2eGK7Bc4kF05iCNf/rP8xpLdaumtnx0OnNQoZ/gkTOqy88f/AEZjSCNWz8RFqM1eZHkvNNSHeJhOCQjkOlvsXf8AvG30DSarHr8ktRkW5xdxu3wuLS4VGr/0Gp0s9BCGnxvamqlVLl81fPJ19UJkanQHps19DEZhBuOurPCUJLqZjme8NWNMKzfkK6FWzcNSdpCyS1OZMm29jyR8Ody374F6aw0Cdc+mdcoVNWSJkuPhrJ4yZKJXDn1xj6jn7TzU1emdsM2ZfOn01mM0biXJKGiy8S1mZ8SFkSV9cZ4uhD2ujxJxckrfi64PEavI1JRbpeavkvVh+0NYdPlpafdl0iWoieSgzacbWgyVwK8jLYZZizKG3Yf+hKGXvsb4U4vLNw+Pln/KFOU2r2fauiFxXRpLMeZXzGuaiSo3FsOcRFuhecHgz9/oMNQ674ibos9F30qo01iE00akMchonZhJzlREpB+vdHoH4ebvbKop9+OR+Igq3RuTXbngvGmaf2tAsc7Mbp5P0Q+PMd9RucXGriM89c5PY+w1KheHrTql1pFTTFqEzlK42Y8qTxstn7ERGf8ASMxpMjW+u1PQaXctPNmDcFPntRJRk2S0KJe5LJJ9Ml28yMZbS67tUKpFYvm5lxYlnRqc4480hCCelGhs/vSLGd1FnGSLfuM+x1EVJuVc+er/AOj22nk0lG+OOOiL6xjYTsW+ByzT9TdT7zZm12jXXattQ2VmUemTJDROvY3x85Gf8nJ8BGY33T3Ve4rt0in1ulURNQuiA8UZURo8JcUeMO/zcGe3mgxpyaPJFW6/o2Y9bjk6V/2XSWDPsJ9By3cV4a025b6rlrF5W0w6hRKXQTJr4giNWMcPDxZ744+nrsNzvXWpylaKUO7YMFv7XraeWwyvdtpaMk4v1IjLYvUgeiycbaduhHW4+btUr5LSvy54ln2rNuKoMvvxYZEa22SI1nkyLbJkXcTYtyRLvtaHcMBl5mNMQakNvkRLLBmW+DMuw5r1Kd1zZ0umzrxdgS6LUG0c9kkIJ+IRmRkZkhBY3wXU+u4uvw25/cUtzH/IXn+2Ynl0yxYd927rgxi1MsmbbVKr5LHAAFEvgAAAAAAAM8CjfFzbT8y1qbd9ObNcu35HMcIu7K8cX5GSfoaheRlkeaZFjzIj0KW0h+O+g0ONqLJKQZYMjEoOnTVr+O5GV1adMobS+jwKpQ0XjU1oRRUp420ufwp+Rl5Ee2O5jxXpcsi4ajxqy3EayTDPkXmfqNe1Eti5NKH3kQfi59hSZBvIbQZq+DcPsf8An0P3Hhg1qlTYBzWJzBsEWVma8cHuXYeE9e9MzaKKxaSDeOXfrb8PxR7v0D1HBrZPNqppZF26UvK833Z7q9cbtOt5SahNcOBFPjbZNe3EfYvz/WY0ml0GTc5uVi4uNCXUGUSMWxNIPoYNmq9a+29wLKhwF5LjL/aHP2/bcbjMlRYLBvSpDbDSC3NR4FVTz+mRjjx288ur6tLsl8y1sweoylknSwR6Lom+7Zrem8tZUSRAmrInaY8tlzJ9CLv7dfyFheFiku16/K7frravgo6PgISzLZZnjOPYsf2xWNj2hX9RLtq8S2+ZHocx1Kps9xkyQlBdvUzyfydT9CHZloW/TrWtuHQqSzy4sRvhRnqo+5n6me49xo/TYaXNPVvieRLjxat38Wzw+s9SlqsMNIuYQb5803VfBIx2p8O5JtjVFi0Zy4VbJCVxXCxuZKIzTuWNyyX1FH0jXWrUW3Tte/rLq0+vIQtpSXWSSiZ5cSTLy22IyPqL8vu4o1p2jU7iloNxqAwbnLI8GtXRJfUzIhQtBuTxB3tR1XdbztIi0txSzjRCbby4SDMjIuMjM9yMtzLoO5o4bsbtKr6t1ycLVy2zVN3XRK+DVKLZletzQK/a3W6cul/bCohxoa0GhbaG3DPJpPcv9ZgiPfYe6yNa6ramlkG3JVpTX5pxzapMosk0+g84PGMng+xZzjsM/cGo0jUHw3XM7U4JQ6tTzYbltpSZIVlxOFER7lnB7egsfw+1GnxNG7XZlzYrDrjBkhLrpJNfzn0I+ot5J/lN5I293T6FWGP8xLHKlXX6lEvWDcNveG2qv1OBJRUatVYzxRSbM3ENoyRGtPYzye3sOgrRojlY8PVIt93ijuy7cYjK4k45azYSW5e4sHKeHPFt5jxM1alPy1Q49ThuyU/iZQ+g1p9yzkc+eqnkXTvZex6aGN8PtRxvQYlq2VDlUDUbTaqza+28r4N5lSyblF2LPEW2e5EewsCNbd2xPD7XJVu2oq26tUX21rh09bvxDkZHU8LM1ko8nsW+PcdKOOIbbNbiySkupmeCIeSn1Om1A1FT58SWaDwrkPE5w++DGyetlPmu99XX2IQ0ccfF9q6K/ucWNxbMqtgnRLVsK4J95EwRSpC0LUUcy3cXgj8iMiIyLr57DPu29Vr28OVCTRKbNVUrUlvtPsG187qVGajNsupmXybY/jfW+L11TjW5qTQbN+zm5KatwkuWUokFHys07ljfp5kLGZW080TjS0uIPoaTyRjdPW5IxT297Vu/gasekxzbW74OlXxOT731pq9+abTbWp9ozyqamkFVXW0mptlKDLJkRFksmRbH0z3F4+HRh6Po3b7Mhlxl1DK+JDiMGXzn2FhEXoQkU8mqU8eyMaV2WsWmcMm+UrdUBAkBVLYAAAyAAABAkAAHykMsyGFsvtodaWnC0qTkjLyMhTt7eHaxq/IclU0pNBkr3UUQ8tLPzNs+n9EyIXOIE8eWUHcXRqnjjNU1Zzg34b63FSmPE1Eksxk7JbKOosF7cYztteG62I0pMy46pU7gcSeSadc5TR/ziLc/zIXkIEvau3LhN90kn9zEcXCjbaXZttfY81HptPpMBqDS4bEKK0nCGmGySgvoQ9QCRq/UbV7prWo8ChVWy6lTLimNwqbLZ5Lj7jiUE2Zn8p5PbOcYFE0SxtZbMpSXNO7tp9doeTcYjEpBk4Rnk8E4RkW+fwLLcX5fdtQLutGoW5UuMo81skmpHVKiMjSovZREYpCj6ba62pAXbtrXjSDo2TJhTuy2iPrjLZmjzwRmL+kmlBx3L5PoUNVG5JqL+a6mMrOpsrUHQO8mKtTmoFWpRx0SkMkaUKJbmxkR5MjyhRGWRgadpBSKh4eHb4l1KeusNQXJbH3mWm22zPDfBjuST79VCxaboZLpWj9wW3DqcaVcNcU0qRKfNaWvu15SjOFHgsr3xuZjb6RYlXj6BOWE/JhlU3KW9E5qFrNklr4sHnGcb+QtPU44qsbpbv8ARWWmyTd5Fb2/7soqrX9ccbwtUGOxPfJ+ZPegOSiWfMNlBqMkZ+qS9iwNbq9IpLVtQl2nZl7QLkjGlz7ScJZk6f6Z4Lp6Yx65F6UjRBb2iCbCr1QjfHMzHJUeXFJSkNuH06kRmWDMjL/IYwrA11qcOHbdWvSmwqNGUklzYLiylONp2IskgjM8eZl6mYlDUYle1pcv6/38jW9Pldbk3wvHD/g0jXG9LkrdNsa3KsipMNTqe1LqrERvhflOGo2zLg/q1GRdMr74IYOQR0K56LXNNbOu6iSYrhFMTKStxuQjJdffcjLpvsRC/NVtJV3LSaDJoFWcgV+gIQmDNkOKWbhJwZcxe55yWePfcz2PIwtNsbWC47hp0i+7ujw6XT18Rx6O8tpUlWSyS+AkbHjqZ+xFkRxajEoKqS5tf87k56fK5u7fSnx+/YrvV7T+3WdfLbpKGZKIlxOJfnpN35+Nx0yPB9h09Z1vU61rbiW/SEuIhQyMmicXxKwazWeT9zMVlrtppdFz3TQrqtCdDj1Wk4IkyTMk7L4kKLYyPczyRiybFj3DHtSE1dUmLJrRJV8U7GL7s1cR4xsXQsF07CnqMntMUfe6di1psWzJL3avuZ4AAUi+BAkAMgAARAAAEgAAAAABAAkQJAABACQBr9+3Au17UlVtqCU9xpxltEfm8rjNx1DZfNg8brz0GB/dCXGolwPVahOw6tRFNocgJkk6Ty3SLkE24kt+MzJPTJH2GzXdQYdz2/Jok9chuO+ptZqjucDiTQ4lxJkfbdBDBK02tl6mOwJ6ZdSQ/NbmS1TXzdXMcQWEE6Z9UFthGxbEBgxMzUmqHa1BuCl2oiW3VH2oT7D1RJlyHLW5yjaMuWecLyRnt06DIK1AaZ1BptnS6UtuTJioclSEPktqI+slrbYM8Fk1k04ZHt0Lbce+DYNtwaWilwo7kWE3VG6oyw0vCWnkLSsuEuyMpzj1MeSo6Z2lUKtIrUqnrVVn57U8p/H++GnG+DgJC+yC5ZFw9MZ8wB7L6uifQZ1Fp9Lo6KtNrEpyOy2uWUdKOWyt0zNfCfZsxhI+p/x8WmsUa3pMquT5EuMdOefQyUdyIvgkcx3csEeCIyI85L1xst32rAuV2nPSpk+HIpzy3or8J/lOIWts21b47oWZfUY49ObbTSafAiMy4Kqc449FlxpS0SEOOZ5qzc6qNed85yAMJUNW6fTIFKk1WkyoRSqq7S6gSnEmVOcbSZrWoy2W3sW5Y2PIztHuyfW6f8RS6Gt5SjnJTxSOFvmR3eWhBr4duYe/oRH1H0ZsC2mokGL8I68zDefe4XnTc5630KQ6bpqyazUSjzkZKy7apdp29HoNGQ43Cjms20uLNZllZqPc/UwBh9NborF2U9+oT7fapMdD7rDZpqHxBrW08tpe3AWCyg/ceuh3SipxbjkFC5f2LOkQzLmZ5vKQleem2ePpuMnbdDhUGmHToCXCYU+9I+deT43XFuL/AFrMYaFYlPhVqpVCNU6wlupvOvSoXxX73W44jgUfBjyx36kQA1M9Y0KqtqU5ikQW3rjo0OqMlMqxM4+IVgmkfdnzFl9Mi2RpDGmtGiyKRIp9RrVPcpdLZpTJxpfBxxmjyhDm243cDIAAAAAARAAAEgAAAAEAAAkAAAAAAAABAAkQJEACQAAAECQAAAAAAAAAABAAkAAAAAAAAAAAQJAAAAABACQAAAAAQAkAAAAAAAAAQJAAAAAAAAAAAAAAAAAAAAAAAQAJAAAECQAAAAAAAAAAAEACQAQAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/9k=';
        const LOGO_BADGE_B64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAABkCAYAAAAonQZNAAABAGlDQ1BpY2MAABiVY2BgPMEABCwGDAy5eSVFQe5OChGRUQrsDxgYgRAMEpOLCxhwA6Cqb9cgai/r4lGHC3CmpBYnA+kPQKxSBLQcaKQIkC2SDmFrgNhJELYNiF1eUlACZAeA2EUhQc5AdgqQrZGOxE5CYicXFIHU9wDZNrk5pckIdzPwpOaFBgNpDiCWYShmCGJwZ3AC+R+iJH8RA4PFVwYG5gkIsaSZDAzbWxkYJG4hxFQWMDDwtzAwbDuPEEOESUFiUSJYiAWImdLSGBg+LWdg4I1kYBC+wMDAFQ0LCBxuUwC7zZ0hHwjTGXIYUoEingx5DMkMekCWEYMBgyGDGQCm1j8/yRb+6wAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH6gEXEzoXM7+SRQAAQ0JJREFUeNrdvXeYHFeZ9v0751RVp5menKQZ5ZyTZUuWc87GgE0ycUkL7MK+LEtcNpFZll3AJMMag8ngxTbBOSc5KOeskSaHns4VzjnvH9UjywZevF5gv+ur62qp1epQ567nPPF+nhL8GY/bH3uaI0d7ufvuB9j4xDN0T+khjCL2HzjEv37ig+du3rRl+p59B5jS1bmupbnhrWAZG8998/ixvscXzJ/HunWnHfnLv/n4fXPmzMJ1XA73HmT16pWcd87ZTJ/RwyvPX/9nW4vzp/zyhx95mv3Hetm2Zx/P7tzJ5etWJ+50VMOzTY24jmDp4gXrDx85+gphNd+86Udn+34wdSJfZNveXqrVCgJIJRJvTSXct47kKjy5aedxiX6gtbmRnp7un/YeP/hYU2OWWTOn87JzT504+5o3+ksXzWPRwvnMnjmDC9ev/pOtTfwxvmTHoVGe3ryNux98lF/ddT+nrFhItVTkwV/8J9//+S/P3rRzd9szO7YzrbvnLKXUNVu37ebA/iMEgan3vFRd1Y8IQgMIrHRAiNrJWQQWazRWRygpcB2J57noKCgqRxdmzpjG4sULscb8vK/v+IPLFi9g2ZKFw29+5ZUPrL/8ehL1dTyzdScXnb6ai847m1PWrGb57Kn/e8Dd8+DjjI6N8+iTT/Nfv7qHu351R8O3b/mx+51bfsRVF511QX9f3yV79uwV3VO6Li5Uq62DuRxjE3n8IMIIB2sdMAohXLAKY0BIhZUKYQ3KRhghMUiEsGAirIlwpEVKgTEagY9AY6wlmfBozGZpa8xSn0mNDPQP/mbmrOm2fWrXr++4+4G7X3XZ+bz1zdeHF1312omLLzyXU09ZTUtzE6+69KyXtP4XtVX/6YtfZ+PGp1m5YinDQyPs2rOHnqlTmorF0tmO44hpPd3Ov/7H1963c9+hnlJVc8ttDzQ6QmQCP+LQ4CGEBaQgFA5WueB6YARELhgZXz1pMDYCK3BsmVRUpCKyaJXCYkEakBJjfIy2WOXgGImVihBBaBTl8ZCBoSGUMa2uK183mD9AsHX/NWBzm3fu5Svf+E7vtJ6p/6aUijzPs1O6Oh/YcPl144sWzKe9rZWNT29mzeqVfPKD73npwH3hpp+wb99Bfv2b3/DyKy9NHT54MN3V0XFVtVw5I+G5vP29H+hIpzKX9A0N0zc4xtPbDqKli8bBYBAWJBIhPIQRSC3xHIu2ATb0scYiCREorACExUqDRYPx0SpE2QBXg5ARkTKEqh5hkwir0ToiEgKQoBQ4LjoyIEIcYdCRoWpCQiUyQpjMU5t3sXnLrqnpdPJH5arPkSNH8avlX6cS3mB9XYauzvaHW1saf3HlZReWb7llQ+Wyiy9g3txZvPdt1//+rfq5r9/MQ488ySlrVnPg6HF27dnPe97xxrannn52/e13/JJ5s2e9cnhk9Myh4dFWIWSqVCkTRZZKYBFCIZSLFQptLRYJViAw1PBAWBVLlohARkipkTpCaI0DKEIQIUpGeBakMCAticgl5UcYGVDwFDnRRmhb0ThEykdLD6QEEYKNwBiUsTgGBAYrJh8Wi8BxHIyOiMIAKSwpT+FIyKQTAJWW5uaRlqamhw7u3/+Tqy6/mLVrVj32pa/dNDx3/lxmzJjBM5s2cdqpq/j797wF59TzLuOKyy9N7d13IJnJpK/zPHeNUop/+cwXezzPvXC8UOX+x5/FogAFUmFxQSjwPCIL1mgwFqkkwlrAABYrwAoBgliqEDhWgo5wo4h0VKHVM3RmLO11lraMoD3h4SZdjOtQHxgcP6RkFUd1lcOVIoeLKQ7lLWVpwAiElSgVYrSPQWClSyAchLU4NsAxIVaAL5KEkYh1q+silaSiQ6zWFPMhYFODuf4eYXpfW+e5r33g4Se5576H72pqaur1XJdMJv10e1vLjy6+5OLqU6+6viLWXXD55VOmzXr90d6BtROFSkehGiaL5QrVqo+2NYWNxHE8tLZoY5GOg7UCi0JKiTURNgpjKROxHNuaQFsEeAlwXERYwa2M0xgWmZGGJa0eC5ok8xsNHV6JrKyQNGCVh1GSVKTRRlKWhryjGfdaeWy0lR9tGmEkiGh2klTLZSpC4bspfJUgkgmMVWAsjtEoG4EQhI5HrGpFfG5RDKhQEhOFCAlCSoQ2KGshCnGVIZnwSKeTJFKJamNDZnBKZ8tGgsLNYu6qDXZgtIBvXJAekRVYG38JQtYAEsTfrJ4zxKKGTk3CJBZrNViLkBKDiL8DCVIiTES6OsYsr8LaLo81U9IsbFXU63GS4SieKZLAx7MatMJaF08KAumirQYRMZ5s45cjrXx3UwFPuVyxsIVCYYInewscqCTIew2EKoGx1ETcweJhpcTaEGy8E+LlSKw18Rok8evWgpUIK1BYpNVgNVZYpLQIfBxb5dSVC3EmihUiXKxKYYQb6yRMjIeVCGpbDRHvQBHLEtYgrXm+whQillALwhqwFqUsXlCghRIru1Oc0dPIssaAdjtGyh/HsRUUAUrFfpw2BmUEApeylARC4+mAjHQZ8CUH+4bwiyFLulo4q62KarPMa2/nocMVNvaNMhwkCbwMWiaJhMLgxrqWACHi87UARj+n5U3t75qxsUgia5BCxvZTWIwwKECbiGpgcKxw0AiMcGs/UrsKtZ9jEisBQthYAoVFWoMkIoZZxtvSSqy1CKtxJKBDRBSR0nm66jTTGtMkRZVCoYCrqgRKklJJUtJB6AClQxAu1rroKEEFifQClKspRgl2Fz229I8ipGBJp6LJjtGoqmTrqkxf1MC0jOY3ByY4YiRFJ4OxAml8HGHRNoqFMBY4rLAI4t31nDCchKIQmBPiOGnsDIJ4FzmxHpIYHCwOEP1Or1ickCpb8+eJ/SsEZtItQMTfZC2eDnCMj7IhQkoOVyUju0Z50Pg0KE1DElrrXTrrkszKOszIKKYkBAmKpEwVTwhcazFhQOA49Nss9x4u0V+OWDq1jqVdhoQo4gQlOm2BFlWivqeZ+mQztx+usi0/jHAbYouOrRk1cWIh9sSfkwrZ1lyAyW0rTgA4icCkyrKiBlz8YXlCTO3kZZk87Ilfeg7F2vY1TOo+Gb/JWJTVqKBERgUkiaBaxhXgSQdhYdSH4xVBmItwpU+zMkzPuMxqSLG0p5HF2SqdagJ0AFKRl408NSrZNGhJeVnW9rTQ41VIR6VYoogNT7vKc+bUNoTykHvH2VeJKLrt+CRr0mOfW5CYXIg9aVEAuvZUTroCNVyoCUz8cISVCKtiSZK6pkB/j7iddK3ip7GLEl8oHX+5lAgT0uJVOH9eC8unNtAiI6RfoVypUgk1uWrIcMVnONCM+DA0EbF9pMyOYZ+NgwVWdgpO7XCY2ZjETSbZnU9y55ExyoFkTWeCUxs9slEeYSSBTFG0HrahnXTrlHx7ITdxlrI9jnH48Y5hduk0pBvBr6JsFbBo6cQXu2bMEKJ28Wv/PrFMAWLSoIg42rEqjm6EcZBW1VwJfeJzv/cQtubgxjtfWoFrNQ6aQAgiK3FsmVWdcM20KtNNH0kdYlyFcWuugDBoLGUNo5HHUb+FfROKHf1ljud8fr3PZ/Ogw4oej9a2LI8fyrMzJ5mT8bl8ZpLZMocNYVQ0I9L1UXpqd9Awc/avGqfO/OH+u35yerZUft/p7YLBvGTg4CB+0IgQCk9XQRh8kcFIDxVFCKPR0sNKF2F1rICsQli3hl8EQgMKawVCOyiralv1BFjmuS33e8P/+D+MEKAsGINGYHGxVpDWeRZlfK6Y18QsRqivFnAFaGoXTDwn7hkkrZ7DNKfKadkkuc4kz45Jnhx22DpQ4dYjimpfiPYlM+oEly1qYn5rFRvmMdkOvCmLx62b+UhLT8eDLes2HPcP758o6sSp9UbQJQpcPCvDoRLcNVKk4mbj3xYydsqxCGuRFowVMSg1LOykUTyxxwygnoeB8/8C5/cfNdGVAkGEwSUigWNCOlWRS2YmWJGeoL40hlu7Bo7wa34SWCSxjCpsaKkHlC7QJKB+WieNPbMo7ijyyOEKgagnIVxa6lP0NHskzWES0hJls/SctvaZUy7826/e8813w+BxlLBz2rLpsxmqorShLSE5Y2YTeyYq7LVpIumBtLVtOmniTlpzTc+/mKTRS09k2liCXV2LBaUloYvMz1ZY35WiOejDsxWsShFhkSJCoJn0OGPV4BJZgxYO1iqMm2Asctg9MEHfQJ72sEzCTFDWLkcHFPe7E7TOTaMdQyEQ6JGxvdutFULE/kTxl5+alnTkKWElj/RSuMD8esuKppAjIxXKbgorFVYohIkQdjKeFr/lgv3JgJMGHAOuASM0rijTHI5wapeiQ4yTEBUix2DwkQi0lUTCi0ECsAZjDCKRwHfqGIsSHJqIeGxgnIeOVAh8zbo2wZpZnewrJrlrf5mHe4ugq5y9crppbOz8oRnNfWwOcPvHXocOyoxWvKhUlSbtJGVkwUhFQoVMaZCkRipUSRHJeMnC1qKdmsV8zkH5UwInRC16iR1na0JSOse8uiIrWjJkdInAxL6hZ0NcbbE2QehkqIgURiqEDVBKkw8shwuSx/uqPHGsynC5SmMCzpvfzDnT07QnYE6HRzZpeWDHIBsHI5LFpifWi/S7MlLkdn37nwmEUy+VuzQ3eGxZVC4LmWxiyCR5aiBgc3+B/eMCFXk4KsCIJMZahAlri1Entq7lD1nG/ylwFqwUhEJglItjItKVHMvbBV1uGS+KQKTjrzdFIgtaZUA4KAEVHIYjj4MTEXtGq2zuHWCgKpDJepZ0ZjlnepJTOjyypoIII5odn8apaVzbwQHZXu5YetZNrt6d66+k6aqTqRZd+GRprPcdAWPSz4+LXSOCu3vzPD1YJGfSpJMZWryAUlAgcNIIIZE2jgIiGTu0sWGsuR5/Oh0XGwfrSCLlIIKAOlVhdnMdjcpHhgJtXbRKEEhF5CoqToZiaDg2XmH70AS7xuFgUTLma5Key9zuDMu7G1nT4jDXyVMfjiC0AeURBCWSTsCaxUvz81sW/l3UMO/bwZRZtA3vqT907Mgn5MTgOzujITXcO8IzBys8dqjMwapLS4vHys4melo7qFQr3L47x5EoxMgYOCsUGqcG3KQP9+Kk7iVvVawBHcd2MgpoSUtaMg6OjJDSwRhBpFxyqoExA4dGymzuzbN1KGDQdxGOR4NnOK0zwZLOBIs60zQrnzZGSfoFsBolLdZW8d16Sg0dvtdY/4HrPvq5r9/wuX+j3ZuSuX/f4KfqRo68a1naMhQm+MWucZ7tjbDGY01PiksXOMzPFgl0xJ6whYdlyPHAx8gkyhq0EFih4syPtTUn/sWB95K3qjLgWoPWEWlraPRckp6DbyyeVFhHMuyHPD1e4KkBzd7hKhVfU5dOsaq7nrmtaWY3SKZmLK11Dk3NDRSG+klVIzwNoVEIabACZKaFnoWn7Gmbs/xn8AOmH/oFO/SG99715PZ3RIP9DMzrZnBY8+RRTWvC4fzZTayblaFbDlJfLRBRz4B2qVMRjtWEWteyYrUYW5wcwP4pJQ6LYyPSxlCRdViTwlEJkpQJpSGXbORwznLXvnGeHAkohNCZcDlr5hTmdyXpyUY0UyEVQeDWk2nrfrpr8fxf6T37luZ61cvqyqMkHUNJlyilWvGmLNrRPnXamxPrzht9/LOvZOL4xMKm/Y+/vK4yqrbnIv5rR5Gqb+lKu1w5t45zplgyehA3LJAQFkdXyKoq2aQDJYMBoppDK62PNc4J5/i5AL/2/Pfou5fsjgjifJxFUcHDukmk4zNEgh0Dlgf3jLNr3FCXyXDWDI8zp6SYmxTUO+MokcfqCC1aEG09w7Zr/puRYlu+vr0ps7i1WDqy9/ry8GHCTAamLtpJ5+w3WGue2XfHV7GZjvn19dF/zisfW7mup5V9w2MM6AxpBWfPrWdDt0+bGUOYEI8Ix1giCy4BjuMSp/RjB1wCyvhYNJGTwBKXJmuZTX6/kbAvHTgrPCrGErgW1wGbyjLqpNh2eIx7dw8yXtHMana4co7HKe0ODcqH6igpHRKiKSUymOZuOpcs+1nHhVfvFe2r2fH5N453rz/nrwrtnfLo1vrrfN/f1dHU9aaoMPrMmGqDtFhI/uhN/ujRtdqkyFVdAgTa+jhCUO+4eK7BDwUpJBk/IAICL4WxIK1FChtnfqWM9Zs2vEi19scBLhIu1nORymBtRH+Y5JeHBFt3lTCRw5qp9Vy2sIFliRzNwRjWhHgJ0EGEcBsoZKYa2z3969nWpg/asRH/0U/8FUUrsWGQa5u78K/GcsWvlPqGhgV2/9zVl9M/dHh+6fjxm+jbvjYVWTaOOzy+dxTXLzG9XpDPG7bsH2FNcx3ZpMVqi8ZBSIsUAqMtxuha1trGRXHhIoSuJS4mXZEXd8gX/c4XHFpCIAVGB+jQcGQs4KEDo/g64syeBG9cWMcpXo4644N0cYSDNhqrHMoqS7qx+8a6tu6/jazJ66H3AVxnrb1688+/RjGXGzNh8Dg62n9IK4SQ8/TQyM1m/+61meIYQxXN3fsGGCpWOK27npcvamFqVnIg57NnoIjVEiElReWipcLRIYERBGFcQ1ACQGGkG4dgcS6dODPyIiOHF+Yr/1uQS7CBIKESBNU8dWac03sE18xxWerksKUc1USayEkSaouWCi3r8WasyLUtXnPT6MRoSSycow7dcc6b5fCefxXaj1JN0xtClbhn9uy5xxf91Q2w6FzxbPkXlySHj63Njg4y4WS5/0CRncOWaY1ZLprbRHtGMNAmeCRn2T4Ysrotw9RUlYCARCx3VK1HVVeBydS5ABQWHQdd1j5Xd3gRQMgT1Z4T8e2LhE8HCF2Oa6dY6myBNe0R18z3mOWOIcMKruOStAGOLmEdRVE2wLSV421zV74rvWLdxqg0it696w222PuF+tFt9S1ju5pMvu/G0vH9PxdSLroJ2P7uBddVRw9+zBnaTQKHbWNJHu9XuMLl3B6XJXVV2vUIG6Yo2lKCHUMh+/xGqjIdF8sRhCLBaOCQ8wVWONiYqBJX30Sc7hfoWkLzxUmcfKmsG8doUlElThepAGF8FkzpZEZK4kVFIqnRyuIRoUyFSGhktnNUZtv+et/LPvKD4Ufv1XhudnzzE2+q7n2qrp4cdaaMlzvkDD5z79rxnZu+dfUNb3636N395fpcb4tSIf02yRODMFT2WNyY4cw2RWM4SJ0eYXFDwLyWesYDxca+AhPGw3XrCLSkJJMcKytGfUU0mWSYrPxag7I13Wf/HNkRwLGWyAQYpSnjcjwvybcoGqUCEaK1QUmPCoKgqYuWeUt+OOXdN343PP10Jhy3kfHiv5cP7lmfrRRwiKWg3paQwwcYHy+elsokT3FyAyrlQs5Ns3HYsOl4jhYvwQUzW5jhDOOGE4TCkhRJ5rc28HRflQMjBcbCdpqVhxBJxkWKPSMhRZkhwo3BMbE3J4hQRPHrYlLlmxe1/v/+IUALiS88NHE5L/CaeLqvxJGqQ5ioJ8TBSoeChnLjdDLzT3u6fcmqrx3+wttwGhuaS7r0hUpf7/WpclkmSOAID0tEMvJp1FUylTHkyHHVQIUgiugLMjx0rEy+UmBtp2J5c4SnSyjp4goHUS3QXadpSUvyJc1wCQKjsV6K3gnBrsEyFZmJGVNSxjvSGoTVSKuRmP/eVv1vuzAAVqCVi++msKoeHSUIrUd/NWLXeIlR1UhJNVMR9fjpLMmeOc9keha90ZaL203SY3jnlmsLh3a9yY4eF0mtENojNCBFSMJGJIwhgSUtFZqQipdg56hlb07TWZdg/RSHVjWCkj6hdYlsEikiutJVGl1DJXQYKWmsNFRFgq39VYaqDoFMItxkrcwnQNga1+VkEJ4D7v+FjaOtifkTf7BK8zzk4vSvCnFCgzACI1MU3VYeHh5i4fQ0sxwfqTxsY9fGFi/1RqP1Ll+6WEes6Nv42DuT/Ydp0lWk1YSuwVcQKgdjfBxpwXdwtUtVufR6ivvHc4xrwTkd7SxOCdJhASl8pNAgFQJJyloaUh6ogHFfk3PaGKkaNuXGyHsNMS3Mxhloaw0QEkmBFQkMqrZ97cmr/F0yE+ewzYvMP/32N8ROo9QBykZYIaiqJDtzgqcHAoZVA0ydZ9sWrvpI0pR2tV/9fiGTdSv9XPHmaHhoWUZXcUURV+Zw7QRJfKSx4ApCa8BqtBHkk908MeayZWiM7kTAus4M7VKTkAbHGFwbIG2EsR7SuNQlPbT1GQ8CRlNdPDICW0uKspOKF211LHG18zdCEAoXXcuQ/OEyXwyX89LYrHF9UWgXrMAKHXPUhKVsPB7bk2PetJX+grnLbpw2u+eZXPEMzJM/7Bo/cvCm8qE9S9P+KFYW8Z0KCRORMJAMIJSCcuTgCA8py5QSaZ7167lr7wReoLigx2NJQ4i0RQwRrhEYo4iUG0cBOAih0RhKKsn2sSoP9hYYVFm0qNlB8ULPVfw2BPa3l/tbW/UloEYtBQzWQwNC+lgirLVETpYDJcGPn82NBbNbfrbAjcY/cMOb+P5lr72iOrB3cX1hHy3OBEaHaCEJRRqLRNkQaSIcmUFIQeRUOKYk9x7K0TtuWNbYyPqeRhpEGSkCrIhqRR4RuxRCI4QhtJayTHOsmuDIziEO5B2iTBM2EL8j2fHSuePOSzANJ8CzGLRQtSqjRhhDaCV5p5nto6Jr2qGhGzuWnP8Xd7zp/bPGt2/8tBg/ojwVoHWABwjjEOARKBdlPRwiIEE1DCmmmnlwSLLp6DDdDpw9pZEpKTBhAI5Ai5j/K4hQMkQgsUbj2wRFlWLXiEKEEFGPjOK67h+HY38CuFpx9gVVxj94iLjCbXAR1j2RZkIqAplgVCvuuO+pWYkEt6ezY273+FFPRQWEI7DGQ0cCrZIEyiESFs8YHB0XunNuM0+MSW7dVaBSDblghscFXSH1uoi11djNsCKmxMoIgyZEUrYeOZug7DZQiAQpq4EIFYZxXPoiXY0XCdwkfULESYIXe1lEBEoDEqsTCGsRIozpVNIBXEYnKtx6690Zv8fnqu6QGalGjJ/D0RZhDRoVZ9+FRqkIjCbnNLOp1MBtu4cZzBs2zGjhwtmWKWYQSUioYtaRa8EzGiMlBZugkp5Cf6GRwWqIL12EcqgGIUqAEX/YoX1JwL20Q4MIAA9sgpgi4IANwYYIHBzlUqr63H+wRL5kuHRWCyvTHk40QFKW8USINJZAOFQdh8GE5LFRl1/tneDocJW1HYpLZ3n0pIrgW4QCLSwiMiS0AeFRcbMMu21sH6vnwQN5DuUUJGJJixxFpBKx8Zqshf+RhO5/UMmXoAXCxFRWS5z9sLgoK2KOLZLITTBMM48MFDk+OsrZMzKcMa2HHjVGU1jAMaATzRywGe47nuPRI0X6B3xWtWe4ZoHD4mwRghIVkUbYiEAppBtz8oqymT4aePBwlQcPDNNXEeTdBoSIWe1GJLDSq53wH1fqXhxwkymXFwCndAJpBIYQLWWcMrAJpAUlQAuD7wogTSiSVKIqffsm2DJUZEN3ioVNdSSU4vCQ5rG+PE8PBhijOXV6PVfMzrKoYQInmqgRnj0MSXzhMYHHmMiwfczh0UOD7MkLcrId7TkEyolT4CZCWhnTUKmxsE7WcSf7ayfYNeJFS6Rzcj7g5KzB8/h24rdNuUTVOBcCIWoUMSEQOOiaB26kxaqYxBxoTahSRCieyRU5PFGlo0GgkpLBgs9YAdLJDk6dmeL86Yoer4rvOBR0EhmFKOtRqCqOjJbZOpZnd0Gzr5RkOKojTNbhk0Jpg5FuzMK0LspIZKSJCNFK1VyoySTIc4ykSd1uhXnBwk+8g+cBYAVOnLGavACTBNlJBjag1EkWd/KDhjhC0RgLQkisDWJn2CqsUlgRxpGw8SACYWIWum8cIidLgXoO5Q2qogijFG5C4KVTFLRhy1CFAy4Y6igFLhPFEiPjVQZzAQVjyZs0vmqiLDIEcToXLSxGxecmDSjpYIQlxGBkDIrSII3CSNDK1tjwAlkrO2hFjQtX45Oc2N21uFaAFLH5dJ5PhZtkjdeQl6LGqYhJ0th4O4qYGY2Q8fufy8YYpBQgFcbGzRfxtVQ1ZqMA6RBaSyAEwnHihToWQUT/+ATlsRKbbB5jNcakMUJgXYmWaXxTh3FknEk2SYxVceeMiS+SFaLGvLdoE5cBrYrPBwxKKZR00AK0iEAKrLFYHQeeOMRlVh0z/qyQWPlc3VWI57b383WcJc6O1rIHAoOQ9gS13dZ0mxASo2OStZQx05zJ51GEtQap4qyyNfEVNDV0LfHrUsWNJTHzW6ONQbpJCiJFwWZrv5vEWA3KYHExpNFocCRWuxBppCSWKDm5bQxSqtoekejJOoyUaKuxOpZAnMnqvY0ZA6LWCWRN7FpZTUyY/t1B/wuMg0CIOJ1sTQQmjHsDrMFiUFJgLJhwksYukSLesjH3wqBQGKOxxkfIEHStiiRl3NFU68SRaCwaHYaxFlEKIRW+cTAqEbs1JBDSIAlBSIyxsaTrCEzsC1od07WM1VhbuxBGxG2cjouSbmy40DFDyZg4piW2tvFrYXz+KKRjUYJYiq2tsT1qu++kIOH5wNX6Qok0niOoq0/iORasxpgIx3UJwohypUoylQQcSoUAKQx12SSuI8nnfLyERyqVBnywCaxIU6j6lKsVBBJpNcoauqd20NXeRrlc4eDBQxSLFVKJDOmGNKAg8rAmoFItYiKDowx1dS7KAYxLGBnypSKGmNKQSnukPA8baYRw0DiU/IhytYpyoKHOIeW4VEPDhB8ShRFJR9CQdnHdJL508CMfv1IiigS61gFpxPMDAws4QorncnHWIozGlTB7+hTWrF5x464dW+5zpHXCKDDWiqi9vW2xteYDxwaG/tGIRH/eKfxTIuF0NzXXfxz0kWNh3z9PndK5VTn2x1JEWpDUgfbE0Ojox0K/tMjaiIQjWbtq+cG5c2d/8vzzzi3u2LZDHj505B0PPfrYGcJEE40tTR9JpJy8Cb1wYmLYEYYV5ULhPWEQHVg4d85/VKqlYhSqqFD25SmrF1938OD+qwYGB7jsgrN3HTp06NOBHwZKJWypGnHo4NHrHBu9rCVbr7taG/+5LpE4GFk1bXBs4h+OHu11liycb6d1tX66b3Bge8U6ejw/plZvOPWdTz65bcXAUL7O4r7QxQAEKtsy6x8qgcEoiZUWx1i0X2ZKRzMbTlv15PSOxvtyhdKvf3LjF48lHNGVcFWLDsINxq++94CuuzdVGnx9JiXb58ya8jeyrv2u0d59b5je3fVIJYj+7dILlheb6lNNrc2NuvdY/znlcrE9CnzmzZ7O+tNOefvVZy554Ec3faM1KgzvufYNb789PzH++sJIf2lOU+Kd5+UOPF1saZ26aMbUx9//16+/4/DR/mUJx+n554///RfR1WcCv9h50dmn9r7i2mtvHh7sm50bHVx45aUXbv/G5z7+N//w0f/TEpRHZWdbW9g/MLKkWikvnjdjqjnjtFXvL+Tzd77yZdeMjQ0Pv+3woQNq0Zyp9rprLv3QG1911baWpsaWDevW77ri8stvfOzRjeWqH5xf8f1ac4lEIFFGM6W98beNgwHcRJIjR47y/Vu++875s6Zd/aqXXfHa2359F09ufOq2zVu243npSjbb6K6sy7lHRwLpGImIqu5d//llOX3RSoHx1VO/+QEt9eVXjY+VP1nxXSbGCzXLJJg6pYslSxaP7N6965KRkeFvDA4N3TI20vfBIKj+IplMXBAI6X7pSLEtPbLrlvaOjo/ecNYF37j7ka3lzZu2U6hW2LZz59q+vr7bSoXcXV5j10UTo0M3ZBLeNUSBOHTsaN0NN9xww9atWxeVQ5cwiAirPl1tTeUz161xLj1jQUsoW4eL+Ymfe0q+ChNRLuXFg48/ftWjT2z+UrEafrshMfH2M05fN+bf9zAjuYNxcsBRz7MOLyjWCIx0CAyUg5Ajx/qZKBa7kM6CiXxZHzs+YA8eOkY1AOml6W5I05BOyoZMUjXWpYC4xKtqZruYz4vc+Bh9fX2UKlXCWkt4qeozNDIiZkybdrCjvXV4PDfx8h98/5bHtu7Yc3ElCK2TSDA8NsbxgQGzdOWyDxwYGGlJppIISegoERTyY+QnRtmxa5tdNG8a2WxWSKUIwwitQ3ITY3J4ZIih4SHGJ/Kk03Vs2777G54Z8vv6jj/m53Z1HOsf2ug4LtpYwihkfGLC7t1/EGuCa0MtT507a4b2XInrSJSreOHx2yGXcBCewmiDDiqEKIxyTagF2jpE1kHjIlSKKc31uj9b+FAqk2hsqK87HPsdNo5VgdbWltuiUPbOWbT40u37jrzq2NAoIDh89BiD/X1/cc0lr/vLxbt2vGbn/qPXPvbkU2/NVWHJrO6+dF0D1lqbSCRyg4NDv2zI1hVyY0O2ODHqSyHKC2f3RK6IxptalxROXXeK+Pa3bs5YITEIlU5lgvps9sONLU31WdUyh6HqR5R05OLFCwt3/uZ2W/HttGqlnDj7vAvCe+++K8JxFU5MdIxikmGdUioZhX48fcLaWgFbnag31Eg3k6FEvFgrwVoHY9JIRyOUwogIY12kyiBEGl0L7D/x+S9wz5NPj0lpAlfZ8POf/JTQVhPVJO7Nr39H2bdqaN+xfHHf8Z9i7AQSGBwc5uEHH3i1E1VEW+vUd5ZIPXTKqYuL23ft/6soKFEtjYvqRG7U8RJn/fTmrw1vOPO8loP7j87Ij42F0s9FM6a2P1IpFZYtWX1K8LlP/2tmPDf6ocGhITNRLD7b1dYRXXzF6+4+bcPl6+9/dFPLrbfdRcJ1cxtOX7fne9/4EI6bMhMTE+qt/+etN//0x999PaLzFJRHZGI9Zq0minzruGmUqvmy1jJJnYv/MDjGxL5K3BNmgABsBqsTYIO4x0v4gIsxDkYrlDI4iYCvfOs7avPO3V/NpLwlU7va1gKbtJKENeDuvOvua4fHy586Nlqlv28QJRQm0ngJl6PHj/KrX+Ve1dM1tekv3/jaWyYiPjYxOpohKFwVhmX72c/+Q8bIxPuGi6Lhrgc3ztq159iZKSE2CUgez5XminT2TXfedc8/7d7TS6jDlkpQtbiisOXIUfe/bvvp5wf6R98+NhFSLpWIXLUvk4r+6y1v+6sP/+rXv6lc95o3v+zC06dt+lq9qDrSYI0gmUjjYnClRkorrRXW1pqWn6OGTPZMmt+xVY3BaI2SHsIoEAIpHSITYqzAcVwsgijU/OzW+zh6vJe6tGcXzp0V6ziZwejYuXzykac52j9GLpJYx8NxEoQ2pL2t9fC5Z67ccWj3nhl79uy6KLq1PLD6zPO+67nqUZlouLpohf3Kt76flonMWwLV0JwrRwR+QHs2US0lOksH+sbmDQ8Pv3vRwkUPXHTVtffe+otbxfZdO1UqW392sVz9zMDIyNl3P/gAoXERToalS5bjk2Ta1Knf6Onu/lZPT48JfGPXrlql/CBEYvCrZXRYpVIqHXFdb7iaC2ZEkUUpl8CYONo8YUTFbxsHhERJicASGU0UWbSe7L+KM29aQ6QFkQ7R1taI7vFWj8IIHUYALJg311+0cH5+0cK5+bbWRm117Ii2tjUVr33tq9/rCPG5TDqVL5fzxWJhlGoQEhisla7oHxyzQ8Pj4chojqqvMUgSqXRGYOqqVWNK5aqTcNU7N2xYH9TVpb+fSbhIraOmuoydNqUzN3/O9Pyi+dPzHa0Zf/HCWdXzzlwndu0+8horU3+3a8/B65cvWWhd170FQaC1prWxIThl1Yp8V2f3T0PVseXosX5RqYaEkUY6tSAWEWeEEL+DAmEsxpgTkYJ0ExiUtkJpZExtdxJpnERGP/ybH0Q4wmoBESa6/anDRhNZ5Tnm/f/4b8yfPf3GBfNmL184f+6Kpuamp5CCKIqo+tUljz726JWXX3HJre3trSsTCefvp3TNdoMwXFQqlm216kdBrjdyhLBKxLRZQp9jR47s37Z1yx6BtdVSma3PPmu+e9PPgsp48Z7WuhZco+ziad2l7o7ml82d1b18wZxpy1vqM185fvjAp5bP7qre//CTr37goSf+8qFHN74u4Xn6V3fdfXddtjG0SLlq2aLvn7Jm5fLLL73oE+l0etUDDz2ydHS8gEDVQr1JHVdzgOuaZ/5DNSJ2gEXMf5WTxGJpUEqTqa/P5kvllbt3H1g4Np7H8ZRcunhh6+rTzz3v0LGBdZGx6Xnz5rcM9h46e/eBo+vbOqa2tbc2LdMmOs9JZ07DTa7r7Rs4bSxXyErpMpHPoUN/XVPz1K5T15/Tt2LN8usfevTO1xw9OvQXocZbv25918Ilqy/ce+DQ6kh4rhUOQghaGtLJ6dO65horLty7/9C8wDeJnu4Zc1pauy/qOz6yIJ1q8s46+8pZOkxsSHmNp2UbutYVy+Fp6bqWWesvvPqszdt2ntY/NJYxwpHbDvTNmDNv0SUT+dKyyMqWvYePrx0emzht14Ej52zesv3j+/cfu3A0VwbHxdQaf4WVSBMxpb0R0T77LJurgE2lCK0fJyatE+fPCHCcKtlsCoFLYSJERxYhDI0NcYfKeMVgoojmjIurBOPFKgkvQZ0bkbQ+vpH4QlGo+gRaAi7WlHGcgK6WLpJOYlQ5lZahkV4KRRfcFPV1SYgC8kUf3yaxbhqBJmWrtDQkqYQBuVIVTzjUZ+pBuhTyRVKeS9rzEDYCCSFQNRaExJGKYjFPFIW4SpKtz4C1lMsl0ukkjpJgDdpGFIsVoiCBxkMLMA5YIePEqF9i7fKZiM4559jxiiXyPLSKixpict6RiGIri0ZYGWcUJnvcrY47U1QarEXqCgqDcFPo0MfVRToaPLLNbX6+GkZ+pDNjE2UQCbyEJZ2yBKWQoFQlnbE4SYvRWUbzJerrPNKeAuEQksa6KUoTYySoknItOC6R9FBSUa1W8YOI+nQGTIQjTMw8Uoqqtozny2jh1loqJ1Oyk1SHWgvcSfxfIXS8GU0ag4uRFqNi0qHQAiessGbJDJzJ3nRrJ2urk+MyJluqVS0eqLUnitoJCOJWdBWneGzcykuEj1QRc2dPr1x54ZlPul7yX+979Nn9c+fPe+9DDz163tHe/jnT5845/ppXv2zvw/c8NPWBe+6bN3/u4v5Lrzx/965dfV333nffgrPPXDu4bNH8nUYLfJHEN4pH7r1zcVoGzgXnn71FIylpSKVS7Nq5Y/7o2Ghm3bp1zyYciQ4qCKtRiRQ79x1u+MFPbl2JkEKbWME/R0qKM9x6Mu8xOU6FMAZX1Py6SXI1Ju4Bk3EaTcqanxLTxUytEdfWZhJNXhOFRcXZ2BPXSSAIY4kUIYKImKgX4nnWzF0w69Mf+tC7L9q+6YG71ixIHb7xU+9915kbVt/Q1V7Pnm1P/+LDb7zq/McfuueLSc8wNtj36w+/7Y3nj/T1frY1m6Ah5dz7wXe+4fxz1q2+uDlprkxTuDKhJx4MC8NP/u1fvvH8Ky8+56L2+sSV9ThXJk1wZ6MrtmeVuWrB9I7LP/TON53/9jdfd1F7Q+bKO2+/7QMiDIwwtVkDk71akwNdhJwMEuOHdTA48fgZoWpNIzWrYE08xol45JqTSiYQpfKJURjPmY/JayNrYh6/Hs/uEHE63DrxwwiE0fGgFy3o7Ooy+YngN7sP9AY7d+y7uVINV//nD773qqsuO7e6d9dWjvXusUIIk2yZapNeAnTSCiHMuVe8xoIhstIKIcyGC686zyjv8+XAUi6MdzckxANCCHPOldeeGWn5FRMmqVTKXdWgmDg+MPZER1t241UXnPum173jr1cOj+ZvamyaUjcyMaAgHVtm9El0VVFjmD9XgImfq1hwXljuOpHNhra2VpxpU1s4PjIKNo0UHmayclsbWPC8LzhR7Yrz+UJOMoAsRjpIG0EUkvYkbY1Z8dnPfJFsJjH94MHDiz72j//+oZ6pPW1D4zkSXooIwJak6ybj9C/gSIvRgqDWSrpr/64mLVKLApPCEZZMd5MF2LxlS1aI5CJjkhjhEtqIY0NDi2Z2t4wAbN2xLzM8VlgyUjQYrz52J8RkIrymjk4ShrgWY56bliFcnmvDjMdpSBFzUww+uYmxnzid7Y37lIzmSmFrE2uiE5MeqKnTEy7MpBSK+D1x6KY5MRlGSBxXcPTwQWH8/NwrLr/kyY468+GBnP+dLdsOvHr3jn0EyJj2AKxZs6LP9RofbW2esmfXs48j0LjCkopxZO2pKwZzJfFoNci0jA/1LQiDSvy5FStHIqMeDYzL/sP9swrjuS7pSMIwMgCRtjY0QhvpKlNLf5/YPSc/ToRSky68rXUTihiHE0JUU2cKEo7i6Wefvt3Z+Ozmz3iee6Ova9Wwk3j+9kRjv3hON0wCaO3zvGdhY32BcAmiSOUnip8bGxtbes55V3+jrj772sZbb7v22SeeeOfuQ70pUau7ffub3/ploBN3BxUb/eTmG4iiClZXUTYWuQ/+7XsfrASpi7ZtO3r1r27/+fcKowcB+OS//ONGx0tfFNoUGy648gtSybdhLVFkTgB0ojPQihMzjk7snufViCeFgd86RM0SWyNqGy2ipbWRpfNXuM4FF5zL/Y8+Rb4/H+uoyQkP9mTQTjY7tYqWJR4XxuQEGLA2LuZ4XpqxfLHz/gcf/sDxvt71kuj622/59t++7//8vakEwfsPHT8GwHdv/t7VVqQ/gnBvBf7RS7rguoQinvnxk5/fcT6y/tP5smo8PjhCUsWq4cc/+/l6pPcfxiaZO2Na996jx2puhDwZiliSxGSR5YVsrFo178SUoJP1++SUqskuGJDG4iBobWoaueKySweddaetfXrLzn1bnMHc8sCGTE5peD5Y4iQaxHNZgskQxE6ObxEWayBTl+HsM84Jo6DgbNn05IaZ0zu+94Vv/Mf15559xg+f3LTtFeKoUQA3fPUbrcqrX97a1vksAI7AKkVQ0z+3/OBnTUaklkciAzpidncrADf/4McNfhAtF9Yl1A5CxXUBx3WeO+0T5zpZYJ4UhJOAmaxi/ZbITQqERFoVDz2IqqRSDkk3cc+FF5z3aykEW7q7O7dnkgphJmeD2Od+/ARo4kQdUpg4pDdSxlqgVte0WIS0dHS06SVLlrzljA2nfqg+k6j61cLp47mxmY3NrUcibcccNyEAtFY2jATaOAagXK0Qhj7CBAC0NTSKxkyKhrRLxpPIKN7C7S2Normxjmx9inQ2jUHHM+bkpD6ugSN0rTKv441i44Y4JYgrbRgwUa2zZrLpd1IVxQwFrEBacLHUJ5xw7epVB2e01hvn9a+4jE/dcNNvtu7cdfVE71BGyJqPJmStnhiLqrAxYI4rwUaxgywluC5RFBsIpSQi0pQnRu09996131Xyu0nXDk3vmdozf8GcPYeOHH1NXX3DynzRf+wDn/wqX/zsJ4ynXELj2Pd87Ivs2PmgdkSZtGPsBz7+JQqju58tR3y0qhUDR49dGxYn5N9/4kYG+zZv9zUf9a3LeFVe8fgzz55aLuUJrbbv+djn+M1992krRVw2lBIbaaj1p0pdMwTComQshZPldlMLz4wJAYUQAtBIEyF1lZ6uKYOe4ktQS50vWjTvtpXLFr6n9/jxtQEGK0X8YeGckD4p4jKiieJ5bGAwUhFFVRBxg+ykYA4MDzmptPqnhfNmfOzuH9x9cwEy//6lb52xf9f292zbfUg0tk/tyGQya3pmLZjRP1TATTW01dWl13jp1tmBLRFot7Uuk14jxTyTdtTtvoV8rnx6gNtSn8msMd3LTFH7t6dSSaKjA0sQ6lSpPJRKZDOZ9Jo5c+YtGtu8XVgdIpVAqNgXlQiwYVzA1hEKiXBcdBBgUSg3gdZBzBNREhP4OEpiowotDQk6Whv+ffniRaMnNra1Vlz1xrct3bH7wC29g6UlqDRhZFBOkkgbMBbPU0RhBcdqPAfWn7H+wFixNHLk8NFTR8cmkDZOeILF6ioJxzCzp9PPT+Ru6prW3R0F+qLDe486+aqkra3FLJg3Rff2HpP7D4+oqV1TTHdnvZ6oFuShY0Oqu6PbTGlq0MZoIieOTwaODSjlazFvzpyoqqtUbZWEkgyNl9Sh4yNSRwFtGdfOmdEd+caKbft6ndC6sdNqLQoHopBk0sVGPovmz7WJTPquo0d6zxkaGfesdDBWonUYk3ekgzAWzwEnLLJ22ZxNr3r5Va91VXLXm6+/KgZu04FjfOBDH2ThoqX/ctuvH/5Qb9+YNEIhpAfCQUqBjXysDvCkYfnShftPWbPiF0EUXlMNtLjtjjunV/1IhFrURDzuxhM2RAqNlZIotDjWBTdLGJaRFFFKoUU9yipkVCRQBu2mQUuEH8QVORciG48TSkQOOgiQKUVABTcKsCKJdjIoJTHlcTyhkU6CsnGxbirWyVaTEAITxZOqLzjvzPLqlcsmNm3a5Pf3D07buWe/rAQGx0vFhJzJXggMnqkye1rr6Kzu9vOvvuSSzW99/StPeISsnN3N3T/+HjNnz//svPnz/7OxoS5euIgJN5OMLylgWk+3Pe+cs48+8cjD195/569mTGlp3Dpn2lQjjcGxoITECher0hiVQassoU0h3XqsTBJoAV4SobyYA2wU2iqM8FBOGgwoBK7jIhAYbRBS1qZuWZTjYi1IoVBOBuXWgUgQRhLppEGmCbWDcjO1kLBWsYsCOtrbSCddqpXy7r5jR7/eUF93ePXqFTQ0ZLWjJDqMuSWTmk/akK7OZtafvvbWt7z9TbsnQTsB3OQxlsvnhTHvX7F41jfbGhNG2CpCWbQ1COHgSJfuru49LmIAQ4eXTB0Lo3CsWs7ZuqT1z96watOpq+b5HmVsWMJag9YCqVLoCIRycKIqSSEQ1kVaD2U0kggjFdZKpBUxPUxKjHQw1kGYuPkjLgSBFgprElRCNy5VmpiLYlEYlUArD2NCHHw8U8ZVEcmMw2VXXFRaunTh0I5tmxfUZVLd7S1NWw7u3ffU3Jkzv51NpSquEEgToYyPE1WY2dFg1q5c8s1kIvG3Y6Pj1ZOxel6l9aFf38qc5eurp69deH/g+x3FiYlV5YofT2yONAJBpVhoCkI9ePnll+dnzJ79y23bt15y9PCh+tUrl/3wgnPOeMSRpm/Prp1Lpk+bZsbHx62SSloTWzCjIxwlagylybDHIpUgqhkha2uWDRFnXsXk4NJa5OMqDBYpHaRy4xghquAqi44CDDZmPglDR3tzb7UwvlMK3YMJEZih005dc/PWTZvn5MbHN0ztnvblUjUa3Lf/4FWj47lOx0tgddx729maZe2qZd+65Nwz/6ZvaCj/sXe9hd8LHMCBrY+zcv3ZQTaTfbi9taXFhMHK3Pi4EEKglGIiX5BDo2Ozt+3anX76mafmG21aztiw4Xsrli1X+/bua9dRlDl65Oii7u6p/3rB+eeNdba3LhgfG6ZUKiAFRFojHTfmY8h4bKyxBkRMI7PUdIKJ82BCipizJgXCRlgd1RztOGkpoirYAFcampuy1GczVCslHCVobWnce86Z63cMD/avrJZL5HPj2cbG5r2zZs/NPLNpS8+eA4dXDA2PvrJ/aKQVx8EPQjzHMn/WFDasP+2bM2fN+oAjZf6f3/+OF8L028ABPHH/3SxZs776tjddf39zQ7Y9rJZXDg0OiSCKUIkk1dCQr5STfsXPdk3p7hfCCSZy+fqlS5ZsOXBw/4q9e/ZOc5SaetGFF1atDmaMDPcTVMtD8xbMf0YoOb1UKmGMjZ1mAY4DjrJEQSX2u6iNuCDuJ1WKeLprLVshiUCHSDSua5k7u4cF82bfd9raU56cMrVzyb79+9BRSMJRXWduWF/p6z2aqJYq6eaWNkZGx5e1tHdOPXDkmJgolJsLpTIIiHRIOu0xvbtj03WvuOzLb33L9f/05MZn8n//vrf8Loh+N3AAm594iJe/+g3BquWLHx4eGn4oivxFRoddxUolHtktJBjI5fKNh48cmTM0PDLHS6T3He/rmz48PNJ5+vr1w4ODAw0//elPmrVfpr216QNrTln19dGx8TVjI8NT3UQCI6C5uSH0FLs6WxuSniJRqZSRUtDSnKWlpQFrQqz2ydYlaWttIqgWmTtzGkpoZs6a+djQYN9TixbOW7h8+dKxw0cOfWfb9h1XTUzkZWQMfrksGhvqwzM2nJHv7pn5bLaxVe3ed6Blx+69ohrWqLgYpNB0d7Zwyuplz06b1vP6rvbmn0/p6gze/IpLfh88vx84gB9850aufe0bqzt2791/xvq1jymFCYPKnHJpIhVFIVZ6hJHGGggigxFyWf/gSJfrJcKuKd2f6T12/Opjx4+5K1cseWLx/Bm54aGBV6TSmSn9Q0NtfhTgOoqXv+zK0oyprTcvXTinvrU5e2h0ZGh6Y1PT7isvv2T01FNWtU7r7uLw/r2cueG08unrTnkkrBRmXnX5xYRBlb6h4bxGyL1790zfsm1b/dSe6Y+WK8HFQyPjUoj4TiTlUrkhVyhtHC9Uz9747JbW3ERRhrUpi9iItCtYMKdn7LyzTv/Wy6+89KPf/u4Pd/z065/hxq/8+/8Lmj/cWn7euhVxdlfK7d//3o/ec82VF77vvNNX7m1MWC1sADbCCAiNZevO3e7xwRFZ1cLbue/w23fuOehlG9v7O6ZM/0wuN7Fl6pSpP6lLJ8qYAGVC0D5pT5Vyo8Mfufs3v1y5ZOHcrrmzp3PFxedl+3sPZe+64xcoE351xtSOwWwq4czq7hpYu2r5bemk+9jePXvuGBwaWRxEnGGkRzUkNWP2/Pf0zJyjrPIIrSJE0T88rp7ZvO2Khx9/MpMbzykhQDkCRURLNmkvu+jsvdddc8X7bv7xL94jhNj+sQ+9/w9BArzIBpH/+PRHAPjC17/P+9726u9+/bs/vL0+m/2XvYf637FzzwFZrlQxeCjXwxrLRKEsiqXj88PAZ3pre0dv38B3Du3abOctih6dOm1WStQyExJDpVjYGAbhOZ6b0EEQDltj5rQ2N0/ZuX07B/btRwfhrsambLnqVzv6+vpfefDg4V+cvn79DfliZX0QCgI/wHPToCPnmWe2zlduEmrdNMYaQh0RRSEWi5tw0KFPxnVob2t9Zs3Kpbdedsn5N7zm0rNyHW2tXH3uKS8KtD+4VV943HnHzzjl3EvZu29v9eWvfM0j1kSPJl26c2PDzYFfTRgbuwmmRqVAKMZzOdHXP5DwtU1WAjP3WP9g20S+FOftHI/GxsaHEOL72YbGR/v6h1fu2LlnihBq47x58zcuWrSkbvrM2Qfvufe+1fX1jSI3Ubhj5+6911RDe7xvcLSlHLJUm9gCC2B4eITBwRHCyMQuiY3H7TrK4hAioiqdbfX5i87d8MSsmdPfrI25ta4uUy36mpdfuOG/A8VLbwn78V2Pcd8Dj7Bi0azMHXfec1mhWPnyzn1H28YKPohELeWl4syUlGh0zDYXIs6OWYuOQhwlC9mmxjAMfOVXyg3xjXsSQTqd+d70nh4viKJX7tqxw2tubaWhsbGyb9++dCqRsGFkowDXBYmN4mDcWIuVLob4uSRmlTvWpykrOHX1iuH29vZ3X33lZb98/8c+Wdr10K0vdfn/s166e57Yyn/d/ku+/IkP8Zlv3LL+6Wd3vHrL9t3XHO8bmuIHFqc2GgjlYJVCSoGOwhNpRWsirNZIpTC2dhMNa3GUwhhDFIUo5ca3B5DEvJYT1V+JRsXpLx0iRew4R7U8mhIWE1RorE8xvbutb+2qBT9ftWLZD9762mse+8cvfptXvOxKFk9v/d8BbvLYdnSAn//Xr3jttde5H//4P88t5PPf2nPgyGl9g7l4OqtyMSLWClYqTBghHbfGdre1ebxx3dPU7gkR5xLjovjkjBBMPEFY1MDT1qBqdwYxoUa6DsaEKBuSFBEzpzSxatniJ5oam9/yhU99cN+X//OH4VWXX8m09sz/eM1/xGZr+PgXb2L75q28/tUvn/2bux84f9/BI+/fvmffrLF8VVrpIqVDaEWtQn7ShOdasVhgEcLWbn0w2ZjGc51+kzPWa6n1mO5hTszsNGhcqWmuT5qVS+YeXDxn+uevvPT8e777w9sPrF27kr94zdV/tLX+UYGbPL730zt53Ssu4tNf+V7zs1u3vPOpZ7ZemZsorS1VAlAumpgXooWCF4wdc2yIIsQSlxuNqN1vycraENBaTt8S34/GRHHTjrTUpSStLY0bT19/ym0rl8z/6rtf/4qxX939IJdecNYffY1/EuAAvva9O9iybTv9QwNk6+pmu8r9xqZNW9f0DQ1lc4UKWnrxXUuEE2u8mgQ6popjwxoNIR5aEPeBnTSHvMbFdW2IDSs01aeYPq0zf9ralU+XS8W3BVYcaG/OsnrlUl575YV/kvX9yYA7+TjvFW/lg+97d/2Tjz953qatW6/fd/DwVQd7+1VgHbTwsDUAAaSNarM3J7f0SVWoE4UUi7ARKRmwaO50vWzxol+sWLb4uyuXLb73Xz7/H4U7f/DVP/ma/izAWWv5wtd/yPHeXi699Nz0T372i/P3HTr6nr0Hj67Nl4JsKbBxYtMS0w9ErRnD2lqnp40b1XTcrFafTtDUWJdfs3zBxrkzp3/pVa98+T0//fnt5c6Odv7y+qtrRZb/HwB38nHjLbfy2BMbWbFief2WnXvO2b33wBsPHum9IpcvOkZ4hDYZ36RCxJYzikIkIUpEpFxBV1tj1D216/aVq1bcdPEFZ9z/61/fUzh93TquOX/dn3Udf3bgIJbAd/3dv3DkeD+nrl2ZfOjhxy/K5XLvGR4dP68/FxIYB0/Gd7mMwoB0QtBYnyrMmdnz+ML5c2548+tfdefnvvLt6sql8/m7t73uzyJh/58A7uTjXR/5FDt37eEVV1w4ra9/8KO7Dxy7eO+BIz2HDh7Cc11mzZwWZNLJX7a3t35rw7q1D+/csy+/ft1a3vCyi/5Xz/t/HbjJ4y3v/TCVis/1r3nVOXff+8CM4vjIa7bt3PObc889t+/6V7/i1r/467+rLlu8kBs+/eH/7VMF4P8CkwJl2bE7DXEAAAAedEVYdGljYzpjb3B5cmlnaHQAR29vZ2xlIEluYy4gMjAxNqwLMzgAAAAUdEVYdGljYzpkZXNjcmlwdGlvbgBzUkdCupBzBwAAAABJRU5ErkJggg==';
        const LOGO_ICON_B64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAABAGlDQ1BpY2MAABiVY2BgPMEABCwGDAy5eSVFQe5OChGRUQrsDxgYgRAMEpOLCxhwA6Cqb9cgai/r4lGHC3CmpBYnA+kPQKxSBLQcaKQIkC2SDmFrgNhJELYNiF1eUlACZAeA2EUhQc5AdgqQrZGOxE5CYicXFIHU9wDZNrk5pckIdzPwpOaFBgNpDiCWYShmCGJwZ3AC+R+iJH8RA4PFVwYG5gkIsaSZDAzbWxkYJG4hxFQWMDDwtzAwbDuPEEOESUFiUSJYiAWImdLSGBg+LWdg4I1kYBC+wMDAFQ0LCBxuUwC7zZ0hHwjTGXIYUoEingx5DMkMekCWEYMBgyGDGQCm1j8/yRb+6wAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH6gEXEzoXM7+SRQAAFmZJREFUaN61mneYpFWd7z/nnPd9K3VVde6eTtMTemACGVwygooiLhhW72VXEXeVvZfwLFcfVFZBFxAFDMguK2B4dNWVFbMXMAEKK0FhcGAYhpnpnpnuns6huiu/4fzuH1Xd08Og6Lr3PP1W1VP19nl/8ftLR/FnrC1HHkd3rKieLna2+k76uFCZUyL0CaLMBoFOi8qIoACUQhTkNTKpsLuN2K0O4WNpI88c2VCemi4r++y2h/7LtKg/9R96gfyGVxMLCvGS13p8qOMXhphzrDZHWHRaDtt26bOs+K7GnUYKhmhQ2eAhE1V+lFXV347vmizefcf7uPSy9///Y6Rlw2vxbDU+axNniJu41BrvtZEyjbVtFAhoZYkrS8qEJLRFKwEUkUDZGorWoWI1IgqULDOlJCq42F97KvxyRooPzAWxwsMf2cLJl9z838fIhk0ncIY8rb4dvPaoqtNwdajdC60y6RrxiqQJWR8vcmwqx5ZUnv54gVanSsqEaASlILSaonWYDmLsr6Z4rpjhscVmhqqpFdQIWqTqSvCzhApu2ZDxH5+tOtHg1vv+fEaaNpyLiaqJkpu+uKpjH7bK7Rc0IPR4FV7XOMW5TRNsTi7S5FQxSqD2d4gxLT1MqYPGdfPIRm4fW0dcR6RNyEzoUdOfYLBTri1/rkmXvlCK3IW/ahvkS4/u/r10mt/3w10f+yg/G46TdKU9bzI3+Sbxj1Y7raBpd6pc3D7CdX07eGvrKGvjeeI6AlFYahcvc8nyBVUx/NtUP4OVNMelFrht/bM0OQHDlSQF62JRKaucs6vWrHMJnnpsKpM7a0sX+0eG/3hGHOXws5EEKiyvrnqNdwUm9tcW7WjgrMwsN/Y/zzvahml1qoAg6Jr4lVom+5AlclAVgAYGKxm+MLaOgnV4U/MEF7Xt49TMLCdlFpj2YwxXkkRKa6ucLRH6eCcqPTESNM2Y3ChWgldm5IwtAwwnj0aFhdVhouXO0Em8EbRK64hLO/Zy7eodDCTyCGAF1BKB6uXQacVvIogCRY3Zf5/u5ye5DpI64oquQdbECgjQEyvx6sYZHAXbixl8MYg2q0U7x5py7rGwef3scW0xJmanD6Fbv1RwW6traDC2XVLtt1s38QZBoYE3t0zwjvZRNELVGrQSHG3RdW8QkYPEi6pj0Yq9lUIJaIS91TTfnekCURyXWuD4hjkiNDV0U2RNlat6dvHx1TtpcYKaOTrx0yXVfGfWDfv26NXce0/i92vkX751Fimbj+fdthsDE3+X1PlUwEg1yY/nVnHfXBePLrSxs5QlF8VwtCJhImKq5hkCiNLUUfcwRw9F89nRI3hooY2YiXh/9x6Oa5ira/fg3RrLltQCHa7Pb/LNlMQgSvdbUW0NfuEXP3x4rV+ZGzyckXTbRnI9Z+FXyu8MnMS1gnFdhJSOMAhFa8gFHpN+gj3lDE8WmvhJroP751bxm0ILs2GcpLFknRBP2yU1HMKMVvCDmV5uH1tPIIZzG6e4vHs3jrLLJlgThkJEBUphNiYXyZiIJ/ItNTNTepNVZn5x/f1P/FviteSmhlYaMSQG3oCWcGPFzX4/0t4RCri4bYS3t41QjBymghjD1SSDlRRD5QZGqgnmQ7eOUKCU0O5UOSU9z1+2jHFKZoZG42NRiAhGweP5Nq4aPIYRP0lvrMxdA09zTHKOCFXDMlFYUaXAxr6NiPKc6ruVEiLRfHp0I/863o9VCkfCsZQtvC3SzhPhjp9Swa9ppG3gNJr9A24u3nV9pGOvRzQnNeS4oX87RyQW6YsV2ZRa4OTMLOc2TfKmlnFe1zTF0clF0iaiZA35yCEfuewsp/n5fDu/zbeC0nTFyjSYkK3FFq7ZexSD1RQNOuQjfTs5JzvJkgWKKEJrtlWD2NW75zbf2pKaPsnR4elKKYwSNqUW2V5sZH81iVUqbYXGhuLUfbq5P6jk9mMyQLntGMome0ZgktdbZRJpE/Kx1S9wbMM8odWIqjmvpeascR3R6VY4umGe1zZN8fqmSTYliyhRzIYOeesy4qd4KNfO7/JN5KI4t42uZ0c5jacsV3YPcXHH3npEgciaBT9y7yyGqas2J8Z+PdC0L5oPk281JjpJSQ0oUiakK+bzYK6dshhQul+7sW0lnd6ZXhjFNB1xJi2VA+6c13FdpL2TEc0FLRO8t3OoFr7UQQtULxPcNJYmx+eoVI7XNU9yenaOuBYm/Rh567DfT/CrhVamwhietvx95z4u796DpyJAEUbu9kqUunSatXc72pnbl9jAR7d9Rp3d8uP/qbU9eiUAdMXKTPlJnik0IgpXRJLtMvFD1doX6qJqYDrRu8Vq9zxB0eT4/E37MDEVUUPUV8piFBGK0EJMhZzQMMsN/c9x2/pn6fEqANj6fWkTcUImR1xFNXiuIVUW8fv3T+VkfLFMmF/kLV2fdiIl2aWYpBA0glHCqdlZGkxYe65yzirqphNLpNB524WvvDdaZdoRxemZWY5JzWNRB4MdrIgTL7dWYK3ArlKGb0z2MRF4AHiqFm9mQ48PDW3hG1NrCUWjlKBV1KUVzQ/vO8Ke/+MX1S+f7NGdwZTriM2oOggIiu2lJj6+bwvX799IyZo6KOpsFfeCYt8nUF0bX904o1p+5CvvDEdZbl/7LG9uGSG0uh6Q61JRf1gzGqEshvvnurn9wHr2VGpZ7dpYkSu7B9lWyPIfMz2UxZBUEZd1DXFp5yA6Ul+Z9lv+ocEpFxS636VweRDpp1Ox8JqYEx495if5xmQ//zHTzbgfByCmLAFgUTgSbG2yufOdik5tjNAbAfq8Mic0zGGlDocv0cpKzSx9v3TfjnIjd4+t4775DkrWwSjLmelZPtj7Isem5riwxTCQKPK5A+uYiWLcMbaGcqgf/sdVe69L6HKh5MdTLYm56zwTvCchlFE4v15s55aRDTxVbERE0WBCzslO87qmKW47sJ7BagpReqCivGMcX8yJVulmUByVytPhVpZTcHUoB8sMSN3VNTAeJPnOdC/fmOplxE8Aina3wrvbR3h3xxDNTpWwbl4XdwzRHSvzT/uPZLji7fzScNv77z2QOXBTxtFnDDx9mWfCd2olRJjEd2Z6uWV0A5NBHK0sr0rP879WDXFGZpK4tjyca2OwksIqnQ7FeZUTiDpOlNIgHJNcwNOWSNSKHFAO5heyVCvATBjn/rkuvjnVw/OlDBaFpyLObpzhslVDHN8wi0aI6tF9STDnNo4RJ5z5+J51V2/JRL+79+QnuGP36vOME35IK+sGYvjixHpuH1tLIXJo0CHvbB/m71cN0uGWiagliEencnxvdtWSrxzvoJyNAB6WdYn8y4DSQRPSWpgP4/x8vpNvTPWyrZglEI1C2JxY5G8793F+yxgZ42OXEseXuFYouvqqZO7Ge1v8+y+YdWn46ZlHZjz3kzHXtpzbNMGd4+u5fWwdZWvo9Cp8sHs3b20dxlWWaDmLsKyNF/GUxUdjlRlwLKyCWsDp9CqI1PxArUjLDZC3Dg/lOvn6VB9PFRrxrUEhrImVeEfbCH/VOkq3VyKweqwSmnlXy+blzLH+ZgXxQ/fusWr2rge9nD2r0W38zlzPTeNh/KjPHBjgyXwL35rqoWwd+mMFru/fwTnZiVrJsASO9cKtw6uSMhF+pBGlVjkiNKKgQYdknWCpPkJE0Aoi0Tyeb+GLE2t4dLGVSh36er0Sb2kZ5+1tI6yN1zQZWF0sV71rCn70VFMy+pLncMpyX0LAj9wf54P0DY1OWLm02XFm9PBVyvEu/Op0HzvLDbxYbkBEsSZW5JY12zk1M1XL1Zb8tU6XAGknIGki5iMXUFnHOCYRWnC1xVEHawqjhDE/yVcm1nLPTDfzYS0mrPIqXNg8zv9oG2YgkUchS2Zk/ci7Y6Laf09PcshfLOn3ZZLyJc+xJ4sSQmueLvuJqxOqMN2fmWZfsfrmZrdy1ZXdu/W2YiNbSxmkvv+N/c9zWmaKaJmalaYuyxAcU7U7IivGWXmbWvH+n4vt3DJyBFtLjYhAoxPwpqZx3tWxn03JRTQWC8upih86P1yspm5u8Sb8BwYzXLBu7vm5svPebEK+orXurkTJDzTG87vCKM7efPexCa/0Ca1stioGXw7S0OlVODqVW84GVsK+Ukv15ZLAZfnVCcOwgo55tXQbBM13Z/r41MgAE0Eco4ST0/Nc3jXIqZlpXBWtaDDUNgmt3lqsuB9qMMW5z+48WnnK8MVd++V9mxeeny+57zXG6d5bOOKR/vRuItGdGXfxZkdHG3wx3Dm2ju2lzLKktxcz/GR+FX/TtpdwpXDrPrtU/oeiiKRW+DlaWUcr8hGSKVvDYuRx/2QXt46uJx+5ZE3AJR37+dvOvbQ5FWw9mq5cNtJjpTB+dTY1s3sxaOWyTTvXuNZ/Y6ksX59ZYOGEu6e3A9u3XrVB8lE60e5OftTT4bka4cFcB9+b7QLg7Ows+ypJ9lZS3DvdzXlN4zQ6lcNKZlUHwqI1lKyzpJi81oppEIqR4a7xdXymzkSPV+ZT/dv5QPcuWpwKkXDYptaqsh/Grt/82fGHpvOryJdS8ZRT/XAq7t+Wbog+XvKd9FOXdsh//u8j5YbH3qlazPTfeSZ4r1bCVBDnzvG15COHDfEi16/ezttbRwHh2VKW3xRaDmkorMz1FMKsH6NolwpcO6W12N0ARTF8Z3YVC9ZhbazArWue5YLWA8vOvJIHQRBB/Mi9c2Kx9atPXTHAiZlh2hryF3vGf5fR1iS86IqObOUGFc9k+1JT3HTKv56bMP61RtkYwHdnethayOLpiPd1DjEQX+S8pnFWeRUq1uHn8+2Eh/ZGVqgF9lVSlK2peanIoNZin66hoyICutwKn1izg7OyU1gRhJXdkfpnUQSR80AxSn2yKZOrtiWmeCHoOtUz1Wu1krig0EqchGevaHRytyxUGk6JO8GntLHtChiqpvnmdC8WzWnped7UMkYkiv54kZMacoDlqUIjU0F8ufhaGdci0TxXyiJSc31DtFUbqT6pJMohNUh7f88ezsxM1nyhnpKogx5X28jq7UU/8cGEFKYdhMWwqSthKjcZZXvkEBQU4xn/PelY/nuODo+h7mP3TPYxVEmRMiGXdOyj0fiIKOI64pTMNCjhQDXBYLmh3m46RBnMhTG2FhpBCQpbMOI/rmNR6TlDtGvpplbHR6u6HtQh9gQI1prZchT7cGtz7vkZaWQkbIknnMJHHB2ehTq0OSdKoZS4jok6USiD8Hypse7gildnZzg1W48XdYVvSebJ6JCSNewspQ+iVf1FIzxXzDJYSQJgxO5NmfAZPS2nzLpEv1BYKqL5v3OdVMVhuem23EkUrGi/Gpqbnlz4iweG5/s4dc0g/d70xZ4O34Na6lxLrat4iGvWNFkVzdcm+hkP4mRNyMUd+0nVq8WljLsrVqbNrQKKvZVULelcghklhGJ4YK5z2T+MDR+e/NXPDuik8xyOBD9SYmcAHl5oY1uxCa2WavQl1FBUI/dr037LnVtS22y7M8kLI72nuab6Ua1tYrl2WW63HwxWAEbBY4tt3D/fAcB5TRP8RcNsPfAdVHra+LS5PqAY9+O1SrL+uwZeLGd4KNcOCrTYvCP+DxOnXYBORQu0+qO/c4l+DsJs4PHNyb5aUlgfxAhCaJ1flvzExxtNoZRUZRaDeHfcFD7p6Kh3JeFLviTLWXNNJ3NBjDvH17IQuaxyK1zSsXe5AbES1D0lNDo+IOQiF1+Wup1CiObfp/sYD2MAuNhHW73yk41eGX3a6gbG3TV+XKpfNhLlUMID8+38cqFjGfwiawZLYfzqZKw4VrWaBT8dT7mVj7o6OmMJVXhJJakOwX24d6aXx/ItKISL2kbYklo4JLgeTI8Er955DERj6xmvAR5fbOMH9RpES1RUQfkL+8qZ4gUnb0b/4Bc/JeXP05QffcSxwbcVQt46/POBdYwGKUT0YjlMfGRt89hTY8FajusZpTlZuNhzoktQcnjkXb5q3qsRthWb+fJEP5Fojkst8Ncd+5dhtabMw5Gp7hJ1kxImggSfP7Ce+cgDBFfCH7frxQfbnSJ3ffHzNaHPDD3CbLovSOrqbY5ELwJsLWW5bWQDU9XUP29szX5ncOFIet097JhcdVrcVK/VysaXlcFLMtT6l1rBfBjjc6MDjFaTZEzAFV176PbKhwjgYIyoseeLqfuVxSBUxfAvY+t5It8ECI6N9rlh+ZbxMFu+5qITlv0HgHZnnvnq6hfcsHyDlqgA8O3ZLl6z7UTlfTdpts375Cup7oSp3OQo27NysPPySwhFc9f4Oh5caEcp4aK2UV7TOFlHokO1sfTqi2Y+dAHImBCt4WuTa/nmdC+iQGOrnvVvLrS+7Zl2cvyfj9WGpcvd+PmpYVqakzRFMy9WnXQ6Us4pFqUCZU6MeQ3hUWrq2RNbC9e7Jnrb4dH2cCZAcc9MP587sB5fNKem57hu9Q4y9eB3cD500Mg0MBPE+epUP7nQ5aTMPDNBnFtHByhKrSL1osrdTTJ3q1veGU7t+eXyEw9JZmYHHyHntvoNNv8pN6p8SyFYZRIlFbvmV0HPPYGSd2lla9OCl2GiJt0aE9+f7eVTIxsoWoe1sRIf6XuBTrdUazWpFXOt+omCWn9D2FdJMRV4oISn883cPLqBReugEFxb/VEsXPinRUmU5377i0OefdjorcvuZ0p1V1Ql92vleKtFu5tR2hsNU+ungqS3ObVIkwmWm5kHzaIGXBbNvTN93DB8JHNhjA63yg39Ozg9M1VrHrykH7FSIErB92Z7+eViGyiYC12q9eaGDio/MaW5y0uBGbvyTIc3XLTnDzOSqwhqcT+xzs1FJyg8qt1Yl1V6c6i02l7K8HS+mRYvpC9WwlW2Jn8Bo4SCjXH3+HpuHR0gF3m0u1WuX72D85rGkBXxYuWsd5kQZZkP43x+bD0H/MQywxoR11a/Fw/zV3oNzcPR0M/49bZdh1nDy051BXjgjg/w/ceHCg2q/HBkDRH6WFHaGw/iPJRrY085Q6Mb0u5WcTQ8X27kxuFNfH2ql7J16fYqXL96B+c3jy2bG4cQX2PNKCEQwzPFZj47uoFHFltYGuJppOxG1TuyqvQhTGy8tONHhIfkAis0yyus9g1nE5eyN6db31LR8etC7WxaGng2moDTM7P0xMrcP9/BcDWBUnBMcpFr+17g1Mx0vXxeoYn6EwPRzAQxnik0c99cJ79aaGE29OoUCY6EQ56t3tioit8KlFuZ3vHTP0jnH3WE44wzX8+jj2wkPbB9XWAa/iHQ7kWRMq0rz6AsRa9WE3JF1yCnZaZpMCGujkBqQ9B85DIZxBmqpNhezPJsMcu+arLWYlK1VoYRmzfW/27cFj/9wDmjOy55skt2P/PgK9L4Jx2qWTXwGpImcscC7/jITfxdZLy/tJhOOXguo55iCAkdkTLR8qAzEk3RakqRQ1X0ikFp/aSQRAvaBr9wovJdHbHqowUbq8zs+MkfTduffMwJoGPgdFImcGek+YhAeeeFyrzBanOURbcISr/y1kuQa/PaRruMRA/GxP9hVhWfCb1UOf3s/ez6Ywj5cxlZWucfNcB93bvo2Xd2ukhiU6DdUyLMSaGoI9GmV6AxstZFwGgdgc0rYcIQ7THKbnWxjzlB4ZnM2BPT1YZeOTC5+79My/8DNXe4ltI+5SwAAAAedEVYdGljYzpjb3B5cmlnaHQAR29vZ2xlIEluYy4gMjAxNqwLMzgAAAAUdEVYdGljYzpkZXNjcmlwdGlvbgBzUkdCupBzBwAAAABJRU5ErkJggg==';

        /**
         * Render the shareable Top 10 picks into #shareTopTen
         * @param {string} mode - 'desktop' or 'mobile'
         * @returns {Promise<Object>} { success }
         */
        async function renderShareableTop10(mode = 'desktop') {
            const container = document.getElementById('shareTopTen');
            if (!container) return { success: false };

            // Get top 10 picks from state.games (which already have analysis)
            const allPicks = [];

            // Get today's date range for filtering (same as Best Bets tab)
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            // Collect all picks with valid win probability from state.games
            if (state.games && state.games.length > 0) {
                for (const game of state.games) {
                    try {
                        // Filter to only include games from TODAY (same as Best Bets tab)
                        const gameDate = new Date(game.commenceTime);
                        if (gameDate < today || gameDate >= tomorrow) continue;

                        const analysis = game.analysis;
                        if (!analysis || analysis.error || !analysis.hasData) continue;

                        // Add spread pick if it qualifies (same criteria as Best Bets tab)
                        if (analysis.spreadPick && analysis.spreadWinProb >= 54 && analysis.spreadEdge >= 2) {
                            const spreadLine = analysis.spreadPick.line;
                            const lineDisplay = spreadLine > 0 ? `+${spreadLine}` : `${spreadLine}`;
                            allPicks.push({
                                game,
                                analysis,
                                type: 'spread',
                                team: analysis.spreadPick.team,
                                line: lineDisplay,
                                winProb: analysis.spreadWinProb,
                                edge: analysis.spreadEdge || 0,
                                confidence: analysis.confidence
                            });
                        }

                        // Add total pick if it qualifies (same criteria as Best Bets tab)
                        if (analysis.totalPick && analysis.totalWinProb >= 54 && analysis.totalEdge >= 3) {
                            allPicks.push({
                                game,
                                analysis,
                                type: 'total',
                                team: `${analysis.totalPick.pick} ${analysis.totalPick.line}`,
                                line: analysis.totalPick.line.toString(),
                                winProb: analysis.totalWinProb,
                                edge: analysis.totalEdge || 0,
                                confidence: analysis.totalConfidence
                            });
                        }
                    } catch (e) {
                        console.warn('Error processing game for share:', e);
                    }
                }
            }

            // Sort by win probability and take top 10
            allPicks.sort((a, b) => b.winProb - a.winProb);
            const top10 = allPicks.slice(0, 10);

            if (top10.length === 0) {
                container.innerHTML = '';
                return { success: false };
            }

            // Generate timestamp matching screenshot format
            const now = new Date();
            const timestamp = now.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            }) + ' ' + now.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit'
            });

            // Calculate summary stats for today's picks
            const avgWinProb = (top10.reduce((sum, p) => sum + p.winProb, 0) / top10.length).toFixed(1);

            // Get historical performance data from predictions database
            let overallWinPct = '--';
            let yesterdayWinPct = '--';
            let yesterdayRecord = '--';
            let overallROI = '--';

            try {
                const allPredictions = await getAllPredictions();
                const graded = allPredictions.filter(p => p.status === 'graded');

                // Overall stats
                const overallWins = graded.filter(p => p.result === 'win').length;
                const overallLosses = graded.filter(p => p.result === 'loss').length;
                const overallTotal = overallWins + overallLosses;

                if (overallTotal > 0) {
                    overallWinPct = ((overallWins / overallTotal) * 100).toFixed(1);
                    const roi = ((overallWins * 0.91 - overallLosses) / overallTotal) * 100;
                    overallROI = `${roi >= 0 ? '+' : ''}${roi.toFixed(1)}`;
                }

                // Yesterday's stats
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toISOString().split('T')[0];

                const yesterdayPicks = graded.filter(p => {
                    const gameDate = p.gameDate ? p.gameDate.split('T')[0] : '';
                    return gameDate === yesterdayStr;
                });

                const yWins = yesterdayPicks.filter(p => p.result === 'win').length;
                const yLosses = yesterdayPicks.filter(p => p.result === 'loss').length;
                const yTotal = yWins + yLosses;

                if (yTotal > 0) {
                    yesterdayWinPct = ((yWins / yTotal) * 100).toFixed(0);
                    yesterdayRecord = `${yWins}-${yLosses}`;
                }
            } catch (e) {
                console.warn('Could not load prediction stats for share:', e);
            }

            // 10 unique emoji reasoning pairs - kept short to fit
            const emojiReasons = [
                { emoji: '', text: 'Algorithm edge' },
                { emoji: '', text: 'Strong trend' },
                { emoji: '', text: 'High value' },
                { emoji: '', text: 'Market inefficiency' },
                { emoji: '', text: 'Good probability' },
                { emoji: '', text: 'Data advantage' },
                { emoji: '', text: 'Premium pick' },
                { emoji: '', text: 'KenPom edge' },
                { emoji: '', text: 'Line value' },
                { emoji: '', text: 'High confidence' }
            ];

            // Render cards with emoji reasoning, no duplicate info
            const cardsHTML = top10.map((pick, index) => {
                const game = pick.game;
                const matchup = `${game.awayTeam} @ ${game.homeTeam}`;
                const gameTime = new Date(game.commenceTime).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                // Determine pick display - include line in label, no separate TOTAL line needed
                const isTotal = pick.type === 'total';
                let pickLabel, pickLine;
                
                if (isTotal) {
                    pickLabel = pick.team.includes('OVER') ? 'OVER' : 'UNDER';
                    pickLine = pick.line;
                } else {
                    // For spreads, show abbreviated team name + spread line prominently
                    const teamName = pick.team;
                    // Abbreviate long team names to ensure spread is visible
                    const maxTeamLen = 18;
                    const shortTeam = teamName.length > maxTeamLen ? teamName.substring(0, maxTeamLen) : teamName;
                    pickLabel = shortTeam;
                    pickLine = pick.line;
                }

                // Calculate model projection text (no edge here since shown in metrics)
                let modelText = '';
                if (isTotal) {
                    const projTotal = pick.analysis.projectedTotal;
                    if (projTotal) {
                        modelText = `Model projects ${projTotal.toFixed(0)} pts`;
                    }
                } else {
                    const projSpread = pick.analysis.projectedSpread;
                    if (projSpread !== null) {
                        modelText = `Model projects ${projSpread > 0 ? '+' : ''}${projSpread.toFixed(1)} spread`;
                    }
                }

                // Tier badge - calibrated thresholds (62%+ Best Bet)
                const tier = pick.winProb >= TIER_THRESHOLDS.BEST_BET ? 'BEST BET' : pick.winProb >= TIER_THRESHOLDS.ELITE ? 'ELITE' : pick.winProb >= TIER_THRESHOLDS.HIGH ? 'STRONG' : 'VALUE';
                const tierClass = pick.winProb >= TIER_THRESHOLDS.BEST_BET ? 'bestbet' : pick.winProb >= TIER_THRESHOLDS.ELITE ? 'elite' : pick.winProb >= TIER_THRESHOLDS.HIGH ? 'strong' : 'value';

                // Basketball rating for Best Bets (62%+) - stored as data attribute for canvas
                const rating = getEliteRating(pick.winProb);

                // Get emoji reason for this pick
                const reason = emojiReasons[index];

                // Shorten team names if needed to fit time
                const shortenTeam = (name) => {
                    if (name.length > 18) {
                        return name.substring(0, 16) + '...';
                    }
                    return name;
                };
                const shortMatchup = `${shortenTeam(game.awayTeam)} @ ${shortenTeam(game.homeTeam)}`;

                // Generate basketball rating HTML for export using logo basketballs
                const ratingHTML = rating > 0 ? (() => {
                    const fullBalls = Math.floor(rating);
                    const hasHalf = rating % 1 !== 0;
                    let balls = '';
                    for (let i = 1; i <= 5; i++) {
                        if (i <= fullBalls) {
                            balls += basketballSVG(16, true);
                        } else if (i === fullBalls + 1 && hasHalf) {
                            balls += basketballSVG(16, true).replace('style="', 'style="clip-path:inset(0 50% 0 0);margin-right:-8px;');
                        } else {
                            balls += basketballSVG(16, false);
                        }
                    }
                    return `<div class="ss-rating-display">${balls}</div>`;
                })() : '';

                return `
                    <div class="ss-card" data-tier="${tierClass}" data-rating="${rating}">
                        <div class="ss-card-rank">${index + 1}</div>
                        <div class="ss-card-content">
                            <div class="ss-card-top">
                                <div class="ss-card-left">
                                    <span class="ss-pick-label">${pickLabel} <span class="ss-pick-line">${pickLine}</span></span>
                                    <div class="ss-matchup">${shortMatchup}</div>
                                    <div class="ss-game-time">${gameTime}</div>
                                    <div class="ss-emoji-reason">${reason.emoji} ${reason.text}</div>
                                </div>
                                <div class="ss-card-right">
                                    <span class="ss-tier-badge ${tierClass}">${tier}</span>
                                    <div class="ss-win-prob ${tierClass}">${pick.winProb.toFixed(1)}%</div>
                                    <div class="ss-win-prob-label">WIN PROB</div>
                                </div>
                            </div>
                            <div class="ss-card-bottom">
                                <div class="ss-model-text">${modelText}</div>
                                ${ratingHTML}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="ss-container ss-${mode}">
                    <div class="ss-header">
                        <div class="ss-header-left">
                            <img src="${LOGO_BADGE_B64}" alt="The Spread Sheet" class="ss-header-badge" />
                            <div class="ss-header-titles">
                                <h1 class="ss-title">Today's Top 10</h1>
                                <p class="ss-subtitle">NCAAB Best Bets  KenPom-Powered Analysis</p>
                            </div>
                        </div>
                        <div class="ss-header-right">
                            <div class="ss-date-badge">
                                <span>${timestamp}</span>
                            </div>
                        </div>
                    </div>

                    <div class="ss-stats-bar">
                        <div class="ss-stat">
                            <span class="ss-stat-value highlight">${overallWinPct}%</span>
                            <span class="ss-stat-label">OVERALL WIN %</span>
                        </div>
                        <div class="ss-stat">
                            <span class="ss-stat-value">${yesterdayWinPct}%</span>
                            <span class="ss-stat-label">YESTERDAY WIN %</span>
                        </div>
                        <div class="ss-stat">
                            <span class="ss-stat-value">${yesterdayRecord}</span>
                            <span class="ss-stat-label">YESTERDAY RECORD</span>
                        </div>
                        <div class="ss-stat">
                            <span class="ss-stat-value ${overallROI !== '--' && parseFloat(overallROI) >= 0 ? 'positive' : ''}">${overallROI}%</span>
                            <span class="ss-stat-label">ROI</span>
                        </div>
                    </div>

                    <div class="ss-cards-grid">
                        ${cardsHTML}
                    </div>

                    <div class="ss-footer">
                        <div class="ss-footer-left">
                            <div class="ss-disclaimer">
                                For entertainment only. Not financial advice. Please gamble responsibly.
                            </div>
                        </div>
                        <div class="ss-footer-center">
                            <img src="${LOGO_ICON_B64}" alt="The Spread Sheet" class="ss-footer-icon" />
                        </div>
                        <div class="ss-footer-right">
                            <span class="ss-tagline">DATA DON'T LIE</span>
                        </div>
                    </div>
                </div>
            `;

            return { success: true };
        }

        /**
         * Lazy-load html-to-image library
         * @returns {Promise<Object>} The library object
         */
        async function loadHtmlToImage() {
            if (window.htmlToImage) return window.htmlToImage;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/dist/html-to-image.min.js';
                script.onload = () => {
                    // html-to-image UMD exposes as window.htmlToImage
                    console.log('[ShareTop10] Script loaded, checking globals:', {
                        htmlToImage: typeof window.htmlToImage,
                        toPng: window.htmlToImage?.toPng ? 'exists' : 'missing'
                    });
                    if (window.htmlToImage && typeof window.htmlToImage.toPng === 'function') {
                        resolve(window.htmlToImage);
                    } else {
                        reject(new Error('html-to-image loaded but toPng function not available'));
                    }
                };
                script.onerror = (e) => {
                    console.error('[ShareTop10] Script load error:', e);
                    reject(new Error('Failed to load html-to-image library from CDN'));
                };
                document.head.appendChild(script);
            });
        }

        /**
         * Canvas-based fallback capture for file:// protocol
         * Renders content to canvas without external resource fetching
         * @param {HTMLElement} element - Element to capture
         * @param {string} mode - 'desktop' or 'mobile'
         * @returns {Promise<string>} Data URL of the captured image
         */
        async function captureWithCanvas(element, mode) {
            const scale = 2; // 2x for retina
            const width = mode === 'desktop' ? 1000 : 540;
            const height = mode === 'desktop' ? 980 : 1550;

            // Screenshot-matching color palette
            const colors = {
                bg: '#f5f5f5',
                bgCard: '#ffffff',
                navy: '#1e3a5f',
                orange: '#ff8c42',
                gold: '#f59e0b',
                green: '#22c55e',
                text: '#1e3a5f',
                textMuted: '#64748b',
                textLight: '#94a3b8'
            };

            // Helper to load image from base64
            const loadImage = (src) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = src;
                });
            };

            // Load logo images
            let logoBadge, logoIcon;
            try {
                [logoBadge, logoIcon] = await Promise.all([
                    loadImage(LOGO_BADGE_B64),
                    loadImage(LOGO_ICON_B64)
                ]);
            } catch (e) {
                console.warn('Failed to load logo images for canvas:', e);
            }

            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = width * scale;
            canvas.height = height * scale;
            const ctx = canvas.getContext('2d');

            // Fill light gray background
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scale for retina
            ctx.scale(scale, scale);

            // Header area
            const headerY = 28;
            const padding = 36;

            // Draw badge logo on the left
            let titleStartX = padding;
            if (logoBadge) {
                const logoH = 70;
                const logoW = logoH * (logoBadge.width / logoBadge.height);
                ctx.drawImage(logoBadge, padding, headerY - 8, logoW, logoH);
                titleStartX = padding + logoW + 14;
            }

            // Draw title (after badge)
            ctx.fillStyle = colors.navy;
            ctx.font = 'italic bold 40px Georgia, serif';
            ctx.textAlign = 'left';
            ctx.fillText("Today's Top 10", titleStartX, headerY + 30);

            // Subtitle
            ctx.fillStyle = colors.textMuted;
            ctx.font = '13px sans-serif';
            ctx.fillText('NCAAB Best Bets  KenPom-Powered Analysis', titleStartX, headerY + 52);

            // Draw date badge (no icon)
            const now = new Date();
            const timestamp = now.toLocaleDateString('en-US', {
                weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'
            }) + ' ' + now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

            const badgeWidth = 180;
            const badgeY = headerY + 8;
            ctx.fillStyle = colors.navy;
            roundRect(ctx, width - badgeWidth - padding, badgeY, badgeWidth, 34, 8);
            ctx.fill();
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(timestamp, width - badgeWidth/2 - padding, badgeY + 22);
            ctx.textAlign = 'left';

            // Get picks data from the rendered element
            const cards = element.querySelectorAll('.ss-card');

            // Get stats from the rendered stats bar
            const statEls = element.querySelectorAll('.ss-stat-value');
            const overallWinPct = statEls[0]?.textContent || '--';
            const yesterdayWinPct = statEls[1]?.textContent || '--';
            const yesterdayRecord = statEls[2]?.textContent || '--';
            const overallROI = statEls[3]?.textContent || '--';

            // Draw stats bar
            const statsY = headerY + 95;
            const statsHeight = 58;

            // Orange border
            ctx.strokeStyle = colors.orange;
            ctx.lineWidth = 2;
            roundRect(ctx, padding, statsY, width - padding * 2, statsHeight, 12);
            ctx.stroke();

            // Navy fill with gradient
            const navyGrad = ctx.createLinearGradient(padding, statsY, padding, statsY + statsHeight);
            navyGrad.addColorStop(0, '#1e3a5f');
            navyGrad.addColorStop(1, '#2a4a70');
            ctx.fillStyle = navyGrad;
            roundRect(ctx, padding, statsY, width - padding * 2, statsHeight, 12);
            ctx.fill();

            // Stats content
            const statWidth = (width - padding * 2) / 4;
            const roiPositive = overallROI.includes('+') || (parseFloat(overallROI) >= 0 && !overallROI.includes('-'));
            const stats = [
                { value: overallWinPct, label: 'OVERALL WIN %', color: colors.orange },
                { value: yesterdayWinPct, label: 'YESTERDAY WIN %', color: '#ffffff' },
                { value: yesterdayRecord, label: 'YESTERDAY RECORD', color: '#ffffff' },
                { value: overallROI, label: 'ROI', color: roiPositive ? colors.green : '#ffffff' }
            ];

            stats.forEach((stat, i) => {
                const x = padding + statWidth * i + statWidth / 2;
                ctx.textAlign = 'center';
                ctx.fillStyle = stat.color;
                ctx.font = 'bold 24px sans-serif';
                ctx.fillText(stat.value, x, statsY + 28);
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '9px sans-serif';
                ctx.fillText(stat.label, x, statsY + 46);
            });
            ctx.textAlign = 'left';

            // Draw cards with improved spacing
            const cardStartY = statsY + statsHeight + 16;
            const cardGap = 10;
            const cardWidth = mode === 'desktop' ? (width - padding * 2 - 12) / 2 : width - padding * 2;
            const cardHeight = 105;

            cards.forEach((card, index) => {
                const col = mode === 'desktop' ? index % 2 : 0;
                const row = mode === 'desktop' ? Math.floor(index / 2) : index;
                const x = padding + col * (cardWidth + 12);
                const y = cardStartY + row * (cardHeight + cardGap);

                // Get card data
                const tier = card.dataset.tier || 'value';
                const isBestBet = tier === 'bestbet';
                const isElite = tier === 'elite';
                const isTopTier = isBestBet || isElite;

                const pickLabelEl = card.querySelector('.ss-pick-label');
                const pickLineEl = card.querySelector('.ss-pick-line');
                const matchupEl = card.querySelector('.ss-matchup');
                const gameTimeEl = card.querySelector('.ss-game-time');
                const emojiReasonEl = card.querySelector('.ss-emoji-reason');
                const winProbEl = card.querySelector('.ss-win-prob');
                const modelTextEl = card.querySelector('.ss-model-text');

                // Get pick label parts - team name and line separately
                const pickLine = pickLineEl?.textContent || '';
                const fullLabel = pickLabelEl?.textContent || `Pick ${index + 1}`;
                // Remove the line from the full label to get just the team/pick name
                const pickName = fullLabel.replace(pickLine, '').trim();
                
                const matchup = matchupEl?.textContent || '';
                const gameTime = gameTimeEl?.textContent || '';
                const emojiReason = emojiReasonEl?.textContent || '';
                const winProb = winProbEl?.textContent || '50%';
                const modelText = modelTextEl?.textContent || '';
                
                // Get rating from data attribute
                const rating = parseFloat(card.dataset.rating) || 0;

                // Card background with shadow
                ctx.fillStyle = colors.bgCard;
                ctx.shadowColor = 'rgba(30, 58, 95, 0.12)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetY = 3;
                roundRect(ctx, x, y, cardWidth, cardHeight, 12);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;

                // Left border color based on tier
                ctx.fillStyle = isBestBet ? colors.gold : (isElite ? colors.orange : colors.navy);
                ctx.fillRect(x, y + 8, 5, cardHeight - 16);

                // Rank square/badge
                const rankSize = 48;
                ctx.fillStyle = colors.navy;
                ctx.fillRect(x + 5, y, rankSize, cardHeight);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(String(index + 1), x + 5 + rankSize/2, y + cardHeight/2 + 7);
                ctx.textAlign = 'left';

                // Right side - Tier badge, Win Prob, and Rating (vertically stacked and centered)
                const rightX = x + cardWidth - 55;

                // For Best Bets: BEST BET at top, WIN PROB in middle, basketballs at bottom
                // For others: tier badge and WIN PROB centered
                if (isBestBet && rating > 0) {
                    // BEST BET badge - at top
                    ctx.fillStyle = colors.gold;
                    const tierBadgeWidth = 58;
                    roundRect(ctx, rightX - tierBadgeWidth/2, y + 10, tierBadgeWidth, 16, 4);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('BEST BET', rightX, y + 21);

                    // Win Prob - in middle
                    ctx.fillStyle = colors.gold;
                    ctx.font = 'bold 20px sans-serif';
                    ctx.fillText(winProb, rightX, y + 46);

                    // WIN PROB label
                    ctx.fillStyle = colors.textLight;
                    ctx.font = '7px sans-serif';
                    ctx.fillText('WIN PROB', rightX, y + 57);
                    
                    // Basketball rating at bottom - draw actual logo-style balls
                    const ballSize = 14;
                    const fullBalls = Math.floor(rating);
                    const hasHalf = rating % 1 !== 0;
                    const totalBalls = 5;
                    const spacing = 1;
                    const totalWidth = totalBalls * ballSize + (totalBalls - 1) * spacing;
                    const startX = rightX - totalWidth / 2;
                    const ballY = y + 72;
                    
                    for (let i = 0; i < totalBalls; i++) {
                        const bx = startX + i * (ballSize + spacing);
                        const isFilled = i < fullBalls;
                        const isHalfBall = i === fullBalls && hasHalf;
                        const cx = bx + ballSize/2;
                        const cy = ballY + ballSize/2;
                        const r = ballSize/2 - 1;
                        
                        if (isFilled) {
                            // Full filled ball with logo design
                            ctx.fillStyle = colors.orange;
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.fill();
                            // Seams
                            ctx.strokeStyle = '#1e3a5f';
                            ctx.lineWidth = 0.8;
                            ctx.beginPath();
                            ctx.moveTo(cx, ballY + 1);
                            ctx.lineTo(cx, ballY + ballSize - 1);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(bx + 2, cy);
                            ctx.lineTo(bx + ballSize - 2, cy);
                            ctx.stroke();
                            // White trend arrow
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1.2;
                            ctx.beginPath();
                            ctx.moveTo(bx + 3, ballY + 10);
                            ctx.lineTo(bx + 6, ballY + 6);
                            ctx.lineTo(bx + 8, ballY + 8);
                            ctx.lineTo(bx + 11, ballY + 4);
                            ctx.stroke();
                        } else if (isHalfBall) {
                            // Half ball - filled left, empty right
                            // Draw filled left half
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(bx, ballY, ballSize/2, ballSize);
                            ctx.clip();
                            ctx.fillStyle = colors.orange;
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#1e3a5f';
                            ctx.lineWidth = 0.8;
                            ctx.beginPath();
                            ctx.moveTo(cx, ballY + 1);
                            ctx.lineTo(cx, ballY + ballSize - 1);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.moveTo(bx + 2, cy);
                            ctx.lineTo(bx + ballSize - 2, cy);
                            ctx.stroke();
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1.2;
                            ctx.beginPath();
                            ctx.moveTo(bx + 3, ballY + 10);
                            ctx.lineTo(bx + 6, ballY + 6);
                            ctx.lineTo(bx + 8, ballY + 8);
                            ctx.lineTo(bx + 11, ballY + 4);
                            ctx.stroke();
                            ctx.restore();
                            
                            // Draw empty right half
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(bx + ballSize/2, ballY, ballSize/2, ballSize);
                            ctx.clip();
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = colors.orange;
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            ctx.restore();
                        } else {
                            // Empty ball
                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = colors.orange;
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    }
                } else {
                    // Non-Best Bet cards - tier badge and WIN PROB centered
                    ctx.fillStyle = isElite ? colors.orange : (tier === 'strong' ? colors.navy : colors.textLight);
                    const tierBadgeWidth = 50;
                    roundRect(ctx, rightX - tierBadgeWidth/2, y + 18, tierBadgeWidth, 16, 4);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(tier.toUpperCase(), rightX, y + 29);

                    // Win Prob
                    ctx.fillStyle = isElite ? colors.orange : colors.navy;
                    ctx.font = 'bold 20px sans-serif';
                    ctx.fillText(winProb, rightX, y + 56);

                    // WIN PROB label
                    ctx.fillStyle = colors.textLight;
                    ctx.font = '7px sans-serif';
                    ctx.fillText('WIN PROB', rightX, y + 68);
                }
                ctx.textAlign = 'left';

                // Left side content - more spacing from rank
                const contentX = x + 68;
                const maxTextWidth = cardWidth - 130; // Leave room for right side

                // Pick label - name in navy, line in orange
                ctx.font = 'bold 15px sans-serif';
                ctx.fillStyle = colors.navy;
                const displayName = pickName.substring(0, 16);
                ctx.fillText(displayName, contentX, y + 20);
                // Draw line in orange after the name
                if (pickLine) {
                    const nameWidth = ctx.measureText(displayName + ' ').width;
                    ctx.fillStyle = colors.orange;
                    ctx.fillText(pickLine, contentX + nameWidth, y + 20);
                }

                // Matchup
                ctx.fillStyle = colors.textMuted;
                ctx.font = '10px sans-serif';
                ctx.fillText(matchup.substring(0, 30), contentX, y + 35);

                // Game time
                ctx.fillStyle = colors.navy;
                ctx.font = '600 10px sans-serif';
                ctx.fillText(gameTime, contentX, y + 49);

                // Emoji reason
                ctx.fillStyle = colors.navy;
                ctx.font = '500 10px sans-serif';
                ctx.fillText(emojiReason.substring(0, 26), contentX, y + 63);

                // Model text - subtle divider line above
                if (modelText) {
                    ctx.strokeStyle = '#f0f0f0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(contentX, y + 76);
                    ctx.lineTo(x + cardWidth - 120, y + 76);
                    ctx.stroke();

                    ctx.fillStyle = colors.textMuted;
                    ctx.font = '9px sans-serif';
                    ctx.fillText(modelText.substring(0, 32), contentX, y + 90);
                }
            });

            // Footer with branding
            const footerY = height - 50;
            ctx.fillStyle = '#e2e8f0';
            ctx.fillRect(padding, footerY - 12, width - padding * 2, 1);

            // Footer left - disclaimer
            ctx.fillStyle = colors.textLight;
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('For entertainment only. Not financial advice.', padding, footerY + 8);
            ctx.fillText('Please gamble responsibly.', padding, footerY + 22);

            // Footer center - icon logo
            if (logoIcon) {
                const iconH = 40;
                const iconW = iconH * (logoIcon.width / logoIcon.height);
                ctx.drawImage(logoIcon, (width - iconW) / 2, footerY - 6, iconW, iconH);
            } else {
                ctx.fillStyle = colors.navy;
                ctx.font = 'bold 20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('', width / 2, footerY + 14);
            }

            // Footer right - tagline only
            ctx.fillStyle = colors.navy;
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'right';
            ctx.letterSpacing = '2px';
            ctx.fillText('DATA DON\'T LIE', width - padding, footerY + 14);
            ctx.textAlign = 'left';

            return canvas.toDataURL('image/png');
        }

        // Helper to draw rounded rectangles
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        /**
         * Export Top 10 picks as a PNG image
         */
        async function exportTopTenAsImage(mode = 'desktop') {
            const container = document.getElementById('shareTopTen');
            const exportBtn = document.getElementById('shareDesktopBtn');

            if (!container) {
                showShareToast('Share container not found');
                return;
            }

            // Disable button during export
            if (exportBtn) exportBtn.disabled = true;

            try {
                showShareToast('Preparing Top 10...');

                // Render the shareable content
                const renderResult = await renderShareableTop10(mode);
                if (!renderResult.success) {
                    showShareToast('No picks available - refresh data first');
                    return;
                }

                // Show container for capture
                container.classList.add('share-mode');
                container.setAttribute('aria-hidden', 'false');

                // Small delay to ensure rendering is complete
                await new Promise(r => setTimeout(r, 100));

                // Load capture library
                showShareToast('Loading capture library...');
                const htmlToImage = await loadHtmlToImage();

                // Get the inner content div (new class naming: .ss-container.ss-desktop or .ss-container.ss-mobile)
                const contentDiv = container.querySelector(`.ss-container.ss-${mode}`);
                if (!contentDiv) {
                    throw new Error('Content div not found after rendering');
                }
                console.log('[ShareTop10] Content div found:', contentDiv.className, contentDiv.offsetWidth, 'x', contentDiv.offsetHeight);

                // Capture at 2x scale for retina
                showShareToast('Capturing image...');

                // Detect file:// protocol which causes CORS issues with html-to-image
                const isFileProtocol = window.location.protocol === 'file:';
                let dataUrl;

                if (isFileProtocol) {
                    // For file:// protocol, use simplified canvas capture
                    console.log('[ShareTop10] Using canvas fallback for file:// protocol');
                    showShareToast('Rendering (local mode)...');
                    dataUrl = await captureWithCanvas(contentDiv, mode);
                } else {
                    // For http/https, use html-to-image which handles CSS better
                    console.log('[ShareTop10] Starting capture with htmlToImage.toPng...');
                    try {
                        dataUrl = await htmlToImage.toPng(contentDiv, {
                            pixelRatio: 2,
                            backgroundColor: '#f5f5f5',
                            cacheBust: true,
                            // Skip fetching external images that might cause CORS issues
                            skipFonts: true,
                            // Handle image load failures gracefully
                            imagePlaceholder: undefined
                        });
                    } catch (captureError) {
                        console.warn('[ShareTop10] html-to-image failed, falling back to canvas:', captureError);
                        showShareToast('Rendering (fallback mode)...');
                        dataUrl = await captureWithCanvas(contentDiv, mode);
                    }
                }
                console.log('[ShareTop10] Capture complete, dataUrl length:', dataUrl?.length);

                // Hide container
                container.classList.remove('share-mode');
                container.setAttribute('aria-hidden', 'true');

                // Convert to blob
                const response = await fetch(dataUrl);
                const blob = await response.blob();

                // Generate filename
                const now = new Date();
                const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '');
                const timeStr = now.toTimeString().slice(0, 5).replace(':', '');
                const filename = `spreadsheet-top10-${dateStr}-${timeStr}.png`;

                // Try clipboard first (if supported)
                let clipboardSuccess = false;
                if (navigator.clipboard && navigator.clipboard.write) {
                    try {
                        await navigator.clipboard.write([
                            new ClipboardItem({ 'image/png': blob })
                        ]);
                        clipboardSuccess = true;
                        showShareToast('Copied to clipboard!');
                    } catch (e) {
                        console.warn('Clipboard write failed:', e);
                    }
                }

                // Try native share on mobile
                let shareSuccess = false;
                if (navigator.share && navigator.canShare) {
                    const file = new File([blob], filename, { type: 'image/png' });
                    if (navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                title: 'Top 10 Best Bets - The Spread Sheet',
                                text: 'Check out my Top 10 picks!',
                                files: [file]
                            });
                            shareSuccess = true;
                            showShareToast('Shared successfully!');
                        } catch (e) {
                            if (e.name !== 'AbortError') {
                                console.warn('Share failed:', e);
                            }
                        }
                    }
                }

                // Always offer download if clipboard/share didn't work or as additional option
                if (!clipboardSuccess && !shareSuccess) {
                    // Download the file
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showShareToast(`Downloaded: ${filename}`);
                } else if (clipboardSuccess && !shareSuccess) {
                    // Also download for easy saving
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                // Log coverage
                console.log(`[ShareTop10] Export complete: ${filename}`);
                console.log(`[ShareTop10] Export complete`);

            } catch (error) {
                console.error('[ShareTop10] Export failed:', error);
                // Better error message extraction for various error types
                let errorMsg = 'Unknown error';
                if (error instanceof Error) {
                    errorMsg = error.message || error.name || 'Error occurred';
                } else if (typeof error === 'string') {
                    errorMsg = error;
                } else if (error && typeof error === 'object') {
                    errorMsg = error.message || error.reason || error.toString() || 'Object error';
                }
                console.error('[ShareTop10] Error details:', { type: typeof error, error });
                showShareToast('Export failed: ' + errorMsg);

                // Ensure container is hidden on error
                container.classList.remove('share-mode');
                container.setAttribute('aria-hidden', 'true');
            } finally {
                // Re-enable button
                if (exportBtn) exportBtn.disabled = false;
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async function() {
            loadConfig();

            // Initialize prediction tracker
            try {
                await initPredictionsDB();
                await renderPredictionTracker();
                // Check for weekly backup reminder
                checkWeeklyBackup();
                // Initialize Google Drive sync
                initGoogleAuth();
            } catch (e) {
                console.warn('Could not initialize prediction tracker:', e);
            }
        });
    </script>
    <!-- Back to Top FAB -->
    <button class="back-to-top" id="backToTopFab" onclick="window.scrollTo({top:0,behavior:'smooth'})" title="Back to top" aria-label="Scroll to top"></button>
</body>
</html>
